"/*\r\n"
" * (C) 2022 copyright VoiceAge Corporation. All Rights Reserved.\r\n"
" *\r\n"
" * This software is protected by copyright law and by international treaties. The source code, and all of its derivations,\r\n"
" * is provided by VoiceAge Corporation under the \"ITU-T Software Tools' General Public License\". Please, read the license file\r\n"
" * or refer to ITU-T Recommendation G.191 on \"SOFTWARE TOOLS FOR SPEECH AND AUDIO CODING STANDARDS\".\r\n"
" *\r\n"
" * Any use of this software is permitted provided that this notice is not removed and that neither the authors nor\r\n"
" * VoiceAge Corporation are deemed to have made any representations as to the suitability of this software\r\n"
" * for any purpose nor are held responsible for any defects of this software. THERE IS NO WARRANTY FOR THIS SOFTWARE.\r\n"
" *\r\n"
" * Authors: Guy Richard, Vladimir Malenovsky (Vladimir.Malenovsky@USherbrooke.ca)\r\n"
" */\r\n"
"\r\n"
"#include <stdio.h>\r\n"
"#include <stdlib.h>\r\n"
"#include <string.h>\r\n"
"#include <stdint.h>\r\n"
"#include <sys/stat.h>\r\n"
"\r\n"
"#ifndef _MSC_VER\r\n"
"#include <dirent.h>\r\n"
"#include <errno.h>\r\n"
"#else\r\n"
" #include <windows.h>\r\n"
"#endif\r\n"
"\r\n"
"#include \"options.h\"\r\n"
"#include \"wmc_auto.h\"\r\n"
"\r\n"
"  \r\n"
"/*-------------------------------------------------------------------*\r\n"
" * WMOPS counting tool\r\n"
" *--------------------------------------------------------------------*/\r\n"
"\r\n"
"#ifdef WMOPS\r\n"
"\r\n"
"#define WMC_TOOL_SKIP      /* Skip the instrumentation of this file, if invoked by accident */\r\n"
"\r\n"
"#define MAX_RECORDS     1024\r\n"
"#define MAX_CHAR        64\r\n"
"#define MAX_STACK       64\r\n"
"#define DOUBLE_MAX      0x80000000\r\n"
"\r\n"
"struct wmops_record\r\n"
"{\r\n"
"  char   label[MAX_CHAR];\r\n"
"  long   call_number;\r\n"
"  long   update_cnt;                 \r\n"
"  int    call_tree[MAX_RECORDS];\r\n"
"  double start_selfcnt;\r\n"
"  double current_selfcnt;\r\n"
"  double max_selfcnt;\r\n"
"  double min_selfcnt;\r\n"
"  double tot_selfcnt;\r\n"
"  double start_cnt;     /* The following take into account the decendants */\r\n"
"  double current_cnt;\r\n"
"  double max_cnt;\r\n"
"  double min_cnt;\r\n"
"  double tot_cnt;\r\n"
"};\r\n"
"\r\n"
"double ops_cnt; \r\n"
"double prom_cnt; \r\n"
"double inst_cnt[NUM_INST];\r\n"
"\r\n"
"static struct wmops_record wmops[MAX_RECORDS];\r\n"
"static int stack[MAX_STACK];\r\n"
"static int sptr;\r\n"
"static int num_records;\r\n"
"static int current_record;\r\n"
"static long update_cnt;\r\n"
"static double start_cnt;\r\n"
"static double max_cnt;\r\n"
"static double min_cnt;\r\n"
"static double inst_cnt_wc[NUM_INST];\r\n"
"static long fnum_cnt_wc; \r\n"
"\r\n"
"\r\n"
"void reset_wmops (void)\r\n"
"{\r\n"
"  int i, j;\r\n"
"\r\n"
"  for (i = 0; i < MAX_RECORDS; i++)\r\n"
"  {\r\n"
"    strcpy(&wmops[i].label[0], \"\\0\");\r\n"
"    wmops[i].call_number = 0;\r\n"
"    wmops[i].update_cnt = 0;           \r\n"
"    for (j = 0; j < MAX_RECORDS; j++)\r\n"
"    {\r\n"
"      wmops[i].call_tree[j] = -1;\r\n"
"    }\r\n"
"    wmops[i].start_selfcnt = 0.0;\r\n"
"    wmops[i].current_selfcnt = 0.0;\r\n"
"    wmops[i].max_selfcnt = 0.0;\r\n"
"    wmops[i].min_selfcnt = DOUBLE_MAX;\r\n"
"    wmops[i].tot_selfcnt = 0.0;\r\n"
"    wmops[i].start_cnt = 0.0;\r\n"
"    wmops[i].current_cnt = 0.0;\r\n"
"    wmops[i].max_cnt = 0.0;\r\n"
"    wmops[i].min_cnt = DOUBLE_MAX;\r\n"
"    wmops[i].tot_cnt = 0.0;\r\n"
"  }\r\n"
"\r\n"
"  for (i = 0; i < MAX_STACK; i++)\r\n"
"  {\r\n"
"    stack[i] = -1;\r\n"
"  }\r\n"
"  sptr = 0;\r\n"
"  num_records = 0;\r\n"
"  current_record = -1;\r\n"
"  update_cnt = 0;\r\n"
"\r\n"
"  max_cnt = 0.0;\r\n"
"  min_cnt = DOUBLE_MAX;\r\n"
"  start_cnt = 0.0;\r\n"
"  ops_cnt = 0.0;\r\n"
"}\r\n"
"\r\n"
"\r\n"
"void push_wmops (const char *label)\r\n"
"{\r\n"
"  int new_flag;\r\n"
"  int i, j;\r\n"
"\r\n"
"  /* Check if new function record label */\r\n"
"  new_flag = 1;\r\n"
"  for (i = 0; i < num_records; i++)\r\n"
"  {\r\n"
"      if (strcmp(wmops[i].label, label) == 0)\r\n"
"      {\r\n"
"          new_flag = 0;\r\n"
"          break;\r\n"
"      }\r\n"
"  }\r\n"
"\r\n"
"  /* Configure new record */\r\n"
"  if (new_flag)\r\n"
"  {\r\n"
"      if (num_records >= MAX_RECORDS)\r\n"
"      {\r\n"
"          fprintf(stdout, \"push_wmops(): exceeded MAX_RECORDS count.\\n\\n\");\r\n"
"          exit(-1);\r\n"
"      }\r\n"
"      strcpy(wmops[i].label, label);\r\n"
"      num_records++;\r\n"
"  }\r\n"
"\r\n"
"  /* Push current context onto stack */\r\n"
"  if (current_record >= 0)\r\n"
"  {\r\n"
"      if (sptr >= MAX_STACK)\r\n"
"      {\r\n"
"          fprintf(stdout, \"\\r push_wmops(): stack exceeded, try inreasing MAX_STACK\\n\");\r\n"
"          exit(-1);\r\n"
"      }\r\n"
"      stack[sptr++] = current_record;\r\n"
"\r\n"
"      /* accumulate op counts */\r\n"
"      wmops[current_record].current_selfcnt += ops_cnt - wmops[current_record].start_selfcnt;\r\n"
"\r\n"
"      /* update call tree */\r\n"
"      for (j = 0; j < MAX_RECORDS; j++)\r\n"
"      {\r\n"
"          if (wmops[i].call_tree[j] == current_record)\r\n"
"          {\r\n"
"              break;\r\n"
"          }\r\n"
"          else if (wmops[i].call_tree[j] == -1)\r\n"
"          {\r\n"
"              wmops[i].call_tree[j] = current_record;\r\n"
"              break;\r\n"
"          }\r\n"
"      }\r\n"
"  }\r\n"
"\r\n"
"  /* init current record */\r\n"
"  current_record = i;\r\n"
"  wmops[current_record].start_selfcnt = ops_cnt;\r\n"
"  wmops[current_record].start_cnt = ops_cnt;\r\n"
"  wmops[current_record].call_number++;\r\n"
"\r\n"
"  return;\r\n"
"}\r\n"
"\r\n"
"\r\n"
"void pop_wmops (void)\r\n"
"{\r\n"
"\r\n"
"  /* Check for underflow */\r\n"
"  if (current_record < 0)\r\n"
"  {\r\n"
"     fprintf (stdout, \"\\r pop_wmops(): stack underflow, too many calls to pop_wmops()\\n\");\r\n"
"     exit (-1);\r\n"
"  }\r\n"
"\r\n"
"  /* update count of current record */\r\n"
"  wmops[current_record].current_selfcnt += ops_cnt - wmops[current_record].start_selfcnt;\r\n"
"  wmops[current_record].current_cnt += ops_cnt - wmops[current_record].start_cnt;\r\n"
"\r\n"
"  /* Get back previous context from stack */\r\n"
"  if (sptr > 0)\r\n"
"  {\r\n"
"     current_record = stack[--sptr];\r\n"
"     wmops[current_record].start_selfcnt = ops_cnt;\r\n"
"  }\r\n"
"  else\r\n"
"  {\r\n"
"     current_record = -1;\r\n"
"  }\r\n"
"\r\n"
"  return;\r\n"
"}\r\n"
"\r\n"
"\r\n"
"void update_wmops (void)\r\n"
"{\r\n"
"  int i;\r\n"
"  double current_cnt;\r\n"
"\r\n"
"  if ( sptr != 0 )\r\n"
"  {\r\n"
"      fprintf (stdout, \"update_wmops(): Stack must be empty!\\n\");\r\n"
"      exit (-1);\r\n"
"  }\r\n"
"\r\n"
"  for (i = 0; i < num_records; i++)\r\n"
"  {\r\n"
"      wmops[i].tot_selfcnt += wmops[i].current_selfcnt;\r\n"
"      wmops[i].tot_cnt += wmops[i].current_cnt;\r\n"
"\r\n"
"      if (wmops[i].current_selfcnt > 0)\r\n"
"      {\r\n"
"          if (wmops[i].current_selfcnt > wmops[i].max_selfcnt)\r\n"
"          {\r\n"
"              wmops[i].max_selfcnt = wmops[i].current_selfcnt;\r\n"
"          }\r\n"
"\r\n"
"          if (wmops[i].current_selfcnt < wmops[i].min_selfcnt)\r\n"
"          {\r\n"
"              wmops[i].min_selfcnt = wmops[i].current_selfcnt;\r\n"
"          }\r\n"
"      }\r\n"
"\r\n"
"      wmops[i].current_selfcnt = 0;\r\n"
"\r\n"
"      if (wmops[i].current_cnt > 0)\r\n"
"      {\r\n"
"          if (wmops[i].current_cnt > wmops[i].max_cnt)\r\n"
"          {\r\n"
"              wmops[i].max_cnt = wmops[i].current_cnt;\r\n"
"          }\r\n"
"\r\n"
"          if (wmops[i].current_cnt < wmops[i].min_cnt)\r\n"
"          {\r\n"
"              wmops[i].min_cnt = wmops[i].current_cnt;\r\n"
"          }\r\n"
"\r\n"
"          wmops[i].update_cnt++;\r\n"
"      }\r\n"
"\r\n"
"      wmops[i].current_cnt = 0;\r\n"
"  }\r\n"
"\r\n"
"  current_cnt = ops_cnt - start_cnt;\r\n"
"  if (current_cnt > max_cnt)\r\n"
"  {\r\n"
"      max_cnt = current_cnt;\r\n"
"\r\n"
"      for (i = 0; i < NUM_INST; i++)\r\n"
"      {\r\n"
"          inst_cnt_wc[i] = inst_cnt[i];\r\n"
"      }\r\n"
"\r\n"
"      fnum_cnt_wc = update_cnt + 1;\r\n"
"  }\r\n"
"\r\n"
"  if (current_cnt < min_cnt)\r\n"
"  {\r\n"
"      min_cnt = current_cnt;\r\n"
"  }\r\n"
"\r\n"
"  for (i = 0; i < NUM_INST; i++)\r\n"
"  {\r\n"
"      inst_cnt[i] = 0.0;\r\n"
"  }\r\n"
"\r\n"
"  start_cnt = ops_cnt;\r\n"
"  update_cnt++;\r\n"
"\r\n"
"  return;\r\n"
"}\r\n"
"\r\n"
"\r\n"
"void print_wmops (void)\r\n"
"{\r\n"
"  int i;\r\n"
"\r\n"
"  char *sfmts = \"%20s %8s %8s %7s %7s\\n\";\r\n"
"  char *dfmts = \"%20s %8.2f %8.3f %7.3f %7.3f\\n\";\r\n"
"  char *sfmt =  \"%20s %8s %8s %7s %7s  %7s %7s %7s\\n\";\r\n"
"  char *dfmt =  \"%20s %8.2f %8.3f %7.3f %7.3f  %7.3f %7.3f %7.3f\\n\";\r\n"
"\r\n"
"#if ENABLE_TREE\r\n"
"\r\n"
"  int j;\r\n"
"  char *sfmtt =  \"%20s %4s %15s\\n\";\r\n"
"  char *dfmtt =  \"%20s %4d  \";\r\n"
"\r\n"
"#endif\r\n"
"\r\n"
"  fprintf(stdout, \"\\n\\n --- Weighted MOPS Analysis ---  \\n\\n\");\r\n"
"  fprintf(stdout, \"WMOPS boost factor: %4.2f\\n\\n\", WMOPS_BOOST_FAC);\r\n"
"\r\n"
"  fprintf(stdout, \"%54s  %23s\\n\", \"|------  SELF  ------|\"\r\n"
"                                  ,\"|---  CUMULATIVE  ---|\");\r\n"
"  fprintf(stdout, sfmt, \"        routine\", \" calls\", \"  min \", \"  max \", \"  avg \", \"  min \", \"  max \", \"  avg \");\r\n"
"  fprintf(stdout, sfmt, \"---------------\", \"------\", \"------\", \"------\", \"------\", \"------\", \"------\", \"------\");\r\n"
"  for (i = 0; i < num_records; i++)\r\n"
"  {\r\n"
"      fprintf(stdout, dfmt,\r\n"
"          wmops[i].label,\r\n"
"          (float)wmops[i].call_number / update_cnt,\r\n"
"          FAC * wmops[i].min_selfcnt,\r\n"
"          FAC * wmops[i].max_selfcnt,\r\n"
"          /* FAC*wmops[i].tot_selfcnt/update_cnt, */\r\n"
"          FAC * wmops[i].tot_selfcnt / wmops[i].update_cnt,             /* added -- JPA */\r\n"
"          FAC * wmops[i].min_cnt,\r\n"
"          FAC * wmops[i].max_cnt,\r\n"
"          /* FAC*wmops[i].tot_cnt/update_cnt); */\r\n"
"          FAC * wmops[i].tot_cnt / wmops[i].update_cnt);                /* added -- JPA */\r\n"
"  }\r\n"
"  fprintf (stdout, sfmts, \"---------------\", \"------\", \"------\", \"------\", \"------\");\r\n"
"  fprintf (stdout, dfmts, \r\n"
"           \"total\",\r\n"
"           (float)update_cnt,\r\n"
"           FAC*min_cnt,\r\n"
"           FAC*max_cnt,\r\n"
"           FAC*ops_cnt/update_cnt);\r\n"
"  fprintf (stdout, \"\\n\"); \r\n"
"\r\n"
"#if ENABLE_TREE\r\n"
"  fprintf (stdout, \"\\nCall Tree:\\n\\n\");\r\n"
"  fprintf (stdout, sfmtt, \"       function\", \"num\", \"called by:    \");\r\n"
"  fprintf (stdout, sfmtt, \"---------------\", \"---\", \"--------------\");\r\n"
"\r\n"
"  for (i = 0; i < num_records; i++)\r\n"
"    {\r\n"
"      fprintf (stdout, dfmtt, wmops[i].label, i);\r\n"
"      for (j = 0; wmops[i].call_tree[j] != -1; j++)\r\n"
"        {\r\n"
"          if (j != 0)\r\n"
"            {\r\n"
"              fprintf (stdout, \", \");\r\n"
"            }\r\n"
"          fprintf (stdout, \"%d\", wmops[i].call_tree[j]);\r\n"
"        }\r\n"
"      fprintf (stdout, \"\\n\");\r\n"
"\r\n"
"    }\r\n"
"\r\n"
"  fprintf (stdout, sfmtt, \"---------------\", \"---\", \"--------------\");\r\n"
"  fprintf (stdout, \"\\n\\n\");\r\n"
"\r\n"
"  fprintf(stdout, \"\\nInstruction Type Analysis (for worst case frame #%ld):\\n\\n\", fnum_cnt_wc);   /* added -- JPA */\r\n"
"  for (i = 0; i < NUM_INST; i++)\r\n"
"  {\r\n"
"      switch ((enum instructions)i)\r\n"
"      {\r\n"
"      case _ADD:       fprintf(stdout, \"\\tAdds:          %12.1f\\n\", inst_cnt_wc[i]);  break;\r\n"
"      case _ABS:       fprintf(stdout, \"\\tAbsolutes:     %12.1f\\n\", inst_cnt_wc[i]);  break;\r\n"
"      case _MULT:      fprintf(stdout, \"\\tMultiplies:    %12.1f\\n\", inst_cnt_wc[i]);  break;\r\n"
"      case _MAC:       fprintf(stdout, \"\\tMACs:          %12.1f\\n\", inst_cnt_wc[i]);  break;\r\n"
"      case _MOVE:      fprintf(stdout, \"\\tMoves:         %12.1f\\n\", inst_cnt_wc[i]);  break;\r\n"
"      case _STORE:     fprintf(stdout, \"\\tStores:        %12.1f\\n\", inst_cnt_wc[i]);  break;\r\n"
"      case _LOGIC:     fprintf(stdout, \"\\tLogicals:      %12.1f\\n\", inst_cnt_wc[i]);  break;\r\n"
"      case _SHIFT:     fprintf(stdout, \"\\tShifts:        %12.1f\\n\", inst_cnt_wc[i]);  break;\r\n"
"      case _BRANCH:    fprintf(stdout, \"\\tBranches:      %12.1f\\n\", inst_cnt_wc[i]);  break;\r\n"
"      case _DIV:       fprintf(stdout, \"\\tDivisions:     %12.1f\\n\", inst_cnt_wc[i]);  break;\r\n"
"      case _SQRT:      fprintf(stdout, \"\\tSquare Root:   %12.1f\\n\", inst_cnt_wc[i]);  break;\r\n"
"      case _TRANS:     fprintf(stdout, \"\\tTrans:         %12.1f\\n\", inst_cnt_wc[i]);  break;\r\n"
"      case _FUNC:      fprintf(stdout, \"\\tFunc Call:     %12.1f\\n\", inst_cnt_wc[i]);  break;\r\n"
"      case _LOOP:      fprintf(stdout, \"\\tLoop Init:     %12.1f\\n\", inst_cnt_wc[i]);  break;\r\n"
"      case _INDIRECT:  fprintf(stdout, \"\\tIndirect Addr: %12.1f\\n\", inst_cnt_wc[i]);  break;\r\n"
"      case _PTR_INIT:  fprintf(stdout, \"\\tPointer Init:  %12.1f\\n\", inst_cnt_wc[i]);  break;\r\n"
"      case _TEST:      fprintf(stdout, \"\\tExtra condit.: %12.1f\\n\", inst_cnt_wc[i]);  break;\r\n"
"      case _POWER:     fprintf(stdout, \"\\tExponential:   %12.1f\\n\", inst_cnt_wc[i]);  break;\r\n"
"      case _LOG:       fprintf(stdout, \"\\tLogarithm:     %12.1f\\n\", inst_cnt_wc[i]);  break;\r\n"
"      case _MISC:      fprintf(stdout, \"\\tAll other op.: %12.1f\\n\", inst_cnt_wc[i]);  break;\r\n"
"      default:         fprintf(stdout, \"\\tERROR: Invalid instruction type: %d\\n\\n\", i);\r\n"
"      }\r\n"
"  }\r\n"
"#endif\r\n"
"\r\n"
"  return;\r\n"
"}\r\n"
"\r\n"
"\r\n"
"/*-------------------------------------------------------------------*\r\n"
" * Memory counting tool measuring RAM usage (stack and heap)\r\n"
" *\r\n"
" * Maximum RAM is measured by monitoring the total allocated memory (stack and heap) in each frame.\r\n"
" * \r\n"
" * Maximum stack is measured by monitoring the difference between the 'top' and 'bottom' of the stack. The 'bottom' of the stack is updated in each function\r\n"
" * with a macro 'func_start_' which is inserted automatically to all functions during the instrumentation process.\r\n"
" * \r\n"
" * Maximum heap is measured by summing the sizes of all memory blocks allocated by malloc() or calloc() and deallocated by free(). The maximum heap size is \r\n"
" * updated each time when the macros malloc_() or calloc_() is invoked. The macros 'malloc_ and calloc_' are inserted automatically during the instrumentation process.\r\n"
" * As part of heap measurements, intra-frame heap and inter-frame heap are measured separately. Intra-frame heap refers to heap memory which is allocated and deallocated\r\n"
" * within a single frame. Inter-frame heap, on the contrary, refers to heap memory which is preserved for more than one frame.\r\n"
" * \r\n"
" * In order to run the memory counting tool the function reset_mem(cnt_size) must be called at the beginning of the encoding/decoding process.\r\n"
" * The unit in which memory consumption is reported is set via the parameter 'cnt_size'. It can be set to 0 (bytes), 1 (32b words) or 2 (64b words).\r\n"
" * At the end of the encoding/decoding process, 'print_mem()' function may be called to print basic information about memory consumption. If the macro 'MEM_COUNT_DETAILS'\r\n"
" * is activated, detailed information is printed\r\n"
" *\r\n"
" * The macro 'WMOPS' needs to be activated to enable memory counting. To avoid the instrumentation of malloc()/calloc()/free() calls, use \r\n"
" * #define WMC_TOOL_SKIP ... #undef WMC_TOOL_SKIP macro pair around the malloc(), calloc() and free().\r\n"
" *--------------------------------------------------------------------*/\r\n"
"\r\n"
"#define MAX_RECORDABLE_CALLS            40\r\n"
"#define MAX_FUNCTION_NAME_LENGTH        35  /* Maximum length that the function string will be truncated to */\r\n"
"#define MAX_PARAMS_LENGTH               50  /* Maximum length that the parameter string will be truncated to */\r\n"
"#define MAX_NUM_RECORDS                 300 /* Initial maximum number of memory records -> mightb be increased during runtime, if needed */\r\n"
"#define MAX_NUM_RECORDS_REALLOC_STEP    10  /* When re-allocating the list of memory records, increase the number of records by this number */\r\n"
"\r\n"
" /* This is the value (in bytes) towards which the block size is rounded. For example, a block of 123 bytes, when using\r\n"
"    a 32 bits system, will end up taking 124 bytes since the last unused byte cannot be used for another block. */\r\n"
"#ifdef MEM_ALIGN_64BITS\r\n"
"#define BLOCK_ROUNDING 8        /* Align on 64 Bits */\r\n"
"#else \r\n"
"#define BLOCK_ROUNDING 4        /* Align on 32 Bits */\r\n"
"#endif\r\n"
"\r\n"
"#define N_32BITS_BLOCKS ( BLOCK_ROUNDING / sizeof( int32_t ) )\r\n"
"\r\n"
"#define MAGIC_VALUE_OOB                 0x12A534F0           /* Signature value which is inserted before and after each allocated memory block, used to detect out-of-bound access */\r\n"
"#define MAGIC_VALUE_USED                ( ~MAGIC_VALUE_OOB ) /* Value used to pre-fill allocated memory blocks, used to calculate actual memory usage */\r\n"
"#define OOB_START                       0x1                  /* Flag indicating out-of-bounds access before memory block */\r\n"
"#define OOB_END                         0x2                  /* Flag indicating out-of-bounds access after memory block */\r\n"
"\r\n"
"#define ROUND_BLOCK_SIZE( n )           ( ( ( n ) + BLOCK_ROUNDING - 1 ) & ~( BLOCK_ROUNDING - 1 ) )\r\n"
"#define IS_CALLOC( str )                ( str[0] == 'c' )\r\n"
"\r\n"
"typedef struct\r\n"
"{\r\n"
"    char function_name[MAX_FUNCTION_NAME_LENGTH + 1];\r\n"
"    int16_t* stack_ptr;\r\n"
"} caller_info;\r\n"
"\r\n"
"caller_info stack_callers[2][MAX_RECORDABLE_CALLS];\r\n"
"\r\n"
"typedef struct\r\n"
"{\r\n"
"    char name[MAX_FUNCTION_NAME_LENGTH + 1]; /* +1 for NUL */\r\n"
"    char params[1 + MAX_PARAMS_LENGTH + 1];  /* +1 for 'm'/'c' alloc & +1 for NUL */\r\n"
"    unsigned long hash;\r\n"
"    int lineno;\r\n"
"    void* block_ptr;\r\n"
"    int block_size;\r\n"
"    int max_block_size;                      /* Maximum block size allocated */\r\n"
"    int32_t wc_heap_size[2];                 /* Worst-Case Heap [Frame#, Size] */\r\n"
"    int32_t wc_heap_size_intra_frame[2];     /* Worst-Case Intra-Frame Heap [Frame#, Size] */\r\n"
"    int32_t wc_heap_size_inter_frame[2];     /* Worst-Case Inter-Frame Heap [Frame#, Size] */\r\n"
"    int frame_allocated;                     /* Frame number in which the Memory Block has been allocated */\r\n"
"    float ave_usage;                         /* Average Usage of memory block calculated as ratio of used size and allocated size */\r\n"
"    int OOB_Flag;\r\n"
"    int noccurances;                         /* Numer of times that the Memory Block Was Allocated */\r\n"
"} allocator_record;\r\n"
"\r\n"
"allocator_record* allocation_list = NULL, * peak_allocations, * peak_allocations_one_frame, * peak_allocations_state;\r\n"
"\r\n"
"static int16_t* ptr_base_stack = 0;                /* Pointer to the bottom of stack (base pointer). Stack grows up. */\r\n"
"static int16_t* ptr_max_stack = 0;                 /* Pointer to the maximum stack pointer (the farest point from the bottom of stack) */\r\n"
"static int32_t wc_frame = 0;                       /* Frame corresponding to the worst-case stack usage */\r\n"
"static int32_t wc_ram_size, wc_ram_frame;\r\n"
"static int32_t current_heap_size, wc_heap_size[2], wc_heap_size_intra_frame[2], wc_heap_size_inter_frame[2];\r\n"
"static int current_calls = 0;\r\n"
"static char location_max_stack[256] = \"undefined\";\r\n"
"static int Num_Records;\r\n"
"static size_t Stat_Cnt_Size = USE_BYTES;\r\n"
"static int Max_Num_Records;\r\n"
"static const char* Count_Unit[] = { \"bytes\", \"words\", \"words\" };\r\n"
"\r\n"
"/* Local Functions */\r\n"
"static unsigned long malloc_hash(const char* func_name, int func_lineno, char* size_str);\r\n"
"allocator_record* get_mem_record(unsigned long* hash, const char* func_name, int func_lineno, char* size_str);\r\n"
"static void* mem_alloc_block(size_t size, const char* size_str);\r\n"
"\r\n"
"/*-------------------------------------------------------------------*\r\n"
" * reset_mem()\r\n"
" *\r\n"
" * Initialize/reset memory counting tool (stack and heap)\r\n"
" *--------------------------------------------------------------------*/\r\n"
"\r\n"
"void reset_mem(Counting_Size cnt_size)\r\n"
"{\r\n"
"    int16_t something;\r\n"
"    size_t tmp_size;\r\n"
"\r\n"
"    /* initialize stack pointers */\r\n"
"    ptr_base_stack = &something;\r\n"
"    ptr_max_stack = ptr_base_stack;\r\n"
"\r\n"
"    Stat_Cnt_Size = cnt_size;\r\n"
"\r\n"
"    /* Check, if sizeof(int32_t) is 4 bytes */\r\n"
"    tmp_size = sizeof(int32_t);\r\n"
"    if (tmp_size != 4)\r\n"
"    {\r\n"
"        printf(\"Error: Expecting 'int32_t' to be a 32 Bits Integer!\");\r\n"
"        exit(-1);\r\n"
"    }\r\n"
"\r\n"
"    /* create allocation list for malloc() memory blocks */\r\n"
"    if (allocation_list == NULL)\r\n"
"    {\r\n"
"        allocation_list = malloc(MAX_NUM_RECORDS * sizeof(allocator_record));\r\n"
"    }\r\n"
"\r\n"
"    if (allocation_list == NULL)\r\n"
"    {\r\n"
"        printf(\"Error: Unable to Create List of Memory Blocks!\");\r\n"
"        exit(-1);\r\n"
"    }\r\n"
"\r\n"
"    Num_Records = 0;\r\n"
"    Max_Num_Records = MAX_NUM_RECORDS;\r\n"
"\r\n"
"    wc_ram_size = 0;\r\n"
"    wc_ram_frame = -1;\r\n"
"    current_heap_size = 0;\r\n"
"    wc_heap_size[0] = -1;\r\n"
"    wc_heap_size[1] = 0;\r\n"
"    wc_heap_size_intra_frame[0] = -1;\r\n"
"    wc_heap_size_intra_frame[1] = 0;\r\n"
"    wc_heap_size_inter_frame[0] = -1;\r\n"
"    wc_heap_size_inter_frame[1] = 0;\r\n"
"\r\n"
"    return;\r\n"
"}\r\n"
"\r\n"
"/*-------------------------------------------------------------------*\r\n"
" * reset_stack()\r\n"
" *\r\n"
" * Reset stack pointer\r\n"
" *--------------------------------------------------------------------*/\r\n"
"\r\n"
"void reset_stack(void)\r\n"
"{\r\n"
"    int16_t something;\r\n"
"\r\n"
"    /* initialize/reset stack pointers */\r\n"
"    ptr_base_stack = &something;\r\n"
"    ptr_max_stack = ptr_base_stack;\r\n"
"\r\n"
"    return;\r\n"
"}\r\n"
"\r\n"
"/*-------------------------------------------------------------------*\r\n"
" * push_stack()\r\n"
" *\r\n"
" * Check the current stack pointer and update the maximum stack pointer, if new maximum found.\r\n"
" *--------------------------------------------------------------------*/\r\n"
"\r\n"
"int push_stack(const char* filename, const char* fctname)\r\n"
"{\r\n"
"    int16_t something;\r\n"
"    int32_t current_stack_size;\r\n"
"\r\n"
"    (void)*filename; /* to avoid compilation warning */\r\n"
"\r\n"
"    /* Is there room to save the caller's information? */\r\n"
"    if (current_calls >= MAX_RECORDABLE_CALLS)\r\n"
"    { /* No */\r\n"
"        fprintf(stderr, \"No more room to store call stack info. Please increase MAX_RECORDABLE_CALLS\");\r\n"
"        exit(-1);\r\n"
"    }\r\n"
"\r\n"
"    /* Valid Function Name? */\r\n"
"    if (fctname[0] == 0)\r\n"
"    { /* No */\r\n"
"        fprintf(stderr, \"Invalid function name for call stack info.\");\r\n"
"        exit(-1);\r\n"
"    }\r\n"
"\r\n"
"    /* Save the Name of the Calling Function in the Table */\r\n"
"    strncpy(stack_callers[0][current_calls].function_name, fctname, MAX_FUNCTION_NAME_LENGTH);\r\n"
"    stack_callers[0][current_calls].function_name[MAX_FUNCTION_NAME_LENGTH] = 0; /* Nul Terminate */\r\n"
"\r\n"
"    /* Save the Stack Pointer */\r\n"
"    stack_callers[0][current_calls].stack_ptr = &something;\r\n"
"\r\n"
"    /* Increase Stack Calling Tree Level */\r\n"
"    current_calls++;\r\n"
"\r\n"
"    /* Is this the First Time or the Worst Case? */\r\n"
"    if (&something < ptr_max_stack || ptr_max_stack == NULL)\r\n"
"    { /* Yes */\r\n"
"        /* Save Info about it */\r\n"
"        ptr_max_stack = &something;\r\n"
"\r\n"
"        //wc_frame = frame;\r\n"
"        wc_frame = update_cnt;          /* current frame number is stored in the variable update_cnt and updated in the function update_wmops() */\r\n"
"        strncpy(location_max_stack, fctname, sizeof(location_max_stack) - 1);\r\n"
"        location_max_stack[sizeof(location_max_stack) - 1] = '\\0';\r\n"
"\r\n"
"        /* Save Call Tree */\r\n"
"        memmove(stack_callers[1], stack_callers[0], sizeof(caller_info) * current_calls);\r\n"
"\r\n"
"        /* Terminate the List (Unless Full) */\r\n"
"        if (current_calls < MAX_RECORDABLE_CALLS)\r\n"
"        {\r\n"
"            stack_callers[1][current_calls].function_name[0] = 0;\r\n"
"        }\r\n"
"    }\r\n"
"\r\n"
"    /* Check, if This is the New Worst-Case RAM (stack + heap) */\r\n"
"    current_stack_size = (int32_t)(((ptr_base_stack - ptr_max_stack) * sizeof(int16_t)));\r\n"
"    if (current_stack_size + current_heap_size > wc_ram_size)\r\n"
"    {\r\n"
"        wc_ram_size = current_stack_size + current_heap_size;\r\n"
"        wc_ram_frame = update_cnt;\r\n"
"    }\r\n"
"\r\n"
"    return 0 /* for Now */;\r\n"
"}\r\n"
"\r\n"
"/*-------------------------------------------------------------------*\r\n"
" * pop_stack()\r\n"
" *\r\n"
" * Remove stack caller entry from the list\r\n"
" *--------------------------------------------------------------------*/\r\n"
"\r\n"
"int pop_stack(const char* filename, const char* fctname)\r\n"
"{\r\n"
"    caller_info* caller_info_ptr;\r\n"
"\r\n"
"    (void)*filename; /* to avoid compilation warning */\r\n"
"\r\n"
"    /* Decrease Stack Calling */\r\n"
"    current_calls--;\r\n"
"\r\n"
"    /* Get Pointer to Caller Information */\r\n"
"    caller_info_ptr = &stack_callers[0][current_calls];\r\n"
"\r\n"
"    /* Check, if Names Match */\r\n"
"    if (strncmp(caller_info_ptr->function_name, fctname, MAX_FUNCTION_NAME_LENGTH) != 0)\r\n"
"    {\r\n"
"        fprintf(stderr, \"Invalid usage of pop_stack()\");\r\n"
"        exit(-1);\r\n"
"    }\r\n"
"\r\n"
"    /* Erase Entry */\r\n"
"    caller_info_ptr->function_name[0] = 0;\r\n"
"\r\n"
"    return 0 /* for Now */;\r\n"
"}\r\n"
"\r\n"
"#ifdef MEM_COUNT_DETAILS\r\n"
"/*-------------------------------------------------------------------*\r\n"
" * print_stack_call_tree()\r\n"
" *\r\n"
" * Print detailed information about worst-case stack usage\r\n"
" *--------------------------------------------------------------------*/\r\n"
"\r\n"
"static void print_stack_call_tree(void)\r\n"
"{\r\n"
"    caller_info* caller_info_ptr;\r\n"
"    int call_level;\r\n"
"\r\n"
"    fprintf(stdout, \"Stack Call Tree (frame #%d):\\n\", wc_frame);\r\n"
"    caller_info_ptr = &stack_callers[1][0];\r\n"
"    for (call_level = 0; call_level < MAX_RECORDABLE_CALLS; call_level++)\r\n"
"    {\r\n"
"        /* Done? */\r\n"
"        if (caller_info_ptr->function_name[0] == 0)\r\n"
"            break;\r\n"
"\r\n"
"        /* Print Name */\r\n"
"        fprintf(stdout, \"%-42s\", caller_info_ptr->function_name);\r\n"
"\r\n"
"        /* Print Stack Usage (Based on Difference) */\r\n"
"        if (call_level != 0)\r\n"
"        {\r\n"
"            fprintf(stdout, \"%ld\\n\", ((caller_info_ptr - 1)->stack_ptr - caller_info_ptr->stack_ptr) * sizeof(int16_t) / sizeof(float));\r\n"
"        }\r\n"
"        else\r\n"
"        {\r\n"
"            fprintf(stdout, \"\\n\");\r\n"
"        }\r\n"
"\r\n"
"        /* Advance */\r\n"
"        caller_info_ptr++;\r\n"
"    }\r\n"
"\r\n"
"    fprintf(stdout, \"\\n\");\r\n"
"\r\n"
"    return;\r\n"
"}\r\n"
"#endif\r\n"
"\r\n"
"\r\n"
"/*-------------------------------------------------------------------*\r\n"
" * mem_alloc()\r\n"
" *\r\n"
" * Creates new record, stores auxiliary information about which function allocated the memory, line number, parameters, etc.\r\n"
" * Finally, it allocates physical memory using malloc()\r\n"
" * The function also updates worst-case heap size and worst-case RAM size\r\n"
" *--------------------------------------------------------------------*/\r\n"
"\r\n"
"void* mem_alloc(\r\n"
"    const char* func_name,\r\n"
"    int func_lineno,\r\n"
"    size_t size,\r\n"
"    char* size_str /* the first char indicates m-alloc or c-alloc */)\r\n"
"{\r\n"
"    int i;\r\n"
"    int32_t current_stack_size;\r\n"
"    unsigned long hash;\r\n"
"    allocator_record *ptr_record;\r\n"
"\r\n"
"    if (size == 0)\r\n"
"    {\r\n"
"        printf(\"Fct=%s, Ln=%i: %s!\\n\", func_name, func_lineno, \"Size of Zero not Supported\");\r\n"
"        exit(-1);\r\n"
"    }\r\n"
"\r\n"
"    /* Create new record, if not existing */\r\n"
"    if ((ptr_record = get_mem_record(&hash, func_name, func_lineno, size_str)) == NULL)\r\n"
"    {\r\n"
"        if (Num_Records >= Max_Num_Records)\r\n"
"        {\r\n"
"            /* There is no room for a new record -> reallocate memory */\r\n"
"            Max_Num_Records += MAX_NUM_RECORDS_REALLOC_STEP;\r\n"
"            allocation_list = realloc(allocation_list, Max_Num_Records * sizeof(allocator_record));\r\n"
"        }\r\n"
"\r\n"
"        ptr_record = &(allocation_list[Num_Records]);\r\n"
"\r\n"
"        /* Initialize new record */\r\n"
"        ptr_record->hash = hash;\r\n"
"        ptr_record->ave_usage = 0;\r\n"
"        ptr_record->noccurances = 0;\r\n"
"        ptr_record->max_block_size = 0;\r\n"
"        ptr_record->frame_allocated = -1;\r\n"
"        ptr_record->OOB_Flag = 0;\r\n"
"        ptr_record->wc_heap_size[0] = -1;\r\n"
"        ptr_record->wc_heap_size[1] = 0;\r\n"
"        ptr_record->wc_heap_size_intra_frame[0] = -1;\r\n"
"        ptr_record->wc_heap_size_intra_frame[1] = 0;\r\n"
"        ptr_record->wc_heap_size_inter_frame[0] = -1;\r\n"
"        ptr_record->wc_heap_size_inter_frame[1] = 0;\r\n"
"\r\n"
"        Num_Records++;\r\n"
"    }\r\n"
"    else\r\n"
"    {\r\n"
"        printf(\"Record Exists\");\r\n"
"    }\r\n"
"\r\n"
"    /* Allocate memory block for the new record, add signature before the beginning and after the memory block and fill it with magic value */\r\n"
"    ptr_record->block_ptr = mem_alloc_block(size, size_str);\r\n"
"\r\n"
"    if (ptr_record->block_ptr == NULL)\r\n"
"    {\r\n"
"        printf(\"Fct=%s, Ln=%i: %s!\\n\", func_name, func_lineno, \"Error: Cannot Allocate Memory!\");\r\n"
"        exit(-1);\r\n"
"    }\r\n"
"\r\n"
"    /* Save all zuxiliary information about the memory block */\r\n"
"    strncpy(ptr_record->name, func_name, MAX_FUNCTION_NAME_LENGTH);\r\n"
"    ptr_record->name[MAX_FUNCTION_NAME_LENGTH] = '\\0';\r\n"
"    strncpy(ptr_record->params, size_str, MAX_PARAMS_LENGTH);     /* Note: The size string starts with either 'm' or 'c' to indicate 'm'alloc or 'c'alloc */\r\n"
"    ptr_record->params[MAX_PARAMS_LENGTH] = '\\0';\r\n"
"    ptr_record->lineno = func_lineno;\r\n"
"    ptr_record->block_size = size;\r\n"
"\r\n"
"    if (ptr_record->block_size > ptr_record->max_block_size)\r\n"
"    {\r\n"
"        ptr_record->max_block_size = ptr_record->block_size;\r\n"
"    }\r\n"
"\r\n"
"    if (ptr_record->frame_allocated != -1)\r\n"
"    {\r\n"
"        printf(\"Fct=%s, Ln=%i: %s!\\n\", func_name, func_lineno, \"Error: Attempt to Allocate the Same Memory Block with Freeing it First!\");\r\n"
"        exit(-1);\r\n"
"    }\r\n"
"\r\n"
"    ptr_record->frame_allocated = update_cnt;      /* Store the current frame number -> later it will be used to determine the total duration */\r\n"
"    ptr_record->noccurances++;\r\n"
"\r\n"
"    /* Update Heap Size in the current frame */\r\n"
"    current_heap_size += ptr_record->block_size;\r\n"
"\r\n"
"    /* Update Worst-Case Heap Size, if Exceeded */\r\n"
"    if ( current_heap_size > wc_heap_size[1] )\r\n"
"    {\r\n"
"        for (i = 0; i < Num_Records; i++)\r\n"
"        {\r\n"
"            if (allocation_list[i].block_ptr != NULL)\r\n"
"            {\r\n"
"                allocation_list[i].wc_heap_size[0] = update_cnt;\r\n"
"                allocation_list[i].wc_heap_size[1] = allocation_list[i].block_size;\r\n"
"            }\r\n"
"            else\r\n"
"            {\r\n"
"                allocation_list[i].wc_heap_size[0] = -1;\r\n"
"                allocation_list[i].wc_heap_size[1] = 0;\r\n"
"            }\r\n"
"        }\r\n"
"\r\n"
"        wc_heap_size[0] = update_cnt;\r\n"
"        wc_heap_size[1] = current_heap_size;\r\n"
"    }\r\n"
"\r\n"
"    /* Check, if this is the new Worst-Case RAM (stack + heap) */\r\n"
"    current_stack_size = (int32_t)(((ptr_base_stack - ptr_max_stack) * sizeof(int16_t)));\r\n"
"    if (current_stack_size + current_heap_size > wc_ram_size)\r\n"
"    {\r\n"
"        wc_ram_size = current_stack_size + current_heap_size;\r\n"
"        wc_ram_frame = update_cnt;\r\n"
"    }\r\n"
"\r\n"
"    return ptr_record->block_ptr;\r\n"
"}\r\n"
"\r\n"
"/*-------------------------------------------------------------------*\r\n"
" * mem_alloc_block()\r\n"
" *\r\n"
" * Physical allocation of memory using malloc(). Appends 'signature' before and after the block,\r\n"
" * pre-fills memory block with magic value\r\n"
" *--------------------------------------------------------------------*/\r\n"
"\r\n"
"static void *mem_alloc_block(size_t size, const char *size_str)\r\n"
"{\r\n"
"    size_t rounded_size;\r\n"
"    void* block_ptr;\r\n"
"    char* tmp_ptr;\r\n"
"    size_t n, f;\r\n"
"    int32_t fill_value;\r\n"
"    int32_t* ptr32;\r\n"
"    int32_t mask, temp;\r\n"
"\r\n"
"    /* Round Up Block Size */\r\n"
"    rounded_size = ROUND_BLOCK_SIZE(size);\r\n"
"\r\n"
"    /* Allocate memory using the standard malloc() by adding room for Signature Values */\r\n"
"    block_ptr = malloc(rounded_size + BLOCK_ROUNDING * 2);\r\n"
"\r\n"
"    if (block_ptr == NULL)\r\n"
"    {\r\n"
"        return NULL;\r\n"
"    }\r\n"
"\r\n"
"    /* Add Signature Before the Start of the Block */\r\n"
"    ptr32 = (int32_t*)block_ptr;\r\n"
"    n = N_32BITS_BLOCKS;\r\n"
"    do\r\n"
"    {\r\n"
"        *ptr32++ = MAGIC_VALUE_OOB;\r\n"
"    } while (--n);\r\n"
"\r\n"
"    /* Fill Memory Block with Magic Value or 0 */\r\n"
"    fill_value = MAGIC_VALUE_USED;\r\n"
"    if (IS_CALLOC(size_str))\r\n"
"    {\r\n"
"        fill_value = 0x00000000;\r\n"
"    }\r\n"
"    n = size / sizeof(int32_t);\r\n"
"    while (n--)\r\n"
"    {\r\n"
"        *ptr32++ = fill_value;\r\n"
"    }\r\n"
"\r\n"
"    /* Fill the Reminder of the Memory Block - After Rounding */\r\n"
"    n = rounded_size - size;\r\n"
"    f = n % sizeof(int32_t);\r\n"
"    if (f != 0)\r\n"
"    {\r\n"
"        /* when filling with '0' need to adapt the magic value */\r\n"
"        /* shift by [1->24, 2->16, 3->8] */\r\n"
"        mask = 0xFFFFFFFF << ((sizeof(int32_t) - f) * 8); /* (1) */\r\n"
"        temp = MAGIC_VALUE_OOB & mask;\r\n"
"        if (fill_value != 0x0)\r\n"
"        { /* for malloc merge fill value */\r\n"
"            temp += (~mask) & MAGIC_VALUE_USED;\r\n"
"        } /* for calloc the code in (1) above already introduces zeros */\r\n"
"        *ptr32++ = temp;\r\n"
"    }\r\n"
"    n /= sizeof(int32_t);\r\n"
"    n += N_32BITS_BLOCKS;\r\n"
"\r\n"
"    /* Add Signature After the End of Block */\r\n"
"    do\r\n"
"    {\r\n"
"        *ptr32++ = MAGIC_VALUE_OOB;\r\n"
"    } while (--n);\r\n"
"\r\n"
"    /* Adjust the Memory Block Pointer (Magic Value Before and After the Memory Block Requested) */\r\n"
"    tmp_ptr = (char*)block_ptr;\r\n"
"    tmp_ptr += BLOCK_ROUNDING;\r\n"
"    block_ptr = (void*)tmp_ptr;\r\n"
"\r\n"
"    return block_ptr;\r\n"
"}\r\n"
"\r\n"
"/*-------------------------------------------------------------------*\r\n"
" * mem_set_usage()\r\n"
" *\r\n"
" * Calculates actual usage of memory block by checking the magic value that was used to pre-fill \r\n"
" * each memory block during its allocation\r\n"
" *--------------------------------------------------------------------*/\r\n"
"\r\n"
"static int mem_set_usage(allocator_record* record_ptr)\r\n"
"{\r\n"
"    int total_bytes_used;\r\n"
"\r\n"
"    size_t n;\r\n"
"    int32_t* ptr32;\r\n"
"    char* ptr8;\r\n"
"    size_t total_bytes;\r\n"
"    int32_t fill_value;\r\n"
"\r\n"
"    fill_value = MAGIC_VALUE_USED;\r\n"
"    if ((record_ptr->params[0]) == 'c')\r\n"
"    {\r\n"
"        fill_value = 0x00000000;\r\n"
"    }\r\n"
"\r\n"
"    total_bytes = record_ptr->block_size;\r\n"
"\r\n"
"    /* Check 4 bytes at a time */\r\n"
"    ptr32 = (int32_t*)record_ptr->block_ptr;\r\n"
"    total_bytes_used = 0;\r\n"
"    for (n = total_bytes / sizeof(int32_t); n > 0; n--)\r\n"
"    {\r\n"
"        if (*ptr32++ != fill_value)\r\n"
"        {\r\n"
"            total_bytes_used += sizeof(int32_t);\r\n"
"        }\r\n"
"    }\r\n"
"\r\n"
"    /* Check remaining bytes (If Applicable) 1 byte at a time */\r\n"
"    ptr8 = (char*)ptr32;\r\n"
"    for (n = total_bytes % sizeof(int32_t); n > 0; n--)\r\n"
"    {\r\n"
"        if (*ptr8++ != (char)fill_value)\r\n"
"        {\r\n"
"            total_bytes_used++;\r\n"
"        }\r\n"
"\r\n"
"        /* Update Value */\r\n"
"        fill_value >>= 8;\r\n"
"    }\r\n"
"\r\n"
"    return total_bytes_used;\r\n"
"}\r\n"
"\r\n"
"/*-------------------------------------------------------------------*\r\n"
" * mem_check_OOB()\r\n"
" *\r\n"
" * Checks, if out-of-bounds access has occured. This is done by inspecting the 'signature' value\r\n"
" * taht has been added before and after the memory block during its allocation\r\n"
" *--------------------------------------------------------------------*/\r\n"
"\r\n"
"static unsigned int mem_check_OOB(allocator_record* record_ptr)\r\n"
"{\r\n"
"    int32_t* ptr32;\r\n"
"    unsigned int OOB_Flag = 0x0;\r\n"
"    int32_t mask;\r\n"
"    size_t i;\r\n"
"    int f;\r\n"
"\r\n"
"    ptr32 = (int32_t*)record_ptr->block_ptr - N_32BITS_BLOCKS;\r\n"
"\r\n"
"    /* Check the Signature at the Beginning of Memory Block */\r\n"
"    i = N_32BITS_BLOCKS;\r\n"
"    do\r\n"
"    {\r\n"
"        if (*ptr32++ ^ MAGIC_VALUE_OOB)\r\n"
"        {\r\n"
"            OOB_Flag |= OOB_START;\r\n"
"        }\r\n"
"    } while (--i);\r\n"
"\r\n"
"    /* Advance to End (Snap to lowest 32 Bits) */\r\n"
"    ptr32 += record_ptr->block_size / sizeof(int32_t);\r\n"
"\r\n"
"    /* Calculate Unused Space That has been added to get to the rounded Block Size */\r\n"
"    i = ROUND_BLOCK_SIZE(record_ptr->block_size) - record_ptr->block_size;\r\n"
"\r\n"
"    /* Partial Check of Signature at the End of Memory Block (for block size that has been rounded) */\r\n"
"    f = i % sizeof(int32_t);\r\n"
"    if (f != 0)\r\n"
"    {\r\n"
"        mask = 0xFFFFFFFF << ((sizeof(int32_t) - f) * 8);\r\n"
"        if ((*ptr32++ ^ MAGIC_VALUE_OOB) & mask)\r\n"
"        {\r\n"
"            OOB_Flag |= OOB_END;\r\n"
"        }\r\n"
"    }\r\n"
"\r\n"
"    /* Full Check of Signature at the End of Memory Block, i.e. all 32 Bits (for the remainder after rounding) */\r\n"
"    i /= sizeof(int32_t);\r\n"
"    i += N_32BITS_BLOCKS;\r\n"
"    do\r\n"
"    {\r\n"
"        if (*ptr32++ ^ MAGIC_VALUE_OOB)\r\n"
"        {\r\n"
"            OOB_Flag |= OOB_END;\r\n"
"        }\r\n"
"    } while (--i);\r\n"
"\r\n"
"    return OOB_Flag;\r\n"
"}\r\n"
"\r\n"
"/*-------------------------------------------------------------------*\r\n"
" * malloc_hash()\r\n"
" *\r\n"
" * Calculate hash from function name, line number and malloc size\r\n"
" *--------------------------------------------------------------------*/\r\n"
"\r\n"
"static unsigned long malloc_hash( const char* func_name, int func_lineno, char* size_str)\r\n"
"{\r\n"
"    unsigned long hash = 5381;\r\n"
"    const char* ptr_str;\r\n"
"    int c;\r\n"
"\r\n"
"    ptr_str = func_name;\r\n"
"    while (c = *ptr_str++)\r\n"
"    {\r\n"
"        hash = ((hash << 5) + hash) + c; /* hash * 33 + c */\r\n"
"    }\r\n"
"\r\n"
"    hash = ((hash << 5) + hash) + func_lineno; /* hash * 33 + func_lineno */\r\n"
"\r\n"
"    ptr_str = size_str;\r\n"
"    while (c = *ptr_str++)\r\n"
"    {\r\n"
"        hash = ((hash << 5) + hash) + c; /* hash * 33 + c */\r\n"
"    }\r\n"
"\r\n"
"    return hash;\r\n"
"}\r\n"
"\r\n"
"/*-------------------------------------------------------------------*\r\n"
" * get_mem_record()\r\n"
" *\r\n"
" * Search for memory record in the internal list, return NULL if not found \r\n"
" *--------------------------------------------------------------------*/\r\n"
"\r\n"
"allocator_record *get_mem_record(unsigned long *hash, const char* func_name, int func_lineno, char *size_str)\r\n"
"{\r\n"
"    int i;\r\n"
"\r\n"
"    /* calculate hash */\r\n"
"    *hash = malloc_hash(func_name, func_lineno, size_str);\r\n"
"\r\n"
"    for (i = 0; i < Num_Records; i++)\r\n"
"    {\r\n"
"        /* check, if memory block is not allocated at the moment and the hash matches */\r\n"
"        if (allocation_list[i].block_ptr == NULL && *hash == allocation_list[i].hash )\r\n"
"        {\r\n"
"            return &(allocation_list[i]);\r\n"
"        }\r\n"
"    }\r\n"
"\r\n"
"    /* not found */\r\n"
"    return NULL;\r\n"
"}\r\n"
"\r\n"
"/*-------------------------------------------------------------------*\r\n"
" * mem_free()\r\n"
" *\r\n"
" * This function updates worst-case intra-frame memory and worst-case inter-frame memory. It also updates actual and average usage of \r\n"
" * the memory block and finally, it de-allocates the physical memory with free()\r\n"
" * \r\n"
" * Note: The record is not removed from the list and may be reused later on in mem_alloc()!\r\n"
"  *--------------------------------------------------------------------*/\r\n"
"\r\n"
"void mem_free(const char* func_name, int func_lineno, void* ptr)\r\n"
"{\r\n"
"    int i;\r\n"
"    int32_t current_heap_size_intra_frame, current_heap_size_inter_frame;\r\n"
"    float current_usage;\r\n"
"    char* tmp_ptr;\r\n"
"    allocator_record *ptr_record;\r\n"
"\r\n"
"    /* Search for the Block Pointer in the List */\r\n"
"    ptr_record = NULL;\r\n"
"    for (i = 0; i < Num_Records; i++)\r\n"
"    {\r\n"
"        if (ptr == allocation_list[i].block_ptr)\r\n"
"        { /* Yes, Found it */\r\n"
"            ptr_record = &(allocation_list[i]);\r\n"
"            break;\r\n"
"        }\r\n"
"    }\r\n"
"\r\n"
"    if (ptr_record == NULL)\r\n"
"    {\r\n"
"        printf(\"Fct=%s, Ln=%i: %s!\\n\", func_name, func_lineno, \"Error: Unable to Find Record Corresponding to the Allocated Memory Block!\");\r\n"
"        exit(-1);\r\n"
"    }\r\n"
"\r\n"
"    /* Update the Heap Size */\r\n"
"    current_heap_size -= ptr_record->block_size;\r\n"
"\r\n"
"    /* Calculate Intra-Frame Heap Size and Inter-Frame Heap Size in the Current Frame */\r\n"
"    current_heap_size_intra_frame = 0;\r\n"
"    current_heap_size_inter_frame = 0;\r\n"
"    for (i = 0; i < Num_Records; i++)\r\n"
"    {\r\n"
"        if (allocation_list[i].block_ptr != NULL)\r\n"
"        {\r\n"
"            if (allocation_list[i].frame_allocated == update_cnt)\r\n"
"            {\r\n"
"                current_heap_size_intra_frame += allocation_list[i].block_size;\r\n"
"            }\r\n"
"            else\r\n"
"            {\r\n"
"                current_heap_size_inter_frame += allocation_list[i].block_size;\r\n"
"            }\r\n"
"        }\r\n"
"    }\r\n"
"\r\n"
"    /* Update Worst-Case Intra-Frame Heap Size, if Exceeded */\r\n"
"    if (ptr_record->frame_allocated == update_cnt && current_heap_size_intra_frame > wc_heap_size_intra_frame[1])\r\n"
"    {\r\n"
"        for (i = 0; i < Num_Records; i++)\r\n"
"        {\r\n"
"            if (allocation_list[i].block_ptr != NULL)\r\n"
"            {\r\n"
"                allocation_list[i].wc_heap_size_intra_frame[0] = update_cnt;\r\n"
"                allocation_list[i].wc_heap_size_intra_frame[1] = allocation_list[i].block_size;\r\n"
"            }\r\n"
"            else\r\n"
"            {\r\n"
"                allocation_list[i].wc_heap_size_intra_frame[0] = -1;\r\n"
"                allocation_list[i].wc_heap_size_intra_frame[1] = 0;\r\n"
"            }\r\n"
"        }\r\n"
"\r\n"
"        wc_heap_size_intra_frame[0] = update_cnt;\r\n"
"        wc_heap_size_intra_frame[1] = current_heap_size_intra_frame;\r\n"
"    }\r\n"
"\r\n"
"    /* Update Worst-Case Inter-Frame Heap Size, if Exceeded */\r\n"
"    if (ptr_record->frame_allocated < update_cnt && current_heap_size_inter_frame > wc_heap_size_inter_frame[1])\r\n"
"    {\r\n"
"        for (i = 0; i < Num_Records; i++)\r\n"
"        {\r\n"
"            if (allocation_list[i].block_ptr != NULL)\r\n"
"            {\r\n"
"                allocation_list[i].wc_heap_size_inter_frame[0] = update_cnt;\r\n"
"                allocation_list[i].wc_heap_size_inter_frame[1] = allocation_list[i].block_size;\r\n"
"            }\r\n"
"            else\r\n"
"            {\r\n"
"                allocation_list[i].wc_heap_size_inter_frame[0] = -1;\r\n"
"                allocation_list[i].wc_heap_size_inter_frame[1] = 0;\r\n"
"            }\r\n"
"        }\r\n"
"\r\n"
"        wc_heap_size_inter_frame[0] = update_cnt;\r\n"
"        wc_heap_size_inter_frame[1] = current_heap_size_inter_frame;\r\n"
"\r\n"
"    }\r\n"
"\r\n"
"    /* Update the Average Usage of Memory Block (Look for Signature) */\r\n"
"    current_usage = (float) mem_set_usage(ptr_record) / ptr_record->block_size;\r\n"
"    ptr_record->ave_usage = ((ptr_record->noccurances - 1.0f) / ptr_record->noccurances) * ptr_record->ave_usage + (1.0f / ptr_record->noccurances) * current_usage;\r\n"
"\r\n"
"    /* Check, if Out-Of-Bounds Access has been Detected */\r\n"
"    ptr_record->OOB_Flag = mem_check_OOB(ptr_record);\r\n"
"\r\n"
"    /* De-Allocate Memory Block */\r\n"
"    tmp_ptr = (char*)ptr;\r\n"
"    tmp_ptr -= BLOCK_ROUNDING;\r\n"
"    ptr = (void*)tmp_ptr;\r\n"
"    free(ptr); \r\n"
"\r\n"
"    /* Reset some properties of the memory record */\r\n"
"    ptr_record->frame_allocated = -1;\r\n"
"    ptr_record->block_ptr = NULL;\r\n"
"    ptr_record->block_size = 0;\r\n"
"\r\n"
"    return;\r\n"
"}\r\n"
"\r\n"
"#ifdef MEM_COUNT_DETAILS\r\n"
"/*-------------------------------------------------------------------*\r\n"
" * subst()\r\n"
" *\r\n"
" * Substitute character in string\r\n"
" *--------------------------------------------------------------------*/\r\n"
"\r\n"
"static void subst(char* s, char from, char to) \r\n"
"{\r\n"
"    while (*s == from)\r\n"
"    {\r\n"
"        *s++ = to;\r\n"
"    }\r\n"
"\r\n"
"    return;\r\n"
"}\r\n"
"\r\n"
"/*-------------------------------------------------------------------*\r\n"
" * mem_count_summary()\r\n"
" *\r\n"
" * Print detailed (per-item) information about heap memory usage\r\n"
" *--------------------------------------------------------------------*/\r\n"
"\r\n"
"static void mem_count_summary(void)\r\n"
"{\r\n"
"    int i, j, flag_intra_frame_memory;\r\n"
"    size_t length;\r\n"
"    char format_str[50], name_str[MAX_FUNCTION_NAME_LENGTH+1], parms_str[MAX_PARAMS_LENGTH+1], type_str[10], usage_str[20], size_str[20], line_str[10];\r\n"
"    char buf[300];\r\n"
"    allocator_record* record_ptr;\r\n"
"\r\n"
"    /* Prepare format string */\r\n"
"    sprintf(format_str, \"%%-%ds %%5s %%6s %%-%ds %%14s %%6s \", MAX_FUNCTION_NAME_LENGTH, MAX_PARAMS_LENGTH);\r\n"
"\r\n"
"    /* Check, if we have at least one Intra-Frame Heap memory block in the list */\r\n"
"    flag_intra_frame_memory = 0;\r\n"
"    for (i = 0; i < Num_Records; i++)\r\n"
"    {\r\n"
"        record_ptr = &(allocation_list[i]);\r\n"
"        if (record_ptr->wc_heap_size_intra_frame[1] > 0)\r\n"
"        {\r\n"
"            flag_intra_frame_memory = 1;\r\n"
"            break;\r\n"
"        }\r\n"
"    }\r\n"
"\r\n"
"    for (j = 0; j < 3; j++)\r\n"
"    {\r\n"
"        if (j == 0 && wc_heap_size[1] > 0)\r\n"
"        {\r\n"
"            /* Total Heap Size */\r\n"
"            printf(\"\\nList of memory blocks when maximum Heap Size is reached:\\n\\n\");\r\n"
"        }\r\n"
"        else if (j == 1 && flag_intra_frame_memory && wc_heap_size_intra_frame[1] > 0)\r\n"
"        {\r\n"
"            /* Intra-Frame Heap Size */\r\n"
"            printf(\"\\nList of memory blocks when maximum Intra-Frame Heap Size is reached:\\n\\n\");\r\n"
"        }\r\n"
"        else if (j == 2 && flag_intra_frame_memory && wc_heap_size_inter_frame[1] > 0)\r\n"
"        {\r\n"
"            /* Inter-Frame Heap Size */\r\n"
"            printf(\"\\nList of memory blocks when maximum Inter-Frame Heap Size is reached:\\n\\n\");\r\n"
"        }\r\n"
"        else\r\n"
"        {\r\n"
"            continue;\r\n"
"        }\r\n"
"\r\n"
"        /* Print Header */\r\n"
"        sprintf(buf, format_str, \"Function Name\", \"Line\", \"Type\", \"Function Parameters\", \"Maximum Size\", \"Usage\");\r\n"
"        puts(buf);\r\n"
"        length = strlen(buf);\r\n"
"        sprintf(buf, \"%0*d\\n\", (int)length - 1, 0);\r\n"
"        subst(buf, '0', '-');\r\n"
"        puts(buf);\r\n"
"\r\n"
"        /* Print all Records */\r\n"
"        for (i = 0; i < Num_Records; i++)\r\n"
"        {\r\n"
"            record_ptr = &(allocation_list[i]);\r\n"
"\r\n"
"            if ( (j == 0 && record_ptr->wc_heap_size[1] > 0) ||\r\n"
"                 (j == 1 && record_ptr->wc_heap_size_intra_frame[1] > 0) ||\r\n"
"                 (j == 2 && record_ptr->wc_heap_size_inter_frame[1] > 0)\r\n"
"               )\r\n"
"            {\r\n"
"                strncpy(name_str, record_ptr->name, MAX_FUNCTION_NAME_LENGTH);\r\n"
"                name_str[MAX_FUNCTION_NAME_LENGTH] = '\\0';\r\n"
"                strncpy(parms_str, &(record_ptr->params[2]), MAX_PARAMS_LENGTH);\r\n"
"                parms_str[MAX_PARAMS_LENGTH] = '\\0';\r\n"
"\r\n"
"                if (record_ptr->params[0] == 'm')\r\n"
"                {\r\n"
"                    strcpy(type_str, \"malloc\");\r\n"
"                }\r\n"
"                else\r\n"
"                {\r\n"
"                    strcpy(type_str, \"calloc\");\r\n"
"                }\r\n"
"\r\n"
"                sprintf(usage_str, \"%d%%\", (int)(record_ptr->ave_usage * 100.0f));\r\n"
"                sprintf(line_str, \"%d\", record_ptr->lineno);\r\n"
"                sprintf(size_str, \"%d %s\", (int)(record_ptr->max_block_size >> Stat_Cnt_Size), Count_Unit[Stat_Cnt_Size]);\r\n"
"\r\n"
"                sprintf(buf, format_str, name_str, line_str, type_str, parms_str, size_str, usage_str);\r\n"
"                puts(buf);\r\n"
"            }\r\n"
"        }\r\n"
"\r\n"
"        printf(\"\\n\\n\");\r\n"
"    }\r\n"
"\r\n"
"    return;\r\n"
"}\r\n"
"#endif\r\n"
"\r\n"
"/*-------------------------------------------------------------------*\r\n"
" * print_mem()\r\n"
" *\r\n"
" * Print information about ROM and RAM memory usage\r\n"
" *--------------------------------------------------------------------*/\r\n"
"\r\n"
"void print_mem(ROM_Size_Lookup_Table Const_Data_PROM_Table[])\r\n"
"{\r\n"
"    int i, nElem;\r\n"
"\r\n"
"    if (Const_Data_PROM_Table != NULL)\r\n"
"    {\r\n"
"        fprintf(stdout, \"\\n\\n --- Program ROM usage ---  \\n\\n\");\r\n"
"\r\n"
"        nElem = 0;\r\n"
"        while (strcmp(Const_Data_PROM_Table[nElem].file_spec, \"\") != 0) nElem++;\r\n"
"\r\n"
"        for (i = 0; i < nElem; i++)\r\n"
"        {\r\n"
"            fprintf(stdout, \"Program ROM size (%s): %d words (instructions)\\n\", Const_Data_PROM_Table[i].file_spec, Const_Data_PROM_Table[i].PROM_size);\r\n"
"        }\r\n"
"\r\n"
"        fprintf(stdout, \"\\n\\n --- Table ROM (const data) usage ---  \\n\\n\");\r\n"
"\r\n"
"        for (i = 0; i < nElem; i++)\r\n"
"        {\r\n"
"            if (Const_Data_PROM_Table[i].Get_Const_Data_Size_Func == NULL)\r\n"
"            {\r\n"
"                fprintf(stdout, \"Error: Cannot retrieve or calculate Table ROM size of (%s)!\\n\", Const_Data_PROM_Table[i].file_spec);\r\n"
"            }\r\n"
"\r\n"
"            fprintf(stdout, \"Table ROM size (%s): %d words\\n\", Const_Data_PROM_Table[i].file_spec, Const_Data_PROM_Table[i].Get_Const_Data_Size_Func());\r\n"
"        }\r\n"
"    }\r\n"
"\r\n"
"    if (wc_ram_size > 0)\r\n"
"    {\r\n"
"        fprintf(stdout, \"\\n\\n --- RAM usage (Stack + Heap) ---  \\n\\n\");\r\n"
"        fprintf(stdout, \"Maximum RAM size: %d %s in frame #%d\\n\", wc_ram_size >> Stat_Cnt_Size, Count_Unit[Stat_Cnt_Size], wc_ram_frame);\r\n"
"    }\r\n"
"\r\n"
"    if (ptr_base_stack - ptr_max_stack > 0)\r\n"
"    {\r\n"
"        fprintf(stdout, \"\\n\\n --- Stack usage ---  \\n\\n\");\r\n"
"        fprintf(stdout, \"Maximum stack size: %ld %s in frame #%d\\n\", ((ptr_base_stack - ptr_max_stack) * sizeof(int16_t)) >> Stat_Cnt_Size, Count_Unit[Stat_Cnt_Size],\r\n"
"            wc_frame);\r\n"
"#ifdef MEM_COUNT_DETAILS\r\n"
"        print_stack_call_tree();\r\n"
"#endif\r\n"
"    }\r\n"
"\r\n"
"    fprintf(stdout, \"\\n\\n --- Heap usage (malloc/calloc) ---  \\n\\n\");\r\n"
"\r\n"
"    /* check, if all memory blocks have been deallocated (freed) */\r\n"
"    for (i = 0; i < Num_Records; i++)\r\n"
"    {\r\n"
"        if (allocation_list[i].block_ptr != NULL)\r\n"
"        {\r\n"
"            printf(\"Fct=%s, Ln=%i: %s!\\n\", allocation_list[i].name, allocation_list[i].lineno, \"Error: Memory Block has not been De-Allocated with free()!\");\r\n"
"            exit(-1);\r\n"
"        }\r\n"
"    }\r\n"
"\r\n"
"    printf(\"Maximum heap size: %d %s in frame %d\\n\", wc_heap_size[1] >> Stat_Cnt_Size, Count_Unit[Stat_Cnt_Size], wc_heap_size[0]);\r\n"
"\r\n"
"    if (wc_heap_size_intra_frame[1] > 0)\r\n"
"    {\r\n"
"        printf(\"Maximum intra-frame heap size: %d %s in frame %d\\n\", wc_heap_size_intra_frame[1] >> Stat_Cnt_Size, Count_Unit[Stat_Cnt_Size], wc_heap_size_intra_frame[0]);\r\n"
"    }\r\n"
"\r\n"
"    if (wc_heap_size_inter_frame[1] > 0 && wc_heap_size_inter_frame[1] != wc_heap_size[1])\r\n"
"    {\r\n"
"        printf(\"Maximum inter-frame heap size: %d %s in frame %d\\n\", wc_heap_size_inter_frame[1] >> Stat_Cnt_Size, Count_Unit[Stat_Cnt_Size], wc_heap_size_inter_frame[1]);\r\n"
"    }\r\n"
"\r\n"
"#ifdef MEM_COUNT_DETAILS\r\n"
"    /* Print detailed information abour heap memory usage */\r\n"
"    mem_count_summary();\r\n"
"#endif\r\n"
"\r\n"
"    if (Stat_Cnt_Size > 0)\r\n"
"    {\r\n"
"        fprintf(stdout, \"\\nNote: 1 word = %d bits\\n\", 8 << Stat_Cnt_Size);\r\n"
"        fprintf(stdout, \"This is an optimistic estimate of memory consumption assuming that each variable type is stored with sizeof(type) bits\\n\\n\");\r\n"
"    }\r\n"
"\r\n"
"    /* De-allocate list of heap memory blocks */\r\n"
"    if (allocation_list != NULL)\r\n"
"    {\r\n"
"        free(allocation_list);\r\n"
"    }\r\n"
"\r\n"
"    return;\r\n"
"}\r\n"
"\r\n"
"#endif /* WMOPS */\r\n"
"\r\n"
"#ifndef WMOPS\r\n"
"int cntr_push_pop = 0;      /* global counter for checking balanced push_wmops()/pop_wmops() pairs when WMOPS is not activated */\r\n"
"#endif\r\n"
"\r\n"
"#undef WMC_TOOL_SKIP\r\n"
"\r\n"
"\r\n"
"\r\n"
"\r\n"
"\r\n"
"\r\n"