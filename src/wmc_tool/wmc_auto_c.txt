"/*\r\n",
" * (C) 2022 copyright VoiceAge Corporation. All Rights Reserved.\r\n",
" *\r\n",
" * This software is protected by copyright law and by international treaties. The source code, and all of its derivations,\r\n",
" * is provided by VoiceAge Corporation under the \"ITU-T Software Tools' General Public License\". Please, read the license file\r\n",
" * or refer to ITU-T Recommendation G.191 on \"SOFTWARE TOOLS FOR SPEECH AND AUDIO CODING STANDARDS\".\r\n",
" *\r\n",
" * Any use of this software is permitted provided that this notice is not removed and that neither the authors nor\r\n",
" * VoiceAge Corporation are deemed to have made any representations as to the suitability of this software\r\n",
" * for any purpose nor are held responsible for any defects of this software. THERE IS NO WARRANTY FOR THIS SOFTWARE.\r\n",
" *\r\n",
" * Authors: Guy Richard, Vladimir Malenovsky (Vladimir.Malenovsky@USherbrooke.ca)\r\n",
" */\r\n",
"\r\n",
"#include <stdio.h>\r\n",
"#include <stdlib.h>\r\n",
"#include <string.h>\r\n",
"#include <stdint.h>\r\n",
"#include <sys/stat.h>\r\n",
"\r\n",
"#ifndef _MSC_VER\r\n",
"#include <dirent.h>\r\n",
"#include <errno.h>\r\n",
"#else\r\n",
"#include <windows.h>\r\n",
"#endif\r\n",
"\r\n",
"#include \"options.h\"\r\n",
"#include \"wmc_auto.h\"\r\n",
"\r\n",
"#define WMC_TOOL_SKIP /* Skip the instrumentation of this file, if invoked by accident */\r\n",
"\r\n",
"#ifdef WMOPS\r\n",
"\r\n",
"/*-------------------------------------------------------------------*\r\n",
" * Complexity counting tool\r\n",
" *--------------------------------------------------------------------*/\r\n",
"\r\n",
"#define MAX_FUNCTION_NAME_LENGTH     50  /* Maximum length of the function name */\r\n",
"#define MAX_PARAMS_LENGTH            50  /* Maximum length of the function parameter string */\r\n",
"#define MAX_NUM_RECORDS              300 /* Initial maximum number of records -> mightb be increased during runtime, if needed */\r\n",
"#define MAX_NUM_RECORDS_REALLOC_STEP 50  /* When re-allocating the list of records, increase the number of records by this number */\r\n",
"#define MAX_CALL_TREE_DEPTH          100 /* maximum depth of the function call tree */\r\n",
"#define DOUBLE_MAX                   0x80000000\r\n",
"#define FAC                          ( FRAMES_PER_SECOND / 1e6 )\r\n",
"\r\n",
"\r\n",
"typedef struct \r\n",
"{\r\n",
"    char label[MAX_FUNCTION_NAME_LENGTH];\r\n",
"    long call_number;\r\n",
"    long update_cnt;\r\n",
"    int call_tree[MAX_CALL_TREE_DEPTH];\r\n",
"    long LastWOper;\r\n",
"    double start_selfcnt;\r\n",
"    double current_selfcnt;\r\n",
"    double max_selfcnt;\r\n",
"    double min_selfcnt;\r\n",
"    double tot_selfcnt;\r\n",
"    double start_cnt; \r\n",
"    double current_cnt;\r\n",
"    double max_cnt;\r\n",
"    double min_cnt;\r\n",
"    double tot_cnt;\r\n",
"#ifdef WMOPS_WC_FRAME_ANALYSIS\r\n",
"    int32_t current_call_number;\r\n",
"    double wc_cnt;\r\n",
"    double wc_selfcnt;\r\n",
"    int32_t wc_call_number;\r\n",
"#endif\r\n",
"} wmops_record;\r\n",
"\r\n",
"double ops_cnt;\r\n",
"double prom_cnt;\r\n",
"double inst_cnt[NUM_INST];\r\n",
"\r\n",
"static wmops_record *wmops = NULL;\r\n",
"static int num_wmops_records, max_num_wmops_records;\r\n",
"static int current_record;\r\n",
"static long update_cnt;\r\n",
"static double start_cnt;\r\n",
"static double max_cnt;\r\n",
"static double min_cnt;\r\n",
"static double inst_cnt_wc[NUM_INST];\r\n",
"static long fnum_cnt_wc;\r\n",
"static int *wmops_caller_stack = NULL, wmops_caller_stack_index, max_wmops_caller_stack_index = 0;\r\n",
"static int *heap_allocation_call_tree = NULL, heap_allocation_call_tree_size = 0, heap_allocation_call_tree_max_size = 0;\r\n",
"\r\n",
"void reset_wmops( void )\r\n",
"{\r\n",
"    int i, j;\r\n",
"    unsigned int *ptr;\r\n",
"\r\n",
"    num_wmops_records = 0;\r\n",
"    max_num_wmops_records = MAX_NUM_RECORDS;\r\n",
"    current_record = -1;\r\n",
"    update_cnt = 0;\r\n",
"\r\n",
"    max_cnt = 0.0;\r\n",
"    min_cnt = DOUBLE_MAX;\r\n",
"    start_cnt = 0.0;\r\n",
"    ops_cnt = 0.0;\r\n",
"\r\n",
"    /* allocate the list of wmops records */\r\n",
"    if ( wmops == NULL )\r\n",
"    {\r\n",
"        wmops = (wmops_record *)malloc( max_num_wmops_records * sizeof( wmops_record ) );\r\n",
"    }\r\n",
"\r\n",
"    if ( wmops == NULL )\r\n",
"    {\r\n",
"        fprintf( stderr, \"Error: Unable to Allocate List of WMOPS Records!\" );\r\n",
"        exit( -1 );\r\n",
"    }\r\n",
"\r\n",
"    /* allocate the BASOP WMOPS counter */\r\n",
"    if ( multiCounter == NULL )\r\n",
"    {\r\n",
"        multiCounter = (BASIC_OP *) malloc( max_num_wmops_records * sizeof( BASIC_OP ) );\r\n",
"    }\r\n",
"\r\n",
"    if ( multiCounter == NULL )\r\n",
"    {\r\n",
"        fprintf( stderr, \"Error: Unable to Allocate the BASOP WMOPS counter!\" );\r\n",
"        exit( -1 );\r\n",
"    }\r\n",
"\r\n",
"    /* initilize the list of wmops records */\r\n",
"    /* initilize the BASOP WMOPS counters */\r\n",
"    for ( i = 0; i < max_num_wmops_records; i++ )\r\n",
"    {\r\n",
"        strcpy( &wmops[i].label[0], \"\\0\" );\r\n",
"        wmops[i].call_number = 0;\r\n",
"        wmops[i].update_cnt = 0;\r\n",
"        for ( j = 0; j < MAX_CALL_TREE_DEPTH; j++ )\r\n",
"        {\r\n",
"            wmops[i].call_tree[j] = -1;\r\n",
"        }\r\n",
"        wmops[i].start_selfcnt = 0.0;\r\n",
"        wmops[i].current_selfcnt = 0.0;\r\n",
"        wmops[i].max_selfcnt = 0.0;\r\n",
"        wmops[i].min_selfcnt = DOUBLE_MAX;\r\n",
"        wmops[i].tot_selfcnt = 0.0;\r\n",
"        wmops[i].start_cnt = 0.0;\r\n",
"        wmops[i].current_cnt = 0.0;\r\n",
"        wmops[i].max_cnt = 0.0;\r\n",
"        wmops[i].min_cnt = DOUBLE_MAX;\r\n",
"        wmops[i].tot_cnt = 0.0;\r\n",
"#ifdef WMOPS_WC_FRAME_ANALYSIS\r\n",
"        wmops[i].wc_cnt = 0.0;\r\n",
"        wmops[i].wc_selfcnt = 0.0;\r\n",
"        wmops[i].current_call_number = 0;\r\n",
"        wmops[i].wc_call_number = -1;\r\n",
"#endif\r\n",
"\r\n",
"        /* clear all BASOP operation counters */\r\n",
"        ptr = (unsigned int*) &multiCounter[i];\r\n",
"        for ( j = 0; j < (int) ( sizeof(BASIC_OP ) / sizeof( unsigned int ) ); j++ )\r\n",
"        {\r\n",
"            *ptr++ = 0;\r\n",
"        }\r\n",
"        wmops[i].LastWOper = 0;\r\n",
"    }\r\n",
"\r\n",
"    /* allocate the list of wmops callers to track the sequence of function calls */\r\n",
"    wmops_caller_stack_index = 0;\r\n",
"    max_wmops_caller_stack_index = MAX_NUM_RECORDS;\r\n",
"    if ( wmops_caller_stack == NULL )\r\n",
"    {\r\n",
"        wmops_caller_stack = malloc( max_wmops_caller_stack_index * sizeof( int ) );\r\n",
"    }\r\n",
"\r\n",
"    if ( wmops_caller_stack == NULL )\r\n",
"    {\r\n",
"        fprintf( stderr, \"Error: Unable to Allocate List of WMOPS Callers!\" );\r\n",
"        exit( -1 );\r\n",
"    }\r\n",
"\r\n",
"    for ( i = 0; i < max_wmops_caller_stack_index; i++ )\r\n",
"    {\r\n",
"        wmops_caller_stack[i] = -1;\r\n",
"    }\r\n",
"\r\n",
"    /* initialize auxiliary BASOP WMOPS variables */\r\n",
"    call_occurred = 1;\r\n",
"    funcId_where_last_call_to_else_occurred = INT_MAX;\r\n",
"\r\n",
"    return;\r\n",
"}\r\n",
"\r\n",
"\r\n",
"void push_wmops( const char *label )\r\n",
"{\r\n",
"    int new_flag;\r\n",
"    int i, j;\r\n",
"\r\n",
"    /* Check, if this is a new function label */\r\n",
"    new_flag = 1;\r\n",
"    for ( i = 0; i < num_wmops_records; i++ )\r\n",
"    {\r\n",
"        if ( strcmp( wmops[i].label, label ) == 0 )\r\n",
"        {\r\n",
"            new_flag = 0;\r\n",
"            break;\r\n",
"        }\r\n",
"    }\r\n",
"\r\n",
"    /* Create a new record in the list */\r\n",
"    if ( new_flag )\r\n",
"    {\r\n",
"        if ( num_wmops_records >= max_num_wmops_records )\r\n",
"        {\r\n",
"            /* There is no room for a new wmops record -> reallocate the list */\r\n",
"            max_num_wmops_records += MAX_NUM_RECORDS_REALLOC_STEP;\r\n",
"            wmops = realloc( wmops, max_num_wmops_records * sizeof( wmops_record ) );\r\n",
"            multiCounter = realloc( multiCounter, max_num_wmops_records * sizeof( BASIC_OP ) );\r\n",
"        }\r\n",
"\r\n",
"        strcpy( wmops[i].label, label );\r\n",
"\r\n",
"        num_wmops_records++;\r\n",
"    }\r\n",
"\r\n",
"    /* Push the current context info to the new record */\r\n",
"    if ( current_record >= 0 )\r\n",
"    {\r\n",
"        if ( wmops_caller_stack_index >= max_wmops_caller_stack_index )\r\n",
"        {\r\n",
"            /* There is no room for a new record -> reallocate the list */\r\n",
"            max_wmops_caller_stack_index += MAX_NUM_RECORDS_REALLOC_STEP;\r\n",
"            wmops_caller_stack = realloc( wmops_caller_stack, max_wmops_caller_stack_index * sizeof( int ) );\r\n",
"        }\r\n",
"        wmops_caller_stack[wmops_caller_stack_index++] = current_record;\r\n",
"\r\n",
"        /* accumulate op counts */\r\n",
"        wmops[current_record].current_selfcnt += ops_cnt - wmops[current_record].start_selfcnt;\r\n",
"\r\n",
"        /* update call tree */\r\n",
"        for ( j = 0; j < MAX_CALL_TREE_DEPTH; j++ )\r\n",
"        {\r\n",
"            if ( wmops[i].call_tree[j] == current_record )\r\n",
"            {\r\n",
"                break;\r\n",
"            }\r\n",
"            else if ( wmops[i].call_tree[j] == -1 )\r\n",
"            {\r\n",
"                wmops[i].call_tree[j] = current_record;\r\n",
"                break;\r\n",
"            }\r\n",
"        }\r\n",
"    }\r\n",
"\r\n",
"    /* update the current context info */\r\n",
"    current_record = i;\r\n",
"    wmops[current_record].start_selfcnt = ops_cnt;\r\n",
"    wmops[current_record].start_cnt = ops_cnt;\r\n",
"    wmops[current_record].call_number++;\r\n",
"#ifdef WMOPS_WC_FRAME_ANALYSIS\r\n",
"    wmops[current_record].current_call_number++;\r\n",
"#endif\r\n",
"\r\n",
"    /* set the ID of BASOP functions counters */\r\n",
"    Set_BASOP_WMOPS_counter( current_record );\r\n",
"\r\n",
"    return;\r\n",
"}\r\n",
"\r\n",
"\r\n",
"void pop_wmops( void )\r\n",
"{\r\n",
"    long tot;\r\n",
"\r\n",
"    /* Check for underflow */\r\n",
"    if ( current_record < 0 )\r\n",
"    {\r\n",
"        fprintf( stdout, \"\\r pop_wmops(): stack underflow, too many calls to pop_wmops()\\n\" );\r\n",
"        exit( -1 );\r\n",
"    }\r\n",
"\r\n",
"    /* add the BASOP complexity to the counter */\r\n",
"    tot = DeltaWeightedOperation();\r\n",
"    ops_cnt += tot;\r\n",
"\r\n",
"     /* update count of current record */\r\n",
"    wmops[current_record].current_selfcnt += ops_cnt - wmops[current_record].start_selfcnt;\r\n",
"    wmops[current_record].current_cnt += ops_cnt - wmops[current_record].start_cnt;\r\n",
"\r\n",
"    /* Get back previous context from stack */\r\n",
"    if ( wmops_caller_stack_index > 0 )\r\n",
"    {\r\n",
"        current_record = wmops_caller_stack[--wmops_caller_stack_index];\r\n",
"        wmops[current_record].start_selfcnt = ops_cnt;\r\n",
"\r\n",
"        /* set the ID of the previous BASOP counter */\r\n",
"        Set_BASOP_WMOPS_counter( current_record );\r\n",
"    }\r\n",
"    else\r\n",
"    {\r\n",
"        current_record = -1;\r\n",
"    }\r\n",
"\r\n",
"\r\n",
"    return;\r\n",
"}\r\n",
"\r\n",
"\r\n",
"void update_wmops( void )\r\n",
"{\r\n",
"    int i;\r\n",
"    double current_cnt;\r\n",
"#ifdef WMOPS_PER_FRAME\r\n",
"    static FILE *fid = NULL;\r\n",
"    const char filename[] = \"wmops_analysis\";\r\n",
"    float tmpF;\r\n",
"#endif\r\n",
"\r\n",
"    if ( wmops_caller_stack_index != 0 )\r\n",
"    {\r\n",
"        fprintf( stdout, \"update_wmops(): WMOPS caller stack corrupted - check that all push_wmops() are matched with pop_wmops()!\\n\" );\r\n",
"        exit( -1 );\r\n",
"    }\r\n",
"\r\n",
"#ifdef WMOPS_PER_FRAME\r\n",
"    /* Check, if the output file has already been opened */\r\n",
"    if ( fid == NULL )\r\n",
"    {\r\n",
"        fid = fopen( filename, \"wb\" );\r\n",
"\r\n",
"        if ( fid == NULL )\r\n",
"        {\r\n",
"            fprintf( stderr, \"\\nCannot open %s!\\n\\n\", filename );\r\n",
"            exit( -1 );\r\n",
"        }\r\n",
"    }\r\n",
"\r\n",
"    /* Write current complexity to the external file */\r\n",
"    tmpF = (float) ( FAC * wmops[0].current_cnt );\r\n",
"    fwrite( &tmpF, sizeof( float ), 1, fid );\r\n",
"#endif\r\n",
"\r\n",
"#ifdef WMOPS_WC_FRAME_ANALYSIS\r\n",
"    if ( ops_cnt - start_cnt > max_cnt )\r\n",
"    {\r\n",
"        for ( i = 0; i < num_wmops_records; i++ )\r\n",
"        {\r\n",
"            wmops[i].wc_cnt = wmops[i].current_cnt;\r\n",
"            wmops[i].wc_selfcnt = wmops[i].current_selfcnt;\r\n",
"            wmops[i].wc_call_number = wmops[i].current_call_number;\r\n",
"        }\r\n",
"    }\r\n",
"#endif\r\n",
"\r\n",
"    for ( i = 0; i < num_wmops_records; i++ )\r\n",
"    {\r\n",
"        wmops[i].tot_selfcnt += wmops[i].current_selfcnt;\r\n",
"        wmops[i].tot_cnt += wmops[i].current_cnt;\r\n",
"\r\n",
"        if ( wmops[i].current_selfcnt > 0 )\r\n",
"        {\r\n",
"            if ( wmops[i].current_selfcnt > wmops[i].max_selfcnt )\r\n",
"            {\r\n",
"                wmops[i].max_selfcnt = wmops[i].current_selfcnt;\r\n",
"            }\r\n",
"\r\n",
"            if ( wmops[i].current_selfcnt < wmops[i].min_selfcnt )\r\n",
"            {\r\n",
"                wmops[i].min_selfcnt = wmops[i].current_selfcnt;\r\n",
"            }\r\n",
"        }\r\n",
"\r\n",
"        wmops[i].current_selfcnt = 0;\r\n",
"\r\n",
"        if ( wmops[i].current_cnt > 0 )\r\n",
"        {\r\n",
"            if ( wmops[i].current_cnt > wmops[i].max_cnt )\r\n",
"            {\r\n",
"                wmops[i].max_cnt = wmops[i].current_cnt;\r\n",
"            }\r\n",
"\r\n",
"\r\n",
"            if ( wmops[i].current_cnt < wmops[i].min_cnt )\r\n",
"            {\r\n",
"                wmops[i].min_cnt = wmops[i].current_cnt;\r\n",
"            }\r\n",
"\r\n",
"            wmops[i].update_cnt++;\r\n",
"        }\r\n",
"\r\n",
"        wmops[i].current_cnt = 0;\r\n",
"#ifdef WMOPS_WC_FRAME_ANALYSIS\r\n",
"        wmops[i].current_call_number = 0;\r\n",
"#endif\r\n",
"\r\n",
"        /* update the WC of all BASOP counters */\r\n",
"        Set_BASOP_WMOPS_counter( i );\r\n",
"        Reset_BASOP_WMOPS_counter();\r\n",
"    }\r\n",
"\r\n",
"    current_cnt = ops_cnt - start_cnt;\r\n",
"    if ( current_cnt > max_cnt )\r\n",
"    {\r\n",
"        max_cnt = current_cnt;\r\n",
"\r\n",
"        for ( i = 0; i < NUM_INST; i++ )\r\n",
"        {\r\n",
"            inst_cnt_wc[i] = inst_cnt[i];\r\n",
"        }\r\n",
"\r\n",
"        fnum_cnt_wc = update_cnt + 1;\r\n",
"    }\r\n",
"\r\n",
"    if ( current_cnt < min_cnt )\r\n",
"    {\r\n",
"        min_cnt = current_cnt;\r\n",
"    }\r\n",
"\r\n",
"    for ( i = 0; i < NUM_INST; i++ )\r\n",
"    {\r\n",
"        inst_cnt[i] = 0.0;\r\n",
"    }\r\n",
"\r\n",
"    start_cnt = ops_cnt;\r\n",
"\r\n",
"    /* increment frame counter */\r\n",
"    update_cnt++;\r\n",
"\r\n",
"    return;\r\n",
"}\r\n",
"\r\n",
"\r\n",
"void print_wmops( void )\r\n",
"{\r\n",
"    int i, label_len, max_label_len;\r\n",
"\r\n",
"    char *sfmts = \"%*s %8s %8s %7s %7s\\n\";\r\n",
"    char *dfmts = \"%*s %8.2f %8.3f %7.3f %7.3f\\n\";\r\n",
"    char *sfmt  = \"%*s %8s %8s %7s %7s  %7s %7s %7s\\n\";\r\n",
"    char *dfmt  = \"%*s %8.2f %8.3f %7.3f %7.3f  %7.3f %7.3f %7.3f\\n\";\r\n",
"\r\n",
"#ifdef WMOPS_WC_FRAME_ANALYSIS\r\n",
"    int j;\r\n",
"    char *sfmtt = \"%20s %4s %15s\\n\";\r\n",
"    char *dfmtt = \"%20s %4d  \";\r\n",
"#endif\r\n",
"\r\n",
"    /* calculate maximum label length for compact prinout */\r\n",
"    max_label_len = 0;\r\n",
"    for ( i = 0; i < num_wmops_records; i++ )\r\n",
"    {\r\n",
"        label_len = strlen( wmops[i].label );\r\n",
"        if ( label_len > max_label_len )\r\n",
"        {\r\n",
"            max_label_len = label_len;\r\n",
"        }\r\n",
"    }\r\n",
"    max_label_len += 4;\r\n",
"\r\n",
"    fprintf( stdout, \"\\n\\n --- Complexity analysis [WMOPS] ---  \\n\\n\" );\r\n",
"    \r\n",
"    fprintf( stdout, \"%*s %33s  %23s\\n\", max_label_len, \"\", \"|------  SELF  ------|\", \"|---  CUMULATIVE  ---|\" );\r\n",
"    fprintf( stdout, sfmt, max_label_len, \"        routine\", \" calls\", \"  min \", \"  max \", \"  avg \", \"  min \", \"  max \", \"  avg \" );\r\n",
"    fprintf( stdout, sfmt, max_label_len, \"---------------\", \"------\", \"------\", \"------\", \"------\", \"------\", \"------\", \"------\" );\r\n",
"\r\n",
"    for ( i = 0; i < num_wmops_records; i++ )\r\n",
"    {\r\n",
"        fprintf( stdout, dfmt, max_label_len, wmops[i].label, update_cnt == 0 ? 0 : (float) wmops[i].call_number / update_cnt,\r\n",
"                 wmops[i].min_selfcnt == DOUBLE_MAX ? 0 : FAC * wmops[i].min_selfcnt,\r\n",
"                 FAC * wmops[i].max_selfcnt,\r\n",
"                 wmops[i].update_cnt == 0 ? 0 : FAC * wmops[i].tot_selfcnt / wmops[i].update_cnt,\r\n",
"                 wmops[i].min_cnt == DOUBLE_MAX ? 0 : FAC * wmops[i].min_cnt,\r\n",
"                 FAC * wmops[i].max_cnt,\r\n",
"                 wmops[i].update_cnt == 0 ? 0 : FAC * wmops[i].tot_cnt / wmops[i].update_cnt );\r\n",
"    }\r\n",
"\r\n",
"    fprintf( stdout, sfmts, max_label_len, \"---------------\", \"------\", \"------\", \"------\", \"------\" );\r\n",
"    fprintf( stdout, dfmts, max_label_len, \"total\", (float) update_cnt, update_cnt == 0 ? 0 : FAC * min_cnt, FAC * max_cnt, update_cnt == 0 ? 0 : FAC * ops_cnt / update_cnt );\r\n",
"    fprintf( stdout, \"\\n\" );\r\n",
"\r\n",
"#ifdef WMOPS_WC_FRAME_ANALYSIS\r\n",
"    fprintf( stdout, \"\\nComplexity analysis for the worst-case frame %ld:\\n\\n\", fnum_cnt_wc );\r\n",
"    fprintf( stdout, \"%*s %8s %10s %12s\\n\", max_label_len,   \"        routine\", \" calls\", \" SELF\", \"  CUMULATIVE\" );\r\n",
"    fprintf( stdout, \"%*s %8s %10s   %10s\\n\", max_label_len, \"---------------\", \"------\", \"------\", \"----------\" );\r\n",
"\r\n",
"    for ( i = 0; i < num_wmops_records; i++ )\r\n",
"    {\r\n",
"        if ( wmops[i].wc_call_number > 0 )\r\n",
"        {\r\n",
"            fprintf( stdout, \"%*s %8d %10.3f %12.3f\\n\", max_label_len, wmops[i].label, wmops[i].wc_call_number, FAC * wmops[i].wc_selfcnt, FAC * wmops[i].wc_cnt );\r\n",
"        }\r\n",
"    }\r\n",
"\r\n",
"    fprintf( stdout, \"\\nCall tree for the worst-case frame %ld:\\n\\n\", fnum_cnt_wc );\r\n",
"    fprintf( stdout, sfmtt, \"       function\", \"num\", \"called by     \" );\r\n",
"    fprintf( stdout, sfmtt, \"---------------\", \"---\", \"--------------\" );\r\n",
"\r\n",
"    for ( i = 0; i < num_wmops_records; i++ )\r\n",
"    {\r\n",
"        if ( wmops[i].wc_call_number > 0 )\r\n",
"        {\r\n",
"            fprintf( stdout, dfmtt, wmops[i].label, i );\r\n",
"            for ( j = 0; wmops[i].call_tree[j] != -1 && j < MAX_CALL_TREE_DEPTH; j++ )\r\n",
"            {\r\n",
"                if ( j != 0 )\r\n",
"                {\r\n",
"                    fprintf( stdout, \", \" );\r\n",
"                }\r\n",
"                fprintf( stdout, \"%d\", wmops[i].call_tree[j] );\r\n",
"            }\r\n",
"            fprintf( stdout, \"\\n\" );\r\n",
"        }\r\n",
"    }\r\n",
"\r\n",
"    fprintf( stdout, \"\\n\\n\" );\r\n",
"\r\n",
"    fprintf( stdout, \"\\nInstruction type analysis for the worst-case frame %ld:\\n\\n\", fnum_cnt_wc ); \r\n",
"    for ( i = 0; i < NUM_INST; i++ )\r\n",
"    {\r\n",
"        switch ( (enum instructions) i )\r\n",
"        {\r\n",
"            case _ADD:\r\n",
"                fprintf( stdout, \"\\tAdds:          %12.1f\\n\", inst_cnt_wc[i] );\r\n",
"                break;\r\n",
"            case _ABS:\r\n",
"                fprintf( stdout, \"\\tAbsolutes:     %12.1f\\n\", inst_cnt_wc[i] );\r\n",
"                break;\r\n",
"            case _MULT:\r\n",
"                fprintf( stdout, \"\\tMultiplies:    %12.1f\\n\", inst_cnt_wc[i] );\r\n",
"                break;\r\n",
"            case _MAC:\r\n",
"                fprintf( stdout, \"\\tMACs:          %12.1f\\n\", inst_cnt_wc[i] );\r\n",
"                break;\r\n",
"            case _MOVE:\r\n",
"                fprintf( stdout, \"\\tMoves:         %12.1f\\n\", inst_cnt_wc[i] );\r\n",
"                break;\r\n",
"            case _STORE:\r\n",
"                fprintf( stdout, \"\\tStores:        %12.1f\\n\", inst_cnt_wc[i] );\r\n",
"                break;\r\n",
"            case _LOGIC:\r\n",
"                fprintf( stdout, \"\\tLogicals:      %12.1f\\n\", inst_cnt_wc[i] );\r\n",
"                break;\r\n",
"            case _SHIFT:\r\n",
"                fprintf( stdout, \"\\tShifts:        %12.1f\\n\", inst_cnt_wc[i] );\r\n",
"                break;\r\n",
"            case _BRANCH:\r\n",
"                fprintf( stdout, \"\\tBranches:      %12.1f\\n\", inst_cnt_wc[i] );\r\n",
"                break;\r\n",
"            case _DIV:\r\n",
"                fprintf( stdout, \"\\tDivisions:     %12.1f\\n\", inst_cnt_wc[i] );\r\n",
"                break;\r\n",
"            case _SQRT:\r\n",
"                fprintf( stdout, \"\\tSquare Root:   %12.1f\\n\", inst_cnt_wc[i] );\r\n",
"                break;\r\n",
"            case _TRANS:\r\n",
"                fprintf( stdout, \"\\tTrans:         %12.1f\\n\", inst_cnt_wc[i] );\r\n",
"                break;\r\n",
"            case _FUNC:\r\n",
"                fprintf( stdout, \"\\tFunc Call:     %12.1f\\n\", inst_cnt_wc[i] );\r\n",
"                break;\r\n",
"            case _LOOP:\r\n",
"                fprintf( stdout, \"\\tLoop Init:     %12.1f\\n\", inst_cnt_wc[i] );\r\n",
"                break;\r\n",
"            case _INDIRECT:\r\n",
"                fprintf( stdout, \"\\tIndirect Addr: %12.1f\\n\", inst_cnt_wc[i] );\r\n",
"                break;\r\n",
"            case _PTR_INIT:\r\n",
"                fprintf( stdout, \"\\tPointer Init:  %12.1f\\n\", inst_cnt_wc[i] );\r\n",
"                break;\r\n",
"            case _TEST:\r\n",
"                fprintf( stdout, \"\\tExtra condit.: %12.1f\\n\", inst_cnt_wc[i] );\r\n",
"                break;\r\n",
"            case _POWER:\r\n",
"                fprintf( stdout, \"\\tExponential:   %12.1f\\n\", inst_cnt_wc[i] );\r\n",
"                break;\r\n",
"            case _LOG:\r\n",
"                fprintf( stdout, \"\\tLogarithm:     %12.1f\\n\", inst_cnt_wc[i] );\r\n",
"                break;\r\n",
"            case _MISC:\r\n",
"                fprintf( stdout, \"\\tAll other op.: %12.1f\\n\", inst_cnt_wc[i] );\r\n",
"                break;\r\n",
"            default:\r\n",
"                fprintf( stdout, \"\\tERROR: Invalid instruction type: %d\\n\\n\", i );\r\n",
"        }\r\n",
"    }\r\n",
"#endif\r\n",
"\r\n",
"    /* De-allocate the list of wmops record */\r\n",
"    if ( wmops != NULL )\r\n",
"    {\r\n",
"        free( wmops );\r\n",
"    }\r\n",
"\r\n",
"    /* De-allocate the list of wmops caller functions */\r\n",
"    if ( wmops_caller_stack != NULL )\r\n",
"    {\r\n",
"        free( wmops_caller_stack );\r\n",
"    }\r\n",
"\r\n",
"    /* De-allocate the BASOP WMOPS counter */\r\n",
"    if ( multiCounter != NULL )\r\n",
"    {\r\n",
"        free( multiCounter );\r\n",
"    }\r\n",
"\r\n",
"    return;\r\n",
"}\r\n",
"\r\n",
"\r\n",
"/*-------------------------------------------------------------------*\r\n",
" * Memory counting tool measuring RAM usage (stack and heap)\r\n",
" *\r\n",
" * Maximum RAM is measured by monitoring the total allocated memory (stack and heap) in each frame.\r\n",
" *\r\n",
" * Maximum stack is measured by monitoring the difference between the 'top' and 'bottom' of the stack. The 'bottom' of the stack is updated in each function\r\n",
" * with a macro 'func_start_' which is inserted automatically to all functions during the instrumentation process.\r\n",
" *\r\n",
" * Maximum heap is measured by summing the sizes of all memory blocks allocated by malloc() or calloc() and deallocated by free(). The maximum heap size is\r\n",
" * updated each time when the macros malloc_() or calloc_() is invoked. The macros 'malloc_ and calloc_' are inserted automatically during the instrumentation process.\r\n",
" * As part of heap measurements, intra-frame heap and inter-frame heap are measured separately. Intra-frame heap refers to heap memory which is allocated and deallocated\r\n",
" * within a single frame. Inter-frame heap, on the contrary, refers to heap memory which is reserved for more than one frame.\r\n",
" *\r\n",
" * In order to run the memory counting tool the function reset_mem(cnt_size) must be called at the beginning of the encoding/decoding process.\r\n",
" * The unit in which memory consumption is reported is set via the parameter 'cnt_size'. It can be set to 0 (bytes), 1 (32b words) or 2 (64b words).\r\n",
" * At the end of the encoding/decoding process, 'print_mem()' function may be called to print basic information about memory consumption. If the macro 'MEM_COUNT_DETAILS'\r\n",
" * is activated, detailed information is printed\r\n",
" *\r\n",
" * The macro 'WMOPS' needs to be activated to enable memory counting. To avoid the instrumentation of malloc()/calloc()/free() calls, use\r\n",
" * #define WMC_TOOL_SKIP ... #undef WMC_TOOL_SKIP macro pair around the malloc(), calloc() and free().\r\n",
" *--------------------------------------------------------------------*/\r\n",
"\r\n",
"/* This is the value (in bytes) towards which the block size is rounded. For example, a block of 123 bytes, when using\r\n",
"   a 32 bits system, will end up taking 124 bytes since the last unused byte cannot be used for another block. */\r\n",
"#ifdef MEM_ALIGN_64BITS\r\n",
"#define BLOCK_ROUNDING 8 /* Align on 64 Bits */\r\n",
"#else\r\n",
"#define BLOCK_ROUNDING 4 /* Align on 32 Bits */\r\n",
"#endif\r\n",
"\r\n",
"#define N_32BITS_BLOCKS ( BLOCK_ROUNDING / sizeof( int32_t ) )\r\n",
"#define ROUND_BLOCK_SIZE( n ) ( ( ( n ) + BLOCK_ROUNDING - 1 ) & ~( BLOCK_ROUNDING - 1 ) )\r\n",
"\r\n",
"#define MAGIC_VALUE_OOB  0x12A534F0           /* Signature value which is inserted before and after each allocated memory block, used to detect out-of-bound access */\r\n",
"#define MAGIC_VALUE_USED ( ~MAGIC_VALUE_OOB ) /* Value used to pre-fill allocated memory blocks, used to calculate actual memory usage */\r\n",
"#define OOB_START        0x1                  /* Flag indicating out-of-bounds access before memory block */\r\n",
"#define OOB_END          0x2                  /* Flag indicating out-of-bounds access after memory block */\r\n",
"\r\n",
"#ifdef MEM_COUNT_DETAILS\r\n",
"const char *csv_filename = \"mem_analysis.csv\";\r\n",
"static FILE *fid_csv_filename = NULL;\r\n",
"#endif\r\n",
"\r\n",
"typedef struct\r\n",
"{\r\n",
"    char function_name[MAX_FUNCTION_NAME_LENGTH + 1];\r\n",
"    int16_t *stack_ptr;\r\n",
"} caller_info;\r\n",
"\r\n",
"static caller_info *stack_callers[2] = {NULL, NULL};\r\n",
"\r\n",
"static int16_t *ptr_base_stack = 0;    /* Pointer to the bottom of stack (base pointer). Stack grows up. */\r\n",
"static int16_t *ptr_current_stack = 0; /* Pointer to the current stack pointer */\r\n",
"static int16_t *ptr_max_stack = 0;     /* Pointer to the maximum stack pointer (the farest point from the bottom of stack) */\r\n",
"static int32_t wc_stack_frame = 0;     /* Frame corresponding to the worst-case stack usage */\r\n",
"static int current_calls = 0, max_num_calls = MAX_NUM_RECORDS;\r\n",
"static char location_max_stack[256] = \"undefined\";\r\n",
"\r\n",
"/* Heap-related variables */\r\n",
"typedef struct\r\n",
"{\r\n",
"    char name[MAX_FUNCTION_NAME_LENGTH + 1]; /* +1 for NUL */\r\n",
"    char params[1 + MAX_PARAMS_LENGTH + 1];  /* +1 for 'm'/'c' alloc & +1 for NUL */\r\n",
"    unsigned long hash;\r\n",
"    int lineno;\r\n",
"    void *block_ptr;\r\n",
"    int block_size;\r\n",
"    unsigned long total_block_size; /* Cumulative sum of the allocated size in the session */\r\n",
"    unsigned long total_used_size;  /* Cumulative sum of the used size in the session */\r\n",
"    int wc_heap_size_intra_frame;   /* Worst-Case Intra-Frame Heap Size */\r\n",
"    int wc_heap_size_inter_frame;   /* Worst-Case Inter-Frame Heap Size */\r\n",
"    int frame_allocated;            /* Frame number in which the Memory Block has been allocated (-1 if not allocated at the moment) */\r\n",
"    int OOB_Flag;\r\n",
"    int noccurances; /* Number of times that the memory block has been allocated in a frame */\r\n",
"} allocator_record;\r\n",
"\r\n",
"allocator_record *allocation_list = NULL;\r\n",
"\r\n",
"static int Num_Records, Max_Num_Records;\r\n",
"static size_t Stat_Cnt_Size = USE_BYTES;\r\n",
"static const char *Count_Unit[] = { \"bytes\", \"words\", \"words\", \"words\" };\r\n",
"\r\n",
"static int32_t wc_ram_size, wc_ram_frame;\r\n",
"static int32_t current_heap_size;\r\n",
"static int *list_wc_intra_frame_heap, n_items_wc_intra_frame_heap, max_items_wc_intra_frame_heap, size_wc_intra_frame_heap, location_wc_intra_frame_heap;\r\n",
"static int *list_current_inter_frame_heap, n_items_current_inter_frame_heap, max_items_current_inter_frame_heap, size_current_inter_frame_heap;\r\n",
"static int *list_wc_inter_frame_heap, n_items_wc_inter_frame_heap, max_items_wc_inter_frame_heap, size_wc_inter_frame_heap, location_wc_inter_frame_heap;\r\n",
"\r\n",
"/* Local Functions */\r\n",
"static unsigned long malloc_hash( const char *func_name, int func_lineno, char *size_str );\r\n",
"allocator_record *get_mem_record( unsigned long *hash, const char *func_name, int func_lineno, char *size_str, int *index_record );\r\n",
"static void *mem_alloc_block( size_t size, const char *size_str );\r\n",
"\r\n",
"/*-------------------------------------------------------------------*\r\n",
" * reset_mem()\r\n",
" *\r\n",
" * Initialize/reset memory counting tool (stack and heap)\r\n",
" *--------------------------------------------------------------------*/\r\n",
"\r\n",
"void reset_mem( Counting_Size cnt_size )\r\n",
"{\r\n",
"    int16_t something;\r\n",
"    size_t tmp_size;\r\n",
"\r\n",
"    /* initialize list of stack records */\r\n",
"    if ( stack_callers[0] == NULL )\r\n",
"    {\r\n",
"        stack_callers[0] = malloc( MAX_NUM_RECORDS * sizeof( caller_info ) );\r\n",
"        stack_callers[1] = malloc( MAX_NUM_RECORDS * sizeof( caller_info ) );\r\n",
"    }\r\n",
"\r\n",
"    if ( stack_callers[0] == NULL || stack_callers[1] == NULL )\r\n",
"    {\r\n",
"        fprintf( stderr, \"Error: Unable to Allocate List of Stack Records!\" );\r\n",
"        exit( -1 );\r\n",
"    }\r\n",
"\r\n",
"    current_calls = 0;\r\n",
"    max_num_calls = MAX_NUM_RECORDS;\r\n",
"\r\n",
"    /* initialize stack pointers */\r\n",
"    ptr_base_stack = &something;\r\n",
"    ptr_max_stack = ptr_base_stack;\r\n",
"    ptr_current_stack = ptr_base_stack;\r\n",
"\r\n",
"    /* initialize the unit of memory block size */\r\n",
"    Stat_Cnt_Size = cnt_size;\r\n",
"\r\n",
"    /* Check, if sizeof(int32_t) is 4 bytes */\r\n",
"    tmp_size = sizeof( int32_t );\r\n",
"    if ( tmp_size != 4 )\r\n",
"    {\r\n",
"        fprintf( stderr, \"Error: Expecting 'int32_t' to be a 32 Bits Integer!\" );\r\n",
"        exit( -1 );\r\n",
"    }\r\n",
"\r\n",
"    /* create allocation list for malloc() memory blocks */\r\n",
"    if ( allocation_list == NULL )\r\n",
"    {\r\n",
"        allocation_list = malloc( MAX_NUM_RECORDS * sizeof( allocator_record ) );\r\n",
"    }\r\n",
"\r\n",
"    if ( allocation_list == NULL )\r\n",
"    {\r\n",
"        fprintf( stderr, \"Error: Unable to Create List of Memory Blocks!\" );\r\n",
"        exit( -1 );\r\n",
"    }\r\n",
"\r\n",
"    Num_Records = 0;\r\n",
"    Max_Num_Records = MAX_NUM_RECORDS;\r\n",
"\r\n",
"    wc_ram_size = 0;\r\n",
"    wc_ram_frame = -1;\r\n",
"    current_heap_size = 0;\r\n",
"\r\n",
"    /* heap allocation tree */\r\n",
"    heap_allocation_call_tree_max_size = MAX_NUM_RECORDS;\r\n",
"    if ( heap_allocation_call_tree == NULL )\r\n",
"    {\r\n",
"        heap_allocation_call_tree = (int *) malloc( heap_allocation_call_tree_max_size * sizeof( int ) );\r\n",
"        memset( heap_allocation_call_tree, -1, heap_allocation_call_tree_max_size * sizeof( int ) );\r\n",
"    }\r\n",
"    heap_allocation_call_tree_size = 0;\r\n",
"\r\n",
"    /* wc intra-frame heap */\r\n",
"    max_items_wc_intra_frame_heap = MAX_NUM_RECORDS;\r\n",
"    if ( list_wc_intra_frame_heap == NULL )\r\n",
"    {\r\n",
"        list_wc_intra_frame_heap = (int *) malloc( max_items_wc_intra_frame_heap * sizeof( int ) );\r\n",
"        memset( list_wc_intra_frame_heap, -1, max_items_wc_intra_frame_heap * sizeof( int ) );\r\n",
"    }\r\n",
"    n_items_wc_intra_frame_heap = 0;\r\n",
"    size_wc_intra_frame_heap = 0;\r\n",
"    location_wc_intra_frame_heap = -1;\r\n",
"\r\n",
"    /* current inter-frame heap */\r\n",
"    max_items_current_inter_frame_heap = MAX_NUM_RECORDS;\r\n",
"    if ( list_current_inter_frame_heap == NULL )\r\n",
"    {\r\n",
"        list_current_inter_frame_heap = (int *) malloc( max_items_current_inter_frame_heap * sizeof( int ) );\r\n",
"        memset( list_current_inter_frame_heap, -1, max_items_current_inter_frame_heap * sizeof( int ) );\r\n",
"    }\r\n",
"    n_items_current_inter_frame_heap = 0;\r\n",
"    size_current_inter_frame_heap = 0;\r\n",
"\r\n",
"    /* wc inter-frame heap */\r\n",
"    max_items_wc_inter_frame_heap = MAX_NUM_RECORDS;\r\n",
"    if ( list_wc_inter_frame_heap == NULL )\r\n",
"    {\r\n",
"        list_wc_inter_frame_heap = (int *) malloc( max_items_wc_inter_frame_heap * sizeof( int ) );\r\n",
"        memset( list_wc_inter_frame_heap, -1, max_items_wc_inter_frame_heap * sizeof( int ) );\r\n",
"    }\r\n",
"    n_items_wc_inter_frame_heap = 0;\r\n",
"    size_wc_inter_frame_heap = 0;\r\n",
"    location_wc_inter_frame_heap = -1;\r\n",
"\r\n",
"#ifdef MEM_COUNT_DETAILS\r\n",
"    /* Check, if the .csv file has already been opened */\r\n",
"    if ( fid_csv_filename == NULL )\r\n",
"    {\r\n",
"        fid_csv_filename = fopen( csv_filename, \"wb\" );\r\n",
"\r\n",
"        if ( fid_csv_filename == NULL )\r\n",
"        {\r\n",
"            fprintf( stderr, \"\\nCannot open %s!\\n\\n\", csv_filename );\r\n",
"            exit( -1 );\r\n",
"        }\r\n",
"    }\r\n",
"    else\r\n",
"    {\r\n",
"        /* reset file */\r\n",
"        rewind( fid_csv_filename );\r\n",
"    }\r\n",
"#endif\r\n",
"\r\n",
"    return;\r\n",
"}\r\n",
"\r\n",
"/*-------------------------------------------------------------------*\r\n",
" * reset_stack()\r\n",
" *\r\n",
" * Reset stack pointer\r\n",
" *--------------------------------------------------------------------*/\r\n",
"\r\n",
"void reset_stack( void )\r\n",
"{\r\n",
"    int16_t something;\r\n",
"\r\n",
"    /* initialize/reset stack pointers */\r\n",
"    ptr_base_stack = &something;\r\n",
"    ptr_max_stack = ptr_base_stack;\r\n",
"    ptr_current_stack = ptr_base_stack;\r\n",
"\r\n",
"    return;\r\n",
"}\r\n",
"\r\n",
"/*-------------------------------------------------------------------*\r\n",
" * push_stack()\r\n",
" *\r\n",
" * Check the current stack pointer and update the maximum stack pointer, if new maximum found.\r\n",
" *--------------------------------------------------------------------*/\r\n",
"\r\n",
"int push_stack( const char *filename, const char *fctname )\r\n",
"{\r\n",
"    int16_t something;\r\n",
"    int32_t current_stack_size;\r\n",
"\r\n",
"    ptr_current_stack = &something;\r\n",
"\r\n",
"    (void) *filename; /* to avoid compilation warning */\r\n",
"\r\n",
"    if ( current_calls >= max_num_calls )\r\n",
"    {\r\n",
"        /* There is no room for a new record -> reallocate the list */\r\n",
"        max_num_calls += MAX_NUM_RECORDS_REALLOC_STEP;\r\n",
"        stack_callers[0] = realloc( stack_callers[0], max_num_calls * sizeof( caller_info ) );\r\n",
"        stack_callers[1] = realloc( stack_callers[1], max_num_calls * sizeof( caller_info ) );\r\n",
"    }\r\n",
"\r\n",
"    /* Valid Function Name? */\r\n",
"    if ( fctname[0] == 0 )\r\n",
"    { /* No */\r\n",
"        fprintf( stderr, \"Invalid function name for call stack info.\" );\r\n",
"        exit( -1 );\r\n",
"    }\r\n",
"\r\n",
"    /* Save the Name of the Calling Function in the Table */\r\n",
"    strncpy( stack_callers[0][current_calls].function_name, fctname, MAX_FUNCTION_NAME_LENGTH );\r\n",
"    stack_callers[0][current_calls].function_name[MAX_FUNCTION_NAME_LENGTH] = 0; /* Nul Terminate */\r\n",
"\r\n",
"    /* Save the Stack Pointer */\r\n",
"    stack_callers[0][current_calls].stack_ptr = ptr_current_stack;\r\n",
"\r\n",
"    /* Increase the Number of Calls in the List */\r\n",
"    current_calls++;\r\n",
"\r\n",
"    /* Is this the First Time or the Worst Case? */\r\n",
"    if ( ptr_current_stack < ptr_max_stack || ptr_max_stack == NULL )\r\n",
"    { /* Yes */\r\n",
"        /* Save Info about it */\r\n",
"        ptr_max_stack = ptr_current_stack;\r\n",
"\r\n",
"        /* save the worst-case frame number */\r\n",
"        /* current frame number is stored in the variable update_cnt and updated in the function update_wmops() */\r\n",
"        wc_stack_frame = update_cnt; \r\n",
"        strncpy( location_max_stack, fctname, sizeof( location_max_stack ) - 1 );\r\n",
"        location_max_stack[sizeof( location_max_stack ) - 1] = '\\0';\r\n",
"\r\n",
"        /* Save Call Tree */\r\n",
"        memmove( stack_callers[1], stack_callers[0], sizeof( caller_info ) * current_calls );\r\n",
"\r\n",
"        /* Terminate the List with 0 (for printing purposes) */\r\n",
"        if ( current_calls < max_num_calls )\r\n",
"        {\r\n",
"            stack_callers[1][current_calls].function_name[0] = 0;\r\n",
"        }\r\n",
"    }\r\n",
"\r\n",
"    /* Check, if This is the New Worst-Case RAM (stack + heap) */\r\n",
"    current_stack_size = (int32_t) ( ( ( ptr_base_stack - ptr_current_stack ) * sizeof( int16_t ) ) );\r\n",
"\r\n",
"    if ( current_stack_size < 0 )\r\n",
"    {\r\n",
"        /* prevent negative stack size */\r\n",
"        current_stack_size = 0;\r\n",
"    }\r\n",
"\r\n",
"    if ( current_stack_size + current_heap_size > wc_ram_size )\r\n",
"    {\r\n",
"        wc_ram_size = current_stack_size + current_heap_size;\r\n",
"        wc_ram_frame = update_cnt;\r\n",
"    }\r\n",
"\r\n",
"    return 0 /* for Now */;\r\n",
"}\r\n",
"\r\n",
"/*-------------------------------------------------------------------*\r\n",
" * pop_stack()\r\n",
" *\r\n",
" * Remove stack caller entry from the list\r\n",
" *--------------------------------------------------------------------*/\r\n",
"\r\n",
"int pop_stack( const char *filename, const char *fctname )\r\n",
"{\r\n",
"    caller_info *caller_info_ptr;\r\n",
"\r\n",
"    (void) *filename; /* to avoid compilation warning */\r\n",
"\r\n",
"    /* Decrease the Number of Records */\r\n",
"    current_calls--;\r\n",
"\r\n",
"    /* Get Pointer to Caller Information */\r\n",
"    caller_info_ptr = &stack_callers[0][current_calls];\r\n",
"\r\n",
"    /* Check, if the Function Names Match */\r\n",
"    if ( strncmp( caller_info_ptr->function_name, fctname, MAX_FUNCTION_NAME_LENGTH ) != 0 )\r\n",
"    {\r\n",
"        fprintf( stderr, \"Invalid usage of pop_stack()\" );\r\n",
"        exit( -1 );\r\n",
"    }\r\n",
"\r\n",
"    /* Erase Entry */\r\n",
"    caller_info_ptr->function_name[0] = 0;\r\n",
"\r\n",
"    /* Retrieve previous stack pointer */\r\n",
"    if ( current_calls == 0 )\r\n",
"    {\r\n",
"        ptr_current_stack = ptr_base_stack;\r\n",
"    }\r\n",
"    else\r\n",
"    {\r\n",
"        ptr_current_stack = stack_callers[0][current_calls - 1].stack_ptr;\r\n",
"    }\r\n",
"\r\n",
"    return 0 /* for Now */;\r\n",
"}\r\n",
"\r\n",
"#ifdef MEM_COUNT_DETAILS\r\n",
"/*-------------------------------------------------------------------*\r\n",
" * print_stack_call_tree()\r\n",
" *\r\n",
" * Print detailed information about worst-case stack usage\r\n",
" *--------------------------------------------------------------------*/\r\n",
"\r\n",
"static void print_stack_call_tree( void )\r\n",
"{\r\n",
"    caller_info *caller_info_ptr;\r\n",
"    int call_level;\r\n",
"    char fctname[MAX_FUNCTION_NAME_LENGTH + 1];\r\n",
"\r\n",
"    fprintf( stdout, \"\\nList of functions when maximum stack size is reached:\\n\\n\" );\r\n",
"\r\n",
"    caller_info_ptr = &stack_callers[1][0];\r\n",
"    for ( call_level = 0; call_level < max_num_calls; call_level++ )\r\n",
"    {\r\n",
"        /* Done? */\r\n",
"        if ( caller_info_ptr->function_name[0] == 0 )\r\n",
"        {\r\n",
"            break;\r\n",
"        }\r\n",
"\r\n",
"        /* Print Name */\r\n",
"        strncpy( fctname, caller_info_ptr->function_name, MAX_FUNCTION_NAME_LENGTH );\r\n",
"        strcat( fctname, \"()\" );\r\n",
"        fprintf( stdout, \"%-42s\", fctname );\r\n",
"\r\n",
"        /* Print Stack Usage (Based on Difference) */\r\n",
"        if ( call_level != 0 )\r\n",
"        {\r\n",
"            fprintf( stdout, \"%lu %s\\n\", ( ( ( caller_info_ptr - 1 )->stack_ptr - caller_info_ptr->stack_ptr ) * sizeof( int16_t ) ) >> Stat_Cnt_Size, Count_Unit[Stat_Cnt_Size] );\r\n",
"        }\r\n",
"        else\r\n",
"        {\r\n",
"            fprintf( stdout, \"%lu %s\\n\", ( ( ptr_base_stack - caller_info_ptr->stack_ptr ) * sizeof( int16_t ) ) >> Stat_Cnt_Size, Count_Unit[Stat_Cnt_Size] );\r\n",
"        }\r\n",
"\r\n",
"        /* Advance */\r\n",
"        caller_info_ptr++;\r\n",
"    }\r\n",
"\r\n",
"    fprintf( stdout, \"\\n\" );\r\n",
"\r\n",
"    return;\r\n",
"}\r\n",
"#endif\r\n",
"\r\n",
"\r\n",
"/*-------------------------------------------------------------------*\r\n",
" * mem_alloc()\r\n",
" *\r\n",
" * Creates new record, stores auxiliary information about which function allocated the memory, line number, parameters, etc.\r\n",
" * Finally, it allocates physical memory using malloc()\r\n",
" * The function also updates worst-case heap size and worst-case RAM size\r\n",
" *--------------------------------------------------------------------*/\r\n",
"\r\n",
"void *mem_alloc(\r\n",
"    const char *func_name,\r\n",
"    int func_lineno,\r\n",
"    size_t size,\r\n",
"    char *size_str /* the first char indicates m-alloc or c-alloc */ )\r\n",
"{\r\n",
"    int index_record;\r\n",
"    int32_t current_stack_size;\r\n",
"    unsigned long hash;\r\n",
"    allocator_record *ptr_record;\r\n",
"\r\n",
"    if ( size == 0 )\r\n",
"    {\r\n",
"        fprintf( stderr, \"Fct=%s, Ln=%i: %s!\\n\", func_name, func_lineno, \"Size of Zero not Supported\" );\r\n",
"        exit( -1 );\r\n",
"    }\r\n",
"\r\n",
"    /* Search for an existing record (that has been de-allocated before) */\r\n",
"    index_record = 0;\r\n",
"    while ( ( ptr_record = get_mem_record( &hash, func_name, func_lineno, size_str, &index_record ) ) != NULL )\r\n",
"    {\r\n",
"        if ( ptr_record->frame_allocated == -1 )\r\n",
"        {\r\n",
"            break;\r\n",
"        }\r\n",
"        else\r\n",
"        {\r\n",
"            index_record++;\r\n",
"        }\r\n",
"    }\r\n",
"\r\n",
"    /* Create new record */\r\n",
"    if ( ptr_record == NULL )\r\n",
"    {\r\n",
"        if ( Num_Records >= Max_Num_Records )\r\n",
"        {\r\n",
"            /* There is no room for a new record -> reallocate memory */\r\n",
"            Max_Num_Records += MAX_NUM_RECORDS_REALLOC_STEP;\r\n",
"            allocation_list = realloc( allocation_list, Max_Num_Records * sizeof( allocator_record ) );\r\n",
"        }\r\n",
"\r\n",
"        ptr_record = &( allocation_list[Num_Records] );\r\n",
"\r\n",
"        /* Initialize new record */\r\n",
"        ptr_record->hash = hash;\r\n",
"        ptr_record->noccurances = 0;\r\n",
"        ptr_record->total_block_size = 0;\r\n",
"        ptr_record->total_used_size = 0;\r\n",
"        ptr_record->frame_allocated = -1;\r\n",
"        ptr_record->OOB_Flag = 0;\r\n",
"        ptr_record->wc_heap_size_intra_frame = -1;\r\n",
"        ptr_record->wc_heap_size_inter_frame = -1;\r\n",
"\r\n",
"        index_record = Num_Records;\r\n",
"        Num_Records++;\r\n",
"    }\r\n",
"\r\n",
"    /* Allocate memory block for the new record, add signature before the beginning and after the memory block and fill it with magic value */\r\n",
"    ptr_record->block_ptr = mem_alloc_block( size, size_str );\r\n",
"\r\n",
"    if ( ptr_record->block_ptr == NULL )\r\n",
"    {\r\n",
"        fprintf( stderr, \"Fct=%s, Ln=%i: %s!\\n\", func_name, func_lineno, \"Error: Cannot Allocate Memory!\" );\r\n",
"        exit( -1 );\r\n",
"    }\r\n",
"\r\n",
"    /* Save all auxiliary information about the memory block */\r\n",
"    strncpy( ptr_record->name, func_name, MAX_FUNCTION_NAME_LENGTH );\r\n",
"    ptr_record->name[MAX_FUNCTION_NAME_LENGTH] = '\\0';\r\n",
"    strncpy( ptr_record->params, size_str, MAX_PARAMS_LENGTH ); /* Note: The size string starts with either 'm' or 'c' to indicate 'm'alloc or 'c'alloc */\r\n",
"    ptr_record->params[MAX_PARAMS_LENGTH] = '\\0';\r\n",
"    ptr_record->lineno = func_lineno;\r\n",
"    ptr_record->block_size = size;\r\n",
"    ptr_record->total_block_size += size;\r\n",
"\r\n",
"#ifdef MEM_COUNT_DETAILS\r\n",
"    /* Export heap memory allocation record to the .csv file */\r\n",
"    fprintf( fid_csv_filename, \"A,%d,%s,%d,%d\\n\", update_cnt, ptr_record->name, ptr_record->lineno, ptr_record->block_size );\r\n",
"#endif\r\n",
"\r\n",
"    if ( ptr_record->frame_allocated != -1 )\r\n",
"    {\r\n",
"        fprintf( stderr, \"Fct=%s, Ln=%i: %s!\\n\", func_name, func_lineno, \"Error: Attempt to Allocate the Same Memory Block with Freeing it First!\" );\r\n",
"        exit( -1 );\r\n",
"    }\r\n",
"\r\n",
"    ptr_record->frame_allocated = update_cnt; /* Store the current frame number -> later it will be used to determine the total duration */\r\n",
"\r\n",
"    /* Update Heap Size in the current frame */\r\n",
"    current_heap_size += ptr_record->block_size;\r\n",
"\r\n",
"    /* Check, if this is the new Worst-Case RAM (stack + heap) */\r\n",
"    current_stack_size = (int32_t) ( ( ( ptr_base_stack - ptr_current_stack ) * sizeof( int16_t ) ) );\r\n",
"    if ( current_stack_size + current_heap_size > wc_ram_size )\r\n",
"    {\r\n",
"        wc_ram_size = current_stack_size + current_heap_size;\r\n",
"        wc_ram_frame = update_cnt;\r\n",
"    }\r\n",
"\r\n",
"    /* Add new entry to the heap allocation call tree */\r\n",
"    if ( heap_allocation_call_tree == NULL )\r\n",
"    {\r\n",
"        fprintf( stderr, \"Error: Heap allocation call tree not created!\" );\r\n",
"        exit( -1 );\r\n",
"    }\r\n",
"\r\n",
"    /* check, if the maximum size of the call tree has been reached -> resize if so */\r\n",
"    if ( heap_allocation_call_tree_size >= heap_allocation_call_tree_max_size )\r\n",
"    {\r\n",
"        heap_allocation_call_tree_max_size += MAX_NUM_RECORDS_REALLOC_STEP;\r\n",
"        heap_allocation_call_tree = (int *) realloc( heap_allocation_call_tree, heap_allocation_call_tree_max_size * sizeof( int ) );\r\n",
"    }\r\n",
"\r\n",
"    /* push new entry (positive number means push op, neagtive number means pop op; zero index must be converted to 0.01 :-) */\r\n",
"    heap_allocation_call_tree[heap_allocation_call_tree_size++] = index_record;\r\n",
"\r\n",
"    return ptr_record->block_ptr;\r\n",
"}\r\n",
"\r\n",
"/*-------------------------------------------------------------------*\r\n",
" * mem_alloc_block()\r\n",
" *\r\n",
" * Physical allocation of memory using malloc(). Appends 'signature' before and after the block,\r\n",
" * pre-fills memory block with magic value\r\n",
" *--------------------------------------------------------------------*/\r\n",
"\r\n",
"static void *mem_alloc_block( size_t size, const char *size_str )\r\n",
"{\r\n",
"    size_t rounded_size;\r\n",
"    void *block_ptr;\r\n",
"    char *tmp_ptr;\r\n",
"    size_t n, f;\r\n",
"    int32_t fill_value;\r\n",
"    int32_t *ptr32;\r\n",
"    int32_t mask, temp;\r\n",
"\r\n",
"    /* Round Up Block Size */\r\n",
"    rounded_size = ROUND_BLOCK_SIZE( size );\r\n",
"\r\n",
"    /* Allocate memory using the standard malloc() by adding room for Signature Values */\r\n",
"    block_ptr = malloc( rounded_size + BLOCK_ROUNDING * 2 );\r\n",
"\r\n",
"    if ( block_ptr == NULL )\r\n",
"    {\r\n",
"        return NULL;\r\n",
"    }\r\n",
"\r\n",
"    /* Add Signature Before the Start of the Block */\r\n",
"    ptr32 = (int32_t *) block_ptr;\r\n",
"    n = N_32BITS_BLOCKS;\r\n",
"    do\r\n",
"    {\r\n",
"        *ptr32++ = MAGIC_VALUE_OOB;\r\n",
"    } while ( --n );\r\n",
"\r\n",
"    /* Fill Memory Block with Magic Value or 0 */\r\n",
"    fill_value = MAGIC_VALUE_USED;\r\n",
"    if ( size_str[0] == 'c' )\r\n",
"    {\r\n",
"        fill_value = 0x00000000;\r\n",
"    }\r\n",
"    n = size / sizeof( int32_t );\r\n",
"    while ( n-- )\r\n",
"    {\r\n",
"        *ptr32++ = fill_value;\r\n",
"    }\r\n",
"\r\n",
"    /* Fill the Reminder of the Memory Block - After Rounding */\r\n",
"    n = rounded_size - size;\r\n",
"    f = n % sizeof( int32_t );\r\n",
"    if ( f != 0 )\r\n",
"    {\r\n",
"        /* when filling with '0' need to adapt the magic value */\r\n",
"        /* shift by [1->24, 2->16, 3->8] */\r\n",
"        mask = 0xFFFFFFFF << ( ( sizeof( int32_t ) - f ) * 8 ); /* (1) */\r\n",
"        temp = MAGIC_VALUE_OOB & mask;\r\n",
"        if ( fill_value != 0x0 )\r\n",
"        { /* for malloc merge fill value */\r\n",
"            temp += ( ~mask ) & MAGIC_VALUE_USED;\r\n",
"        } /* for calloc the code in (1) above already introduces zeros */\r\n",
"        *ptr32++ = temp;\r\n",
"    }\r\n",
"    n /= sizeof( int32_t );\r\n",
"    n += N_32BITS_BLOCKS;\r\n",
"\r\n",
"    /* Add Signature After the End of Block */\r\n",
"    do\r\n",
"    {\r\n",
"        *ptr32++ = MAGIC_VALUE_OOB;\r\n",
"    } while ( --n );\r\n",
"\r\n",
"    /* Adjust the Memory Block Pointer (Magic Value Before and After the Memory Block Requested) */\r\n",
"    tmp_ptr = (char *) block_ptr;\r\n",
"    tmp_ptr += BLOCK_ROUNDING;\r\n",
"    block_ptr = (void *) tmp_ptr;\r\n",
"\r\n",
"    return block_ptr;\r\n",
"}\r\n",
"\r\n",
"/*-------------------------------------------------------------------*\r\n",
" * mem_set_usage()\r\n",
" *\r\n",
" * Calculates actual usage of memory block by checking the magic value that was used to pre-fill\r\n",
" * each memory block during its allocation\r\n",
" *--------------------------------------------------------------------*/\r\n",
"\r\n",
"static int mem_set_usage( allocator_record *record_ptr )\r\n",
"{\r\n",
"    int total_bytes_used;\r\n",
"\r\n",
"    size_t n;\r\n",
"    int32_t *ptr32;\r\n",
"    char *ptr8;\r\n",
"    size_t total_bytes;\r\n",
"    int32_t fill_value;\r\n",
"\r\n",
"    fill_value = MAGIC_VALUE_USED;\r\n",
"    if ( ( record_ptr->params[0] ) == 'c' )\r\n",
"    {\r\n",
"        fill_value = 0x00000000;\r\n",
"    }\r\n",
"\r\n",
"    total_bytes = record_ptr->block_size;\r\n",
"\r\n",
"    /* Check 4 bytes at a time */\r\n",
"    ptr32 = (int32_t *) record_ptr->block_ptr;\r\n",
"    total_bytes_used = 0;\r\n",
"    for ( n = total_bytes / sizeof( int32_t ); n > 0; n-- )\r\n",
"    {\r\n",
"        if ( *ptr32++ != fill_value )\r\n",
"        {\r\n",
"            total_bytes_used += sizeof( int32_t );\r\n",
"        }\r\n",
"    }\r\n",
"\r\n",
"    /* Check remaining bytes (If Applicable) 1 byte at a time */\r\n",
"    ptr8 = (char *) ptr32;\r\n",
"    for ( n = total_bytes % sizeof( int32_t ); n > 0; n-- )\r\n",
"    {\r\n",
"        if ( *ptr8++ != (char) fill_value )\r\n",
"        {\r\n",
"            total_bytes_used++;\r\n",
"        }\r\n",
"\r\n",
"        /* Update Value */\r\n",
"        fill_value >>= 8;\r\n",
"    }\r\n",
"\r\n",
"    return total_bytes_used;\r\n",
"}\r\n",
"\r\n",
"/*-------------------------------------------------------------------*\r\n",
" * mem_check_OOB()\r\n",
" *\r\n",
" * Checks, if out-of-bounds access has occured. This is done by inspecting the 'signature' value\r\n",
" * taht has been added before and after the memory block during its allocation\r\n",
" *--------------------------------------------------------------------*/\r\n",
"\r\n",
"static unsigned int mem_check_OOB( allocator_record *record_ptr )\r\n",
"{\r\n",
"    int32_t *ptr32;\r\n",
"    unsigned int OOB_Flag = 0x0;\r\n",
"    int32_t mask;\r\n",
"    size_t i;\r\n",
"    int f;\r\n",
"\r\n",
"    ptr32 = (int32_t *) record_ptr->block_ptr - N_32BITS_BLOCKS;\r\n",
"\r\n",
"    /* Check the Signature at the Beginning of Memory Block */\r\n",
"    i = N_32BITS_BLOCKS;\r\n",
"    do\r\n",
"    {\r\n",
"        if ( *ptr32++ ^ MAGIC_VALUE_OOB )\r\n",
"        {\r\n",
"            OOB_Flag |= OOB_START;\r\n",
"        }\r\n",
"    } while ( --i );\r\n",
"\r\n",
"    /* Advance to End (Snap to lowest 32 Bits) */\r\n",
"    ptr32 += record_ptr->block_size / sizeof( int32_t );\r\n",
"\r\n",
"    /* Calculate Unused Space That has been added to get to the rounded Block Size */\r\n",
"    i = ROUND_BLOCK_SIZE( record_ptr->block_size ) - record_ptr->block_size;\r\n",
"\r\n",
"    /* Partial Check of Signature at the End of Memory Block (for block size that has been rounded) */\r\n",
"    f = i % sizeof( int32_t );\r\n",
"    if ( f != 0 )\r\n",
"    {\r\n",
"        mask = 0xFFFFFFFF << ( ( sizeof( int32_t ) - f ) * 8 );\r\n",
"        if ( ( *ptr32++ ^ MAGIC_VALUE_OOB ) & mask )\r\n",
"        {\r\n",
"            OOB_Flag |= OOB_END;\r\n",
"        }\r\n",
"    }\r\n",
"\r\n",
"    /* Full Check of Signature at the End of Memory Block, i.e. all 32 Bits (for the remainder after rounding) */\r\n",
"    i /= sizeof( int32_t );\r\n",
"    i += N_32BITS_BLOCKS;\r\n",
"    do\r\n",
"    {\r\n",
"        if ( *ptr32++ ^ MAGIC_VALUE_OOB )\r\n",
"        {\r\n",
"            OOB_Flag |= OOB_END;\r\n",
"        }\r\n",
"    } while ( --i );\r\n",
"\r\n",
"    return OOB_Flag;\r\n",
"}\r\n",
"\r\n",
"/*-------------------------------------------------------------------*\r\n",
" * malloc_hash()\r\n",
" *\r\n",
" * Calculate hash from function name, line number and malloc size\r\n",
" *--------------------------------------------------------------------*/\r\n",
"\r\n",
"static unsigned long malloc_hash( const char *func_name, int func_lineno, char *size_str )\r\n",
"{\r\n",
"    unsigned long hash = 5381;\r\n",
"    const char *ptr_str;\r\n",
"\r\n",
"    ptr_str = func_name;\r\n",
"    while ( ptr_str != NULL && *ptr_str != '\\0' )\r\n",
"    {\r\n",
"        hash = ( ( hash << 5 ) + hash ) + *ptr_str++; /* hash * 33 + char */\r\n",
"    }\r\n",
"\r\n",
"    hash = ( ( hash << 5 ) + hash ) + func_lineno; /* hash * 33 + func_lineno */\r\n",
"\r\n",
"    ptr_str = size_str;\r\n",
"    while ( ptr_str != NULL && *ptr_str != '\\0' )\r\n",
"    {\r\n",
"        hash = ( ( hash << 5 ) + hash ) + *ptr_str++; /* hash * 33 + char */\r\n",
"    }\r\n",
"\r\n",
"    return hash;\r\n",
"}\r\n",
"\r\n",
"/*-------------------------------------------------------------------*\r\n",
" * get_mem_record()\r\n",
" *\r\n",
" * Search for memory record in the internal list, return NULL if not found\r\n",
" * Start from index_record\r\n",
" *--------------------------------------------------------------------*/\r\n",
"\r\n",
"allocator_record *get_mem_record( unsigned long *hash, const char *func_name, int func_lineno, char *size_str, int *index_record )\r\n",
"{\r\n",
"    int i;\r\n",
"\r\n",
"    if ( *index_record < 0 || *index_record > Num_Records )\r\n",
"    {\r\n",
"        return NULL;\r\n",
"    }\r\n",
"\r\n",
"    /* calculate hash */\r\n",
"    *hash = malloc_hash( func_name, func_lineno, size_str );\r\n",
"\r\n",
"    for ( i = *index_record; i < Num_Records; i++ )\r\n",
"    {\r\n",
"        /* check, if memory block is not allocated at the moment and the hash matches */\r\n",
"        if ( allocation_list[i].block_ptr == NULL && *hash == allocation_list[i].hash )\r\n",
"        {\r\n",
"            *index_record = i;\r\n",
"            return &( allocation_list[i] );\r\n",
"        }\r\n",
"    }\r\n",
"\r\n",
"    /* not found */\r\n",
"    *index_record = -1;\r\n",
"    return NULL;\r\n",
"}\r\n",
"\r\n",
"\r\n",
"/*-------------------------------------------------------------------*\r\n",
" * mem_free()\r\n",
" *\r\n",
" * This function de-allocatesd the memory block and frees the mphysical memory with free().\r\n",
" * It also updates actual and average usage of the memory block.\r\n",
" *\r\n",
" * Note: The record is not removed from the list and may be reused later on in mem_alloc()!\r\n",
" *--------------------------------------------------------------------*/\r\n",
"\r\n",
"void mem_free( const char *func_name, int func_lineno, void *ptr )\r\n",
"{\r\n",
"    int i, index_record;\r\n",
"    char *tmp_ptr;\r\n",
"    allocator_record *ptr_record;\r\n",
"\r\n",
"    /* Search for the Block Pointer in the List */\r\n",
"    ptr_record = NULL;\r\n",
"    index_record = -1;\r\n",
"    for ( i = 0; i < Num_Records; i++ )\r\n",
"    {\r\n",
"        if ( ptr == allocation_list[i].block_ptr )\r\n",
"        { /* Yes, Found it */\r\n",
"            ptr_record = &( allocation_list[i] );\r\n",
"            index_record = i;\r\n",
"            break;\r\n",
"        }\r\n",
"    }\r\n",
"\r\n",
"    if ( ptr_record == NULL )\r\n",
"    {\r\n",
"        fprintf( stderr, \"Fct=%s, Ln=%i: %s!\\n\", func_name, func_lineno, \"Error: Unable to Find Record Corresponding to the Allocated Memory Block!\" );\r\n",
"        exit( -1 );\r\n",
"    }\r\n",
"\r\n",
"    /* Update the Heap Size */\r\n",
"    current_heap_size -= ptr_record->block_size;\r\n",
"\r\n",
"    /* Calculate the Actual Usage of the Memory Block (Look for Signature) */\r\n",
"    ptr_record->total_used_size += mem_set_usage( ptr_record );\r\n",
"\r\n",
"    /* Check, if Out-Of-Bounds Access has been Detected */\r\n",
"    ptr_record->OOB_Flag = mem_check_OOB( ptr_record );\r\n",
"\r\n",
"#ifdef MEM_COUNT_DETAILS\r\n",
"    /* Export heap memory de-allocation record to the .csv file */\r\n",
"    fprintf( fid_csv_filename, \"D,%d,%s,%d,%d\\n\", update_cnt, ptr_record->name, ptr_record->lineno, ptr_record->block_size );\r\n",
"#endif\r\n",
"\r\n",
"    /* De-Allocate Memory Block */\r\n",
"    tmp_ptr = (char *) ptr;\r\n",
"    tmp_ptr -= BLOCK_ROUNDING;\r\n",
"    ptr = (void *) tmp_ptr;\r\n",
"    free( ptr );\r\n",
"\r\n",
"    /* Add new entry to the heap allocation call tree */\r\n",
"    if ( heap_allocation_call_tree == NULL )\r\n",
"    {\r\n",
"        fprintf( stderr, \"Error: Heap allocation call tree not created!\" );\r\n",
"        exit( -1 );\r\n",
"    }\r\n",
"\r\n",
"    /* check, if the maximum size of the call tree has been reached -> resize if so */\r\n",
"    if ( heap_allocation_call_tree_size >= heap_allocation_call_tree_max_size )\r\n",
"    {\r\n",
"        heap_allocation_call_tree_max_size += MAX_NUM_RECORDS_REALLOC_STEP;\r\n",
"        heap_allocation_call_tree = (int *) realloc( heap_allocation_call_tree, heap_allocation_call_tree_max_size * sizeof( int ) );\r\n",
"    }\r\n",
"\r\n",
"    heap_allocation_call_tree[heap_allocation_call_tree_size++] = -index_record;\r\n",
"\r\n",
"    /* Reset memory block pointer (this is checked when updating wc intra-frame and inter-frame memory) */\r\n",
"    ptr_record->block_ptr = NULL;\r\n",
"\r\n",
"    return;\r\n",
"}\r\n",
"\r\n",
"\r\n",
"/*-------------------------------------------------------------------*\r\n",
" * update_mem()\r\n",
" *\r\n",
" * This function updates the worst-case intra-frame memory and the worst-case inter-frame memory.\r\n",
" *--------------------------------------------------------------------*/\r\n",
"\r\n",
"void update_mem( void )\r\n",
"{\r\n",
"    int i, j, flag_alloc = -1, i_record;\r\n",
"    int size_current_intra_frame_heap;\r\n",
"    int *list_current_intra_frame_heap = NULL, n_items_current_intra_frame_heap;\r\n",
"    allocator_record *ptr_record;\r\n",
"\r\n",
"    /* process the heap allocation call tree and prepare lists of intra-frame and inter-frame heap memory blocks for this frame */\r\n",
"    n_items_current_intra_frame_heap = 0;\r\n",
"    size_current_intra_frame_heap = 0;\r\n",
"    for ( i = 0; i < heap_allocation_call_tree_size; i++ )\r\n",
"    {\r\n",
"        /* get the record */\r\n",
"        i_record = heap_allocation_call_tree[i];\r\n",
"\r\n",
"        if ( i_record > 0 )\r\n",
"        {\r\n",
"            flag_alloc = 1;\r\n",
"        }\r\n",
"        else if ( i_record < 0 )\r\n",
"        {\r\n",
"            flag_alloc = 0;\r\n",
"            i_record = -i_record;\r\n",
"        }\r\n",
"        ptr_record = &( allocation_list[i_record] );\r\n",
"\r\n",
"        if ( ptr_record->frame_allocated == update_cnt && ptr_record->block_ptr == NULL )\r\n",
"        {\r\n",
"            /* intra-frame heap memory */\r\n",
"            if ( list_current_intra_frame_heap == NULL )\r\n",
"            {\r\n",
"                list_current_intra_frame_heap = (int *) malloc( heap_allocation_call_tree_size * sizeof( int ) );\r\n",
"                memset( list_current_intra_frame_heap, -1, heap_allocation_call_tree_size * sizeof( int ) );\r\n",
"            }\r\n",
"\r\n",
"            /* zero index doesn't have sign to determine whether it's allocated or de-allocated -> we need to search the list */\r\n",
"            if ( i_record == 0 )\r\n",
"            {\r\n",
"                flag_alloc = 1;\r\n",
"                for ( j = 0; j < n_items_current_intra_frame_heap; j++ )\r\n",
"                {\r\n",
"                    if ( list_current_intra_frame_heap[j] == i_record )\r\n",
"                    {\r\n",
"                        flag_alloc = 0;\r\n",
"                        break;\r\n",
"                    }\r\n",
"                }\r\n",
"            }\r\n",
"\r\n",
"            if ( flag_alloc )\r\n",
"            {\r\n",
"                /* add to list */\r\n",
"                list_current_intra_frame_heap[n_items_current_intra_frame_heap++] = i_record;\r\n",
"                size_current_intra_frame_heap += ptr_record->block_size;\r\n",
"\r\n",
"                /* no need to re-size the list -> the initially allocated size should be large enough */\r\n",
"            }\r\n",
"            else\r\n",
"            {\r\n",
"                /* remove from list */\r\n",
"                for ( j = 0; j < n_items_current_intra_frame_heap; j++ )\r\n",
"                {\r\n",
"                    if ( list_current_intra_frame_heap[j] == i_record )\r\n",
"                    {\r\n",
"                        break;\r\n",
"                    }\r\n",
"                }\r\n",
"                memmove( &list_current_intra_frame_heap[j], &list_current_intra_frame_heap[j + 1], ( n_items_current_intra_frame_heap - j ) * sizeof( int ) );\r\n",
"                n_items_current_intra_frame_heap--;\r\n",
"                size_current_intra_frame_heap -= ptr_record->block_size;\r\n",
"\r\n",
"                /* reset block size */\r\n",
"                ptr_record->frame_allocated = -1;\r\n",
"                ptr_record->block_size = 0;\r\n",
"            }\r\n",
"        }\r\n",
"        else\r\n",
"        {\r\n",
"            /* inter-frame heap memory */\r\n",
"\r\n",
"            /* zero index doesn't have sign to determine whether it's  allocated or de-allocated -> we need to search the list */\r\n",
"            if ( i_record == 0 )\r\n",
"            {\r\n",
"                flag_alloc = 1;\r\n",
"                for ( j = 0; j < n_items_current_inter_frame_heap; j++ )\r\n",
"                {\r\n",
"                    if ( list_current_inter_frame_heap[j] == i_record )\r\n",
"                    {\r\n",
"                        flag_alloc = 0;\r\n",
"                        break;\r\n",
"                    }\r\n",
"                }\r\n",
"            }\r\n",
"\r\n",
"            if ( flag_alloc )\r\n",
"            {\r\n",
"                /* add to list */\r\n",
"                if ( n_items_current_inter_frame_heap >= max_items_current_inter_frame_heap )\r\n",
"                {\r\n",
"                    /* resize list, if needed */\r\n",
"                    max_items_current_inter_frame_heap = n_items_current_inter_frame_heap + MAX_NUM_RECORDS_REALLOC_STEP;\r\n",
"                    list_current_inter_frame_heap = realloc( list_current_inter_frame_heap, max_items_current_inter_frame_heap * sizeof( int ) );\r\n",
"                }\r\n",
"\r\n",
"                list_current_inter_frame_heap[n_items_current_inter_frame_heap++] = i_record;\r\n",
"                size_current_inter_frame_heap += ptr_record->block_size;\r\n",
"            }\r\n",
"            else\r\n",
"            {\r\n",
"                /* remove from list */\r\n",
"                for ( j = 0; j < n_items_current_inter_frame_heap; j++ )\r\n",
"                {\r\n",
"                    if ( list_current_inter_frame_heap[j] == i_record )\r\n",
"                    {\r\n",
"                        break;\r\n",
"                    }\r\n",
"                }\r\n",
"                memmove( &list_current_inter_frame_heap[j], &list_current_inter_frame_heap[j + 1], ( n_items_current_inter_frame_heap - j ) * sizeof( int ) );\r\n",
"                n_items_current_inter_frame_heap--;\r\n",
"                size_current_inter_frame_heap -= ptr_record->block_size;\r\n",
"\r\n",
"                /* reset block size */\r\n",
"                ptr_record->frame_allocated = -1;\r\n",
"                ptr_record->block_size = 0;\r\n",
"            }\r\n",
"        }\r\n",
"    }\r\n",
"\r\n",
"    /* check, if this is the new worst-case for intra-frame heap memory */\r\n",
"    if ( size_current_intra_frame_heap > size_wc_intra_frame_heap )\r\n",
"    {\r\n",
"        if ( n_items_current_intra_frame_heap >= max_items_wc_intra_frame_heap )\r\n",
"        {\r\n",
"            /* resize the list, if needed */\r\n",
"            max_items_wc_intra_frame_heap = n_items_current_intra_frame_heap + MAX_NUM_RECORDS_REALLOC_STEP;\r\n",
"            list_wc_intra_frame_heap = realloc( list_wc_intra_frame_heap, max_items_wc_intra_frame_heap * sizeof( int ) );\r\n",
"        }\r\n",
"\r\n",
"        /* copy current-frame list to worst-case list */\r\n",
"        memmove( list_wc_intra_frame_heap, list_current_intra_frame_heap, n_items_current_intra_frame_heap * sizeof( int ) );\r\n",
"        n_items_wc_intra_frame_heap = n_items_current_intra_frame_heap;\r\n",
"        size_wc_intra_frame_heap = size_current_intra_frame_heap;\r\n",
"        location_wc_intra_frame_heap = update_cnt;\r\n",
"\r\n",
"        /* update the wc numbers in all individual records */\r\n",
"        for ( i = 0; i < n_items_wc_intra_frame_heap; i++ )\r\n",
"        {\r\n",
"            i_record = list_wc_intra_frame_heap[i];\r\n",
"            ptr_record = &( allocation_list[i_record] );\r\n",
"            ptr_record->wc_heap_size_intra_frame = ptr_record->block_size;\r\n",
"        }\r\n",
"    }\r\n",
"\r\n",
"    /* check, if this is the new worst-case for inter-frame heap memory */\r\n",
"    if ( size_current_inter_frame_heap > size_wc_inter_frame_heap )\r\n",
"    {\r\n",
"        if ( n_items_current_inter_frame_heap >= max_items_wc_inter_frame_heap )\r\n",
"        {\r\n",
"            /* resize list, if needed */\r\n",
"            max_items_wc_inter_frame_heap = n_items_current_inter_frame_heap + MAX_NUM_RECORDS_REALLOC_STEP;\r\n",
"            list_wc_inter_frame_heap = realloc( list_wc_inter_frame_heap, max_items_wc_inter_frame_heap * sizeof( int ) );\r\n",
"        }\r\n",
"\r\n",
"        /* copy current-frame list to worst-case list */\r\n",
"        memmove( list_wc_inter_frame_heap, list_current_inter_frame_heap, n_items_current_inter_frame_heap * sizeof( int ) );\r\n",
"        n_items_wc_inter_frame_heap = n_items_current_inter_frame_heap;\r\n",
"        size_wc_inter_frame_heap = size_current_inter_frame_heap;\r\n",
"        location_wc_inter_frame_heap = update_cnt;\r\n",
"\r\n",
"        /* update the wc numbers in all individual records */\r\n",
"        for ( i = 0; i < n_items_wc_inter_frame_heap; i++ )\r\n",
"        {\r\n",
"            i_record = list_wc_inter_frame_heap[i];\r\n",
"            ptr_record = &( allocation_list[i_record] );\r\n",
"            ptr_record->wc_heap_size_inter_frame = ptr_record->block_size;\r\n",
"        }\r\n",
"    }\r\n",
"\r\n",
"    /* reset heap allocation call tree */\r\n",
"    heap_allocation_call_tree_size = 0;\r\n",
"\r\n",
"    /* de-allocate list of intra-frame heap memory blocks in the current fraeme - it's needed only inside this function */\r\n",
"    if ( list_current_intra_frame_heap )\r\n",
"    {\r\n",
"        free( list_current_intra_frame_heap );\r\n",
"    }\r\n",
"\r\n",
"    return;\r\n",
"}\r\n",
"\r\n",
"#ifdef MEM_COUNT_DETAILS\r\n",
"/*-------------------------------------------------------------------*\r\n",
" * subst()\r\n",
" *\r\n",
" * Substitute character in string\r\n",
" *--------------------------------------------------------------------*/\r\n",
"\r\n",
"static void subst( char *s, char from, char to )\r\n",
"{\r\n",
"    while ( *s == from )\r\n",
"    {\r\n",
"        *s++ = to;\r\n",
"    }\r\n",
"\r\n",
"    return;\r\n",
"}\r\n",
"\r\n",
"\r\n",
"/*-------------------------------------------------------------------*\r\n",
" * mem_count_summary()\r\n",
" *\r\n",
" * Print detailed (per-item) information about heap memory usage\r\n",
" *--------------------------------------------------------------------*/\r\n",
"\r\n",
"static void mem_count_summary( void )\r\n",
"{\r\n",
"    int i, j, index, index_record;\r\n",
"    size_t length;\r\n",
"    char buf[300], format_str[50], name_str[MAX_FUNCTION_NAME_LENGTH + 3], parms_str[MAX_PARAMS_LENGTH + 1], type_str[10], usage_str[20], size_str[20], line_str[10];\r\n",
"    allocator_record *ptr_record, *ptr;\r\n",
"\r\n",
"    /* Prepare format string */\r\n",
"    sprintf( format_str, \"%%-%ds %%5s %%6s %%-%ds %%20s %%6s \", MAX_FUNCTION_NAME_LENGTH, MAX_PARAMS_LENGTH );\r\n",
"\r\n",
"    if ( n_items_wc_intra_frame_heap > 0 )\r\n",
"    {\r\n",
"        /* Intra-Frame Heap Size */\r\n",
"        fprintf( stdout, \"\\nList of memory blocks when maximum intra-frame heap size is reached:\\n\\n\" );\r\n",
"\r\n",
"        /* Find duplicate records (same hash and worst-case heap size) */\r\n",
"        for ( i = 0; i < n_items_wc_intra_frame_heap; i++ )\r\n",
"        {\r\n",
"            index_record = list_wc_intra_frame_heap[i];\r\n",
"            if ( index_record == -1 )\r\n",
"            {\r\n",
"                continue;\r\n",
"            }\r\n",
"\r\n",
"            ptr_record = &( allocation_list[index_record] );\r\n",
"            for ( j = i + 1; j < n_items_wc_intra_frame_heap; j++ )\r\n",
"            {\r\n",
"                index = list_wc_intra_frame_heap[j];\r\n",
"                if ( index == -1 )\r\n",
"                {\r\n",
"                    continue;\r\n",
"                }\r\n",
"                ptr = &( allocation_list[index] );\r\n",
"\r\n",
"                if ( ptr->hash == ptr_record->hash && ptr->wc_heap_size_intra_frame == ptr_record->wc_heap_size_intra_frame )\r\n",
"                {\r\n",
"                    ptr_record->noccurances++;\r\n",
"                    list_wc_intra_frame_heap[j] = -1;\r\n",
"                }\r\n",
"            }\r\n",
"        }\r\n",
"\r\n",
"        /* Print Header */\r\n",
"        sprintf( buf, format_str, \"Function Name\", \"Line\", \"Type\", \"Function Parameters\", \"Maximum Size\", \"Usage\" );\r\n",
"        puts( buf );\r\n",
"        length = strlen( buf );\r\n",
"        sprintf( buf, \"%0*d\\n\", (int) length - 1, 0 );\r\n",
"        subst( buf, '0', '-' );\r\n",
"        puts( buf );\r\n",
"\r\n",
"        for ( i = 0; i < n_items_wc_intra_frame_heap; i++ )\r\n",
"        {\r\n",
"            index_record = list_wc_intra_frame_heap[i];\r\n",
"\r\n",
"            if ( index_record != -1 )\r\n",
"            {\r\n",
"                /* get the record */\r\n",
"                ptr_record = &( allocation_list[index_record] );\r\n",
"\r\n",
"                /* prepare information strings */\r\n",
"                strncpy( name_str, ptr_record->name, MAX_FUNCTION_NAME_LENGTH );\r\n",
"                strcat( name_str, \"()\" );\r\n",
"                name_str[MAX_FUNCTION_NAME_LENGTH] = '\\0';\r\n",
"                strncpy( parms_str, &( ptr_record->params[2] ), MAX_PARAMS_LENGTH );\r\n",
"                parms_str[MAX_PARAMS_LENGTH] = '\\0';\r\n",
"\r\n",
"                if ( ptr_record->params[0] == 'm' )\r\n",
"                {\r\n",
"                    strcpy( type_str, \"malloc\" );\r\n",
"                }\r\n",
"                else\r\n",
"                {\r\n",
"                    strcpy( type_str, \"calloc\" );\r\n",
"                }\r\n",
"\r\n",
"                sprintf( line_str, \"%d\", ptr_record->lineno );\r\n",
"\r\n",
"                /* prepare average usage & memory size strings */\r\n",
"                sprintf( usage_str, \"%d%%\", (int) ( ( (float) ptr_record->total_used_size / ( ptr_record->total_block_size + 1 ) ) * 100.0f ) );\r\n",
"\r\n",
"                if ( ptr_record->noccurances > 1 )\r\n",
"                {\r\n",
"                    sprintf( size_str, \"%dx%d %s\", ptr_record->noccurances, (int) ( ptr_record->wc_heap_size_intra_frame >> Stat_Cnt_Size ), Count_Unit[Stat_Cnt_Size] );\r\n",
"                }\r\n",
"                else\r\n",
"                {\r\n",
"                    sprintf( size_str, \"%d %s\", (int) ( ptr_record->wc_heap_size_intra_frame >> Stat_Cnt_Size ), Count_Unit[Stat_Cnt_Size] );\r\n",
"                }\r\n",
"\r\n",
"                sprintf( buf, format_str, name_str, line_str, type_str, parms_str, size_str, usage_str );\r\n",
"                puts( buf );\r\n",
"            }\r\n",
"        }\r\n",
"\r\n",
"        fprintf( stdout, \"\\n\" );\r\n",
"    }\r\n",
"\r\n",
"    if ( n_items_wc_inter_frame_heap > 0 )\r\n",
"    {\r\n",
"        /* Inter-Frame Heap Size */\r\n",
"        fprintf( stdout, \"\\nList of memory blocks when maximum inter-frame heap size is reached:\\n\\n\" );\r\n",
"\r\n",
"        /* Find duplicate records (same hash and worst-case heap size) */\r\n",
"        for ( i = 0; i < n_items_wc_inter_frame_heap; i++ )\r\n",
"        {\r\n",
"            index_record = list_wc_inter_frame_heap[i];\r\n",
"            if ( index_record == -1 )\r\n",
"            {\r\n",
"                continue;\r\n",
"            }\r\n",
"            ptr_record = &( allocation_list[index_record] );\r\n",
"            ptr_record->noccurances = 1; /* reset the counter as some blocks may have been both, intra-frame and inter-frame */\r\n",
"            for ( j = i + 1; j < n_items_wc_inter_frame_heap; j++ )\r\n",
"            {\r\n",
"                index = list_wc_inter_frame_heap[j];\r\n",
"                if ( index == -1 )\r\n",
"                {\r\n",
"                    continue;\r\n",
"                }\r\n",
"                ptr = &( allocation_list[index] );\r\n",
"\r\n",
"                if ( ptr->hash == ptr_record->hash && ptr->wc_heap_size_inter_frame == ptr_record->wc_heap_size_inter_frame )\r\n",
"                {\r\n",
"                    ptr_record->noccurances++;\r\n",
"                    list_wc_inter_frame_heap[j] = -1;\r\n",
"                }\r\n",
"            }\r\n",
"        }\r\n",
"\r\n",
"        /* Print Header */\r\n",
"        sprintf( buf, format_str, \"Function Name\", \"Line\", \"Type\", \"Function Parameters\", \"Memory Size\", \"Usage\" );\r\n",
"        puts( buf );\r\n",
"        length = strlen( buf );\r\n",
"        sprintf( buf, \"%0*d\\n\", (int) length - 1, 0 );\r\n",
"        subst( buf, '0', '-' );\r\n",
"        puts( buf );\r\n",
"\r\n",
"        for ( i = 0; i < n_items_wc_inter_frame_heap; i++ )\r\n",
"        {\r\n",
"            index_record = list_wc_inter_frame_heap[i];\r\n",
"\r\n",
"            if ( index_record != -1 )\r\n",
"            {\r\n",
"                /* get the record */\r\n",
"                ptr_record = &( allocation_list[index_record] );\r\n",
"\r\n",
"                /* prepare information strings */\r\n",
"                strncpy( name_str, ptr_record->name, MAX_FUNCTION_NAME_LENGTH );\r\n",
"                strcat( name_str, \"()\" );\r\n",
"                name_str[MAX_FUNCTION_NAME_LENGTH] = '\\0';\r\n",
"                strncpy( parms_str, &( ptr_record->params[2] ), MAX_PARAMS_LENGTH );\r\n",
"                parms_str[MAX_PARAMS_LENGTH] = '\\0';\r\n",
"\r\n",
"                if ( ptr_record->params[0] == 'm' )\r\n",
"                {\r\n",
"                    strcpy( type_str, \"malloc\" );\r\n",
"                }\r\n",
"                else\r\n",
"                {\r\n",
"                    strcpy( type_str, \"calloc\" );\r\n",
"                }\r\n",
"\r\n",
"                sprintf( line_str, \"%d\", ptr_record->lineno );\r\n",
"\r\n",
"                /* prepare average usage & memory size strings */\r\n",
"                sprintf( usage_str, \"%d%%\", (int) ( ( (float) ptr_record->total_used_size / ( ptr_record->total_block_size + 0.1f ) ) * 100.0f + 0.5f ) );\r\n",
"\r\n",
"                if ( ptr_record->noccurances > 1 )\r\n",
"                {\r\n",
"                    sprintf( size_str, \"%dx%d %s\", ptr_record->noccurances, (int) ( ptr_record->wc_heap_size_inter_frame >> Stat_Cnt_Size ), Count_Unit[Stat_Cnt_Size] );\r\n",
"                }\r\n",
"                else\r\n",
"                {\r\n",
"                    sprintf( size_str, \"%d %s\", (int) ( ptr_record->wc_heap_size_inter_frame >> Stat_Cnt_Size ), Count_Unit[Stat_Cnt_Size] );\r\n",
"                }\r\n",
"\r\n",
"                sprintf( buf, format_str, name_str, line_str, type_str, parms_str, size_str, usage_str );\r\n",
"                puts( buf );\r\n",
"            }\r\n",
"        }\r\n",
"\r\n",
"        fprintf( stdout, \"\\n\" );\r\n",
"    }\r\n",
"\r\n",
"    return;\r\n",
"}\r\n",
"\r\n",
"#endif\r\n",
"\r\n",
"/*-------------------------------------------------------------------*\r\n",
" * print_mem()\r\n",
" *\r\n",
" * Print information about ROM and RAM memory usage\r\n",
" *--------------------------------------------------------------------*/\r\n",
"\r\n",
"void print_mem( ROM_Size_Lookup_Table Const_Data_PROM_Table[] )\r\n",
"{\r\n",
"    int i, nElem;\r\n",
"\r\n",
"    fprintf( stdout, \"\\n\\n --- Memory usage ---  \\n\\n\" );\r\n",
"\r\n",
"    if ( Const_Data_PROM_Table != NULL )\r\n",
"    {\r\n",
"        nElem = 0;\r\n",
"        while ( strcmp( Const_Data_PROM_Table[nElem].file_spec, \"\" ) != 0 )\r\n",
"            nElem++;\r\n",
"\r\n",
"        for ( i = 0; i < nElem; i++ )\r\n",
"        {\r\n",
"            if ( Stat_Cnt_Size > 0 )\r\n",
"            {\r\n",
"                /* words */\r\n",
"                fprintf( stdout, \"Program ROM size (%s): %d words\\n\", Const_Data_PROM_Table[i].file_spec, Const_Data_PROM_Table[i].PROM_size );\r\n",
"            }\r\n",
"            else\r\n",
"            {\r\n",
"                /* bytes (here, we assume that each instruction takes PROM_INST_SIZE bits of the PROM memory) */\r\n",
"                fprintf( stdout, \"Program ROM size (%s): %d bytes\\n\", Const_Data_PROM_Table[i].file_spec, Const_Data_PROM_Table[i].PROM_size * ( PROM_INST_SIZE / 8 ) );\r\n",
"            }\r\n",
"        }\r\n",
"\r\n",
"        for ( i = 0; i < nElem; i++ )\r\n",
"        {\r\n",
"            if ( Const_Data_PROM_Table[i].Get_Const_Data_Size_Func == NULL )\r\n",
"            {\r\n",
"                fprintf( stdout, \"Error: Cannot retrieve or calculate Table ROM size of (%s)!\\n\", Const_Data_PROM_Table[i].file_spec );\r\n",
"            }\r\n",
"\r\n",
"            fprintf( stdout, \"Table ROM (const data) size (%s): %d %s\\n\", Const_Data_PROM_Table[i].file_spec, Const_Data_PROM_Table[i].Get_Const_Data_Size_Func() >> Stat_Cnt_Size, Count_Unit[Stat_Cnt_Size] );\r\n",
"        }\r\n",
"    }\r\n",
"    else\r\n",
"    {\r\n",
"        fprintf( stdout, \"Program ROM size: not available\\n\" );\r\n",
"        fprintf( stdout, \"Table ROM (const data) size: not available\\n\" );\r\n",
"    }\r\n",
"\r\n",
"    if ( wc_ram_size > 0 )\r\n",
"    {\r\n",
"        fprintf( stdout, \"Maximum RAM (stack + heap) size: %d %s in frame %d\\n\", wc_ram_size >> Stat_Cnt_Size, Count_Unit[Stat_Cnt_Size], wc_ram_frame );\r\n",
"    }\r\n",
"    else\r\n",
"    {\r\n",
"        fprintf( stdout, \"Maximum RAM (stack + heap) size: not available\\n\" );\r\n",
"    }\r\n",
"\r\n",
"    /* check, if the stack is empty */\r\n",
"    if ( ptr_current_stack != ptr_base_stack )\r\n",
"    {\r\n",
"        fprintf( stderr, \"Warning: Stack is not empty.\\n\" );\r\n",
"    }\r\n",
"\r\n",
"    if ( ptr_base_stack - ptr_max_stack > 0 )\r\n",
"    {\r\n",
"        fprintf( stdout, \"Maximum stack size: %lu %s in frame %d\\n\", ( ( ptr_base_stack - ptr_max_stack ) * sizeof( int16_t ) ) >> Stat_Cnt_Size, Count_Unit[Stat_Cnt_Size],\r\n",
"                 wc_stack_frame );\r\n",
"    }\r\n",
"    else\r\n",
"    {\r\n",
"        fprintf( stdout, \"Maximum stack size: not available\\n\" );\r\n",
"    }\r\n",
"\r\n",
"    /* last update of intra-frame memory and inter-frame memory, if needed */\r\n",
"    if ( heap_allocation_call_tree_size > 0 )\r\n",
"    {\r\n",
"        update_mem();\r\n",
"    }\r\n",
"\r\n",
"    /* check, if all memory blocks have been deallocated (freed) */\r\n",
"    for ( i = 0; i < Num_Records; i++ )\r\n",
"    {\r\n",
"        if ( allocation_list[i].block_ptr != NULL )\r\n",
"        {\r\n",
"            fprintf( stderr, \"Fct=%s, Ln=%i: %s!\\n\", allocation_list[i].name, allocation_list[i].lineno, \"Error: Memory Block has not been De-Allocated with free()!\" );\r\n",
"            exit( -1 );\r\n",
"        }\r\n",
"    }\r\n",
"\r\n",
"    if ( n_items_wc_intra_frame_heap > 0 )\r\n",
"    {\r\n",
"        fprintf( stdout, \"Maximum intra-frame heap size: %d %s in frame %d\\n\", size_wc_intra_frame_heap >> Stat_Cnt_Size, Count_Unit[Stat_Cnt_Size], location_wc_intra_frame_heap );\r\n",
"    }\r\n",
"    else\r\n",
"    {\r\n",
"        fprintf( stdout, \"Maximum intra-frame heap size: 0\\n\" );\r\n",
"    }\r\n",
"\r\n",
"    if ( n_items_wc_inter_frame_heap > 0 )\r\n",
"    {\r\n",
"        fprintf( stdout, \"Maximum inter-frame heap size: %d %s in frame %d\\n\", size_wc_inter_frame_heap >> Stat_Cnt_Size, Count_Unit[Stat_Cnt_Size], location_wc_inter_frame_heap );\r\n",
"    }\r\n",
"    else\r\n",
"    {\r\n",
"        fprintf( stdout, \"Maximum inter-frame heap size: 0\\n\" );\r\n",
"    }\r\n",
"\r\n",
"#ifdef MEM_COUNT_DETAILS\r\n",
"    /* Print detailed information about worst-case stack usage */\r\n",
"    if ( ptr_base_stack - ptr_max_stack > 0 )\r\n",
"    {\r\n",
"        print_stack_call_tree();\r\n",
"    }\r\n",
"\r\n",
"    /* Print detailed information about worst-case heap usage */\r\n",
"    mem_count_summary();\r\n",
"#endif\r\n",
"\r\n",
"    if ( Stat_Cnt_Size > 0 )\r\n",
"    {\r\n",
"        /* words */\r\n",
"        fprintf( stdout, \"\\nNote: The Program ROM size is calculated under the assumption that 1 instruction word is stored with %d bits\\n\", 8 << Stat_Cnt_Size );\r\n",
"    }\r\n",
"    else\r\n",
"    {\r\n",
"        /* bytes */\r\n",
"        fprintf( stdout, \"\\nNote: The Program ROM size is calculated under the assumption that 1 instruction word is stored with %d bits\\n\", PROM_INST_SIZE );\r\n",
"    }\r\n",
"    fprintf( stdout, \"Note: The Data ROM size is calculated using the sizeof(type) built-in function\\n\" );\r\n",
"\r\n",
"    if ( n_items_wc_intra_frame_heap > 0 )\r\n",
"    {\r\n",
"        fprintf( stdout, \"Intra-frame heap memory is allocated and de-allocated in the same frame\\n\" );\r\n",
"    }\r\n",
"\r\n",
"    /* De-allocate list of heap memory blocks */\r\n",
"    if ( allocation_list != NULL )\r\n",
"    {\r\n",
"        free( allocation_list );\r\n",
"    }\r\n",
"\r\n",
"    /* De-allocate list of stack records */\r\n",
"    if ( stack_callers[0] != NULL )\r\n",
"    {\r\n",
"        free( stack_callers[0] );\r\n",
"    }\r\n",
"\r\n",
"    if ( stack_callers[1] != NULL )\r\n",
"    {\r\n",
"        free( stack_callers[1] );\r\n",
"    }\r\n",
"\r\n",
"    /* De-allocate heap allocation call tree */\r\n",
"    if ( heap_allocation_call_tree != NULL )\r\n",
"    {\r\n",
"        free( heap_allocation_call_tree );\r\n",
"    }\r\n",
"\r\n",
"    /* De-allocate intra-frame and inter-frame heap lists */\r\n",
"    if ( list_wc_intra_frame_heap != NULL )\r\n",
"    {\r\n",
"        free( list_wc_intra_frame_heap );\r\n",
"    }\r\n",
"\r\n",
"    if ( list_current_inter_frame_heap != NULL )\r\n",
"    {\r\n",
"        free( list_current_inter_frame_heap );\r\n",
"    }\r\n",
"\r\n",
"    if ( list_wc_inter_frame_heap != NULL )\r\n",
"    {\r\n",
"        free( list_wc_inter_frame_heap );\r\n",
"    }\r\n",
"\r\n",
"#ifdef MEM_COUNT_DETAILS\r\n",
"    if ( fid_csv_filename != NULL )\r\n",
"    {\r\n",
"        fclose( fid_csv_filename );\r\n",
"    }\r\n",
"#endif\r\n",
"\r\n",
"    return;\r\n",
"}\r\n",
"\r\n",
"#endif /* WMOPS */\r\n",
"\r\n",
"#ifndef WMOPS\r\n",
"int cntr_push_pop = 0; /* global counter for checking balanced push_wmops()/pop_wmops() pairs when WMOPS is not activated */\r\n",
"#endif\r\n",
"\r\n",
"#ifdef WMOPS\r\n",
"/* Global counter for the calculation of BASOP complexity */\r\n",
"BASIC_OP *multiCounter = NULL;\r\n",
"int currCounter = 0;\r\n",
"int funcId_where_last_call_to_else_occurred;\r\n",
"long funcid_total_wmops_at_last_call_to_else;\r\n",
"int call_occurred = 1;\r\n",
"\r\n",
"BASIC_OP op_weight = {\r\n",
"    1, 1, 1, 1, 1,\r\n",
"    1, 1, 1, 1, 1,\r\n",
"    1, 1, 1, 1, 1,\r\n",
"    1, 1, 2, 2, 1,\r\n",
"    1, 1, 1, 3, 1,\r\n",
"\r\n",
"    1, 1, 1, 3, 1,\r\n",
"    4, 1, 18, 1, 1,\r\n",
"    2, 1, 2, 2, 1,\r\n",
"    1, 1, 1, 1, 1,\r\n",
"    3, 3, 3, 3, 1,\r\n",
"\r\n",
"    1, 1, 1, 1, 1,\r\n",
"    1, 1, 1, 2,\r\n",
"    1, 2, 2, 4, 1,\r\n",
"    1, 1, 1, 1, 1,\r\n",
"    1, 1, 1, 1, 1,\r\n",
"\r\n",
"    1, 1, 1, 1, 3,\r\n",
"    3, 3, 3, 3, 1,\r\n",
"    1, 1, 1, 1, 1,\r\n",
"    1, 1, 1, 4, 4,\r\n",
"    4, 8, 3, 4, 4,\r\n",
"\r\n",
"    5, 32, 3\r\n",
"};\r\n",
"\r\n",
"/* Set the counter group to use, default is zero */\r\n",
"void Set_BASOP_WMOPS_counter( int counterId )\r\n",
"{\r\n",
"    if ( ( counterId > num_wmops_records ) || ( counterId < 0 ) )\r\n",
"    {\r\n",
"        currCounter = 0;\r\n",
"        return;\r\n",
"    }\r\n",
"    currCounter = counterId;\r\n",
"    call_occurred = 1;\r\n",
"}\r\n",
"\r\n",
"extern int32_t frame;\r\n",
"\r\n",
"long TotalWeightedOperation()\r\n",
"{\r\n",
"    int i;\r\n",
"    unsigned int *ptr, *ptr2;\r\n",
"    long tot; \r\n",
"\r\n",
"    tot = 0;\r\n",
"    ptr = (unsigned int *) &multiCounter[currCounter];\r\n",
"    ptr2 = (unsigned int *) &op_weight;\r\n",
"\r\n",
"    for ( i = 0; i < ( int )( sizeof( multiCounter[currCounter] ) / sizeof( unsigned int ) ); i++ )\r\n",
"    {\r\n",
"        tot += ( ( *ptr++ ) * ( *ptr2++ ) );\r\n",
"    }\r\n",
"\r\n",
"    return ( tot );\r\n",
"}\r\n",
"\r\n",
"long DeltaWeightedOperation( void )\r\n",
"{\r\n",
"    long NewWOper, delta;\r\n",
"\r\n",
"    NewWOper = TotalWeightedOperation();\r\n",
"\r\n",
"    delta = NewWOper - wmops[currCounter].LastWOper;\r\n",
"    wmops[currCounter].LastWOper = NewWOper;\r\n",
"\r\n",
"    return ( delta );\r\n",
"}\r\n",
"\r\n",
"/* Resets the current BASOP WMOPS counter */\r\n",
"void Reset_BASOP_WMOPS_counter( void )\r\n",
"{\r\n",
"    int i;\r\n",
"    long *ptr;\r\n",
"\r\n",
"    /* clear the current BASOP operation counter before new frame begins */\r\n",
"    ptr = (long *) &multiCounter[currCounter];\r\n",
"    for ( i = 0; i < (int) ( sizeof( multiCounter[currCounter] ) / sizeof( long ) ); i++ )\r\n",
"    {\r\n",
"        *ptr++ = 0;\r\n",
"    }\r\n",
"\r\n",
"    wmops[currCounter].LastWOper = 0;\r\n",
"\r\n",
"    return;\r\n",
"}\r\n",
"\r\n",
"#endif\r\n",
"\r\n",
"\r\n",
"\r\n",