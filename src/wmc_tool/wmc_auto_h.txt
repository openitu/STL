"/*\r\n",
" * (C) 2023 copyright VoiceAge Corporation. All Rights Reserved.\r\n",
" *\r\n",
" * This software is protected by copyright law and by international treaties. The source code, and all of its derivations,\r\n",
" * is provided by VoiceAge Corporation under the \"ITU-T Software Tools' General Public License\". Please, read the license file\r\n",
" * or refer to ITU-T Recommendation G.191 on \"SOFTWARE TOOLS FOR SPEECH AND AUDIO CODING STANDARDS\".\r\n",
" *\r\n",
" * Any use of this software is permitted provided that this notice is not removed and that neither the authors nor\r\n",
" * VoiceAge Corporation are deemed to have made any representations as to the suitability of this software\r\n",
" * for any purpose nor are held responsible for any defects of this software. THERE IS NO WARRANTY FOR THIS SOFTWARE.\r\n",
" *\r\n",
" * Authors: Guy Richard, Vladimir Malenovsky (Vladimir.Malenovsky@USherbrooke.ca)\r\n",
" */\r\n",
"\r\n",
"#ifndef WMOPS_H\r\n",
"#define WMOPS_H\r\n",
"\r\n",
"#ifndef EXIT_FAILURE\r\n",
"#include <stdlib.h> /* stdlib is needed for exit() */\r\n",
"#endif\r\n",
"\r\n",
"#ifndef EOF\r\n",
"#include <stdio.h> /* stdio is needed for fprintf() */\r\n",
"#endif\r\n",
"\r\n",
"\r\n",
"/* To Prevent \"warning: '$' in identifier or number\" message under GCC */\r\n",
"#ifdef __GNUC__\r\n",
"#pragma GCC system_header\r\n",
"#endif\r\n",
"\r\n",
"#ifndef INT_MAX\r\n",
"#define INT_MAX 32767\r\n",
"#endif\r\n",
"\r\n",
"#define FRAMES_PER_SECOND 50.0    \r\n",
"#define PROM_INST_SIZE    32     /* number of bits of each program instruction when stored in the PROM memory (applied only when the user selects reporting in bytes) */\r\n",
"\r\n",
"#ifdef WMOPS\r\n",
"enum instructions\r\n",
"{\r\n",
"    _ADD,\r\n",
"    _ABS,\r\n",
"    _MULT,\r\n",
"    _MAC,\r\n",
"    _MOVE,\r\n",
"    _STORE,\r\n",
"    _LOGIC,\r\n",
"    _SHIFT,\r\n",
"    _BRANCH,\r\n",
"    _DIV,\r\n",
"    _SQRT,\r\n",
"    _TRANS,\r\n",
"    _FUNC,\r\n",
"    _LOOP,\r\n",
"    _INDIRECT,\r\n",
"    _PTR_INIT,\r\n",
"    _TEST,\r\n",
"    _POWER,\r\n",
"    _LOG,\r\n",
"    _MISC,\r\n",
"    NUM_INST\r\n",
"};\r\n",
"\r\n",
"#define _ADD_C      1\r\n",
"#define _ABS_C      1\r\n",
"#define _MULT_C     1\r\n",
"#define _MAC_C      1\r\n",
"#define _MOVE_C     1\r\n",
"#define _STORE_C    1\r\n",
"#define _LOGIC_C    1\r\n",
"#define _SHIFT_C    1\r\n",
"#define _BRANCH_C   4\r\n",
"#define _DIV_C      18\r\n",
"#define _SQRT_C     10\r\n",
"#define _TRANS_C    25\r\n",
"#define _FUNC_C     2 /* need to add number of arguments */\r\n",
"#define _LOOP_C     3\r\n",
"#define _INDIRECT_C 2\r\n",
"#define _PTR_INIT_C 1\r\n",
"#define _TEST_C     2\r\n",
"#define _POWER_C    25\r\n",
"#define _LOG_C      25\r\n",
"#define _MISC_C     1\r\n",
"\r\n",
"#define _ADD_P      1\r\n",
"#define _ABS_P      1\r\n",
"#define _MULT_P     1\r\n",
"#define _MAC_P      1\r\n",
"#define _MOVE_P     1\r\n",
"#define _STORE_P    0\r\n",
"#define _LOGIC_P    1\r\n",
"#define _SHIFT_P    1\r\n",
"#define _BRANCH_P   2\r\n",
"#define _DIV_P      2\r\n",
"#define _SQRT_P     2\r\n",
"#define _TRANS_P    2\r\n",
"#define _FUNC_P     2 /* need to add number of arguments */\r\n",
"#define _LOOP_P     1\r\n",
"#define _INDIRECT_P 2\r\n",
"#define _PTR_INIT_P 1\r\n",
"#define _TEST_P     1\r\n",
"#define _POWER_P    2\r\n",
"#define _LOG_P      2\r\n",
"#define _MISC_P     1\r\n",
"\r\n",
"#define ADD( x )                                    \\\r\n",
"    {                                               \\\r\n",
"        {                                           \\\r\n",
"            ops_cnt += ( _ADD_C * ( x ) );          \\\r\n",
"            inst_cnt[_ADD] += ( x );                \\\r\n",
"            {                                       \\\r\n",
"                static int pcnt;                    \\\r\n",
"                if ( !pcnt )                        \\\r\n",
"                {                                   \\\r\n",
"                    pcnt = 1;                       \\\r\n",
"                    prom_cnt += ( _ADD_P * ( x ) ); \\\r\n",
"                }                                   \\\r\n",
"            }                                       \\\r\n",
"        }                                           \\\r\n",
"    }\r\n",
"#define ABS( x )                                    \\\r\n",
"    {                                               \\\r\n",
"        {                                           \\\r\n",
"            ops_cnt += ( _ABS_C * ( x ) );          \\\r\n",
"            inst_cnt[_ABS] += ( x );                \\\r\n",
"            {                                       \\\r\n",
"                static int pcnt;                    \\\r\n",
"                if ( !pcnt )                        \\\r\n",
"                {                                   \\\r\n",
"                    pcnt = 1;                       \\\r\n",
"                    prom_cnt += ( _ABS_P * ( x ) ); \\\r\n",
"                }                                   \\\r\n",
"            }                                       \\\r\n",
"        }                                           \\\r\n",
"    }\r\n",
"#define MULT( x )                                    \\\r\n",
"    {                                                \\\r\n",
"        {                                            \\\r\n",
"            ops_cnt += ( _MULT_C * ( x ) );          \\\r\n",
"            inst_cnt[_MULT] += ( x );                \\\r\n",
"            {                                        \\\r\n",
"                static int pcnt;                     \\\r\n",
"                if ( !pcnt )                         \\\r\n",
"                {                                    \\\r\n",
"                    pcnt = 1;                        \\\r\n",
"                    prom_cnt += ( _MULT_P * ( x ) ); \\\r\n",
"                }                                    \\\r\n",
"            }                                        \\\r\n",
"        }                                            \\\r\n",
"    }\r\n",
"#define MAC( x )                                    \\\r\n",
"    {                                               \\\r\n",
"        {                                           \\\r\n",
"            ops_cnt += ( _MAC_C * ( x ) );          \\\r\n",
"            inst_cnt[_MAC] += ( x );                \\\r\n",
"            {                                       \\\r\n",
"                static int pcnt;                    \\\r\n",
"                if ( !pcnt )                        \\\r\n",
"                {                                   \\\r\n",
"                    pcnt = 1;                       \\\r\n",
"                    prom_cnt += ( _MAC_P * ( x ) ); \\\r\n",
"                }                                   \\\r\n",
"            }                                       \\\r\n",
"        }                                           \\\r\n",
"    }\r\n",
"#define MOVE( x )                                    \\\r\n",
"    {                                                \\\r\n",
"        {                                            \\\r\n",
"            ops_cnt += ( _MOVE_C * ( x ) );          \\\r\n",
"            inst_cnt[_MOVE] += ( x );                \\\r\n",
"            {                                        \\\r\n",
"                static int pcnt;                     \\\r\n",
"                if ( !pcnt )                         \\\r\n",
"                {                                    \\\r\n",
"                    pcnt = 1;                        \\\r\n",
"                    prom_cnt += ( _MOVE_P * ( x ) ); \\\r\n",
"                }                                    \\\r\n",
"            }                                        \\\r\n",
"        }                                            \\\r\n",
"    }\r\n",
"#define STORE( x )                                    \\\r\n",
"    {                                                 \\\r\n",
"        {                                             \\\r\n",
"            ops_cnt += ( _STORE_C * ( x ) );          \\\r\n",
"            inst_cnt[_STORE] += ( x );                \\\r\n",
"            {                                         \\\r\n",
"                static int pcnt;                      \\\r\n",
"                if ( !pcnt )                          \\\r\n",
"                {                                     \\\r\n",
"                    pcnt = 1;                         \\\r\n",
"                    prom_cnt += ( _STORE_P * ( x ) ); \\\r\n",
"                }                                     \\\r\n",
"            }                                         \\\r\n",
"        }                                             \\\r\n",
"    }\r\n",
"#define LOGIC( x )                                    \\\r\n",
"    {                                                 \\\r\n",
"        {                                             \\\r\n",
"            ops_cnt += ( _LOGIC_C * ( x ) );          \\\r\n",
"            inst_cnt[_LOGIC] += ( x );                \\\r\n",
"            {                                         \\\r\n",
"                static int pcnt;                      \\\r\n",
"                if ( !pcnt )                          \\\r\n",
"                {                                     \\\r\n",
"                    pcnt = 1;                         \\\r\n",
"                    prom_cnt += ( _LOGIC_P * ( x ) ); \\\r\n",
"                }                                     \\\r\n",
"            }                                         \\\r\n",
"        }                                             \\\r\n",
"    }\r\n",
"#define SHIFT( x )                                    \\\r\n",
"    {                                                 \\\r\n",
"        {                                             \\\r\n",
"            ops_cnt += ( _SHIFT_C * ( x ) );          \\\r\n",
"            inst_cnt[_SHIFT] += ( x );                \\\r\n",
"            {                                         \\\r\n",
"                static int pcnt;                      \\\r\n",
"                if ( !pcnt )                          \\\r\n",
"                {                                     \\\r\n",
"                    pcnt = 1;                         \\\r\n",
"                    prom_cnt += ( _SHIFT_P * ( x ) ); \\\r\n",
"                }                                     \\\r\n",
"            }                                         \\\r\n",
"        }                                             \\\r\n",
"    }\r\n",
"#define BRANCH( x )                                    \\\r\n",
"    {                                                  \\\r\n",
"        {                                              \\\r\n",
"            ops_cnt += ( _BRANCH_C * ( x ) );          \\\r\n",
"            inst_cnt[_BRANCH] += ( x );                \\\r\n",
"            {                                          \\\r\n",
"                static int pcnt;                       \\\r\n",
"                if ( !pcnt )                           \\\r\n",
"                {                                      \\\r\n",
"                    pcnt = 1;                          \\\r\n",
"                    prom_cnt += ( _BRANCH_P * ( x ) ); \\\r\n",
"                }                                      \\\r\n",
"            }                                          \\\r\n",
"        }                                              \\\r\n",
"    }\r\n",
"#define DIV( x )                                    \\\r\n",
"    {                                               \\\r\n",
"        {                                           \\\r\n",
"            ops_cnt += ( _DIV_C * ( x ) );          \\\r\n",
"            inst_cnt[_DIV] += ( x );                \\\r\n",
"            {                                       \\\r\n",
"                static int pcnt;                    \\\r\n",
"                if ( !pcnt )                        \\\r\n",
"                {                                   \\\r\n",
"                    pcnt = 1;                       \\\r\n",
"                    prom_cnt += ( _DIV_P * ( x ) ); \\\r\n",
"                }                                   \\\r\n",
"            }                                       \\\r\n",
"        }                                           \\\r\n",
"    }\r\n",
"#define SQRT( x )                                    \\\r\n",
"    {                                                \\\r\n",
"        {                                            \\\r\n",
"            ops_cnt += ( _SQRT_C * ( x ) );          \\\r\n",
"            inst_cnt[_SQRT] += ( x );                \\\r\n",
"            {                                        \\\r\n",
"                static int pcnt;                     \\\r\n",
"                if ( !pcnt )                         \\\r\n",
"                {                                    \\\r\n",
"                    pcnt = 1;                        \\\r\n",
"                    prom_cnt += ( _SQRT_P * ( x ) ); \\\r\n",
"                }                                    \\\r\n",
"            }                                        \\\r\n",
"        }                                            \\\r\n",
"    }\r\n",
"#define TRANS( x )                                    \\\r\n",
"    {                                                 \\\r\n",
"        {                                             \\\r\n",
"            ops_cnt += ( _TRANS_C * ( x ) );          \\\r\n",
"            inst_cnt[_TRANS] += ( x );                \\\r\n",
"            {                                         \\\r\n",
"                static int pcnt;                      \\\r\n",
"                if ( !pcnt )                          \\\r\n",
"                {                                     \\\r\n",
"                    pcnt = 1;                         \\\r\n",
"                    prom_cnt += ( _TRANS_P * ( x ) ); \\\r\n",
"                }                                     \\\r\n",
"            }                                         \\\r\n",
"        }                                             \\\r\n",
"    }\r\n",
"#define LOOP( x )                                    \\\r\n",
"    {                                                \\\r\n",
"        {                                            \\\r\n",
"            ops_cnt += ( _LOOP_C * ( x ) );          \\\r\n",
"            inst_cnt[_LOOP] += ( x );                \\\r\n",
"            {                                        \\\r\n",
"                static int pcnt;                     \\\r\n",
"                if ( !pcnt )                         \\\r\n",
"                {                                    \\\r\n",
"                    pcnt = 1;                        \\\r\n",
"                    prom_cnt += ( _LOOP_P * ( x ) ); \\\r\n",
"                }                                    \\\r\n",
"            }                                        \\\r\n",
"        }                                            \\\r\n",
"    }\r\n",
"#define INDIRECT( x )                                    \\\r\n",
"    {                                                    \\\r\n",
"        {                                                \\\r\n",
"            ops_cnt += ( _INDIRECT_C * ( x ) );          \\\r\n",
"            inst_cnt[_INDIRECT] += ( x );                \\\r\n",
"            {                                            \\\r\n",
"                static int pcnt;                         \\\r\n",
"                if ( !pcnt )                             \\\r\n",
"                {                                        \\\r\n",
"                    pcnt = 1;                            \\\r\n",
"                    prom_cnt += ( _INDIRECT_P * ( x ) ); \\\r\n",
"                }                                        \\\r\n",
"            }                                            \\\r\n",
"        }                                                \\\r\n",
"    }\r\n",
"#define PTR_INIT( x )                                    \\\r\n",
"    {                                                    \\\r\n",
"        {                                                \\\r\n",
"            ops_cnt += ( _PTR_INIT_C * ( x ) );          \\\r\n",
"            inst_cnt[_PTR_INIT] += ( x );                \\\r\n",
"            {                                            \\\r\n",
"                static int pcnt;                         \\\r\n",
"                if ( !pcnt )                             \\\r\n",
"                {                                        \\\r\n",
"                    pcnt = 1;                            \\\r\n",
"                    prom_cnt += ( _PTR_INIT_P * ( x ) ); \\\r\n",
"                }                                        \\\r\n",
"            }                                            \\\r\n",
"        }                                                \\\r\n",
"    }\r\n",
"#define TEST( x )                                    \\\r\n",
"    {                                                \\\r\n",
"        {                                            \\\r\n",
"            ops_cnt += ( _TEST_C * ( x ) );          \\\r\n",
"            inst_cnt[_TEST] += ( x );                \\\r\n",
"            {                                        \\\r\n",
"                static int pcnt;                     \\\r\n",
"                if ( !pcnt )                         \\\r\n",
"                {                                    \\\r\n",
"                    pcnt = 1;                        \\\r\n",
"                    prom_cnt += ( _TEST_P * ( x ) ); \\\r\n",
"                }                                    \\\r\n",
"            }                                        \\\r\n",
"        }                                            \\\r\n",
"    }\r\n",
"#define POWER( x )                                    \\\r\n",
"    {                                                 \\\r\n",
"        {                                             \\\r\n",
"            ops_cnt += ( _POWER_C * ( x ) );          \\\r\n",
"            inst_cnt[_POWER] += ( x );                \\\r\n",
"            {                                         \\\r\n",
"                static int pcnt;                      \\\r\n",
"                if ( !pcnt )                          \\\r\n",
"                {                                     \\\r\n",
"                    pcnt = 1;                         \\\r\n",
"                    prom_cnt += ( _POWER_P * ( x ) ); \\\r\n",
"                }                                     \\\r\n",
"            }                                         \\\r\n",
"        }                                             \\\r\n",
"    }\r\n",
"#define LOG( x )                                    \\\r\n",
"    {                                               \\\r\n",
"        {                                           \\\r\n",
"            ops_cnt += ( _LOG_C * ( x ) );          \\\r\n",
"            inst_cnt[_LOG] += ( x );                \\\r\n",
"            {                                       \\\r\n",
"                static int pcnt;                    \\\r\n",
"                if ( !pcnt )                        \\\r\n",
"                {                                   \\\r\n",
"                    pcnt = 1;                       \\\r\n",
"                    prom_cnt += ( _LOG_P * ( x ) ); \\\r\n",
"                }                                   \\\r\n",
"            }                                       \\\r\n",
"        }                                           \\\r\n",
"    }\r\n",
"#define MISC( x )                                    \\\r\n",
"    {                                                \\\r\n",
"        {                                            \\\r\n",
"            ops_cnt += ( _MISC_C * ( x ) );          \\\r\n",
"            inst_cnt[_MISC] += ( x );                \\\r\n",
"            {                                        \\\r\n",
"                static int pcnt;                     \\\r\n",
"                if ( !pcnt )                         \\\r\n",
"                {                                    \\\r\n",
"                    pcnt = 1;                        \\\r\n",
"                    prom_cnt += ( _MISC_P * ( x ) ); \\\r\n",
"                }                                    \\\r\n",
"            }                                        \\\r\n",
"        }                                            \\\r\n",
"    }\r\n",
"\r\n",
"#define FUNC( x )                                              \\\r\n",
"    {                                                          \\\r\n",
"        {                                                      \\\r\n",
"            ops_cnt += ( _FUNC_C + _MOVE_C * ( x ) );          \\\r\n",
"            inst_cnt[_FUNC]++;                                 \\\r\n",
"            inst_cnt[_MOVE] += ( x );                          \\\r\n",
"            {                                                  \\\r\n",
"                static int pcnt;                               \\\r\n",
"                if ( !pcnt )                                   \\\r\n",
"                {                                              \\\r\n",
"                    pcnt = 1;                                  \\\r\n",
"                    prom_cnt += ( _FUNC_P + _MOVE_P * ( x ) ); \\\r\n",
"                }                                              \\\r\n",
"            }                                                  \\\r\n",
"        }                                                      \\\r\n",
"    }\r\n",
"\r\n",
"#define DADD( x )                                   \\\r\n",
"    {                                               \\\r\n",
"        {                                           \\\r\n",
"            ops_cnt += ( 2 * _ADD_C * ( x ) );      \\\r\n",
"            inst_cnt[_ADD] += ( x );                \\\r\n",
"            {                                       \\\r\n",
"                static int pcnt;                    \\\r\n",
"                if ( !pcnt )                        \\\r\n",
"                {                                   \\\r\n",
"                    pcnt = 1;                       \\\r\n",
"                    prom_cnt += ( _ADD_P * ( x ) ); \\\r\n",
"                }                                   \\\r\n",
"            }                                       \\\r\n",
"        }                                           \\\r\n",
"    }\r\n",
"#define DMULT( x )                                   \\\r\n",
"    {                                                \\\r\n",
"        {                                            \\\r\n",
"            ops_cnt += ( 2 * _MULT_C * ( x ) );      \\\r\n",
"            inst_cnt[_MULT] += ( x );                \\\r\n",
"            {                                        \\\r\n",
"                static int pcnt;                     \\\r\n",
"                if ( !pcnt )                         \\\r\n",
"                {                                    \\\r\n",
"                    pcnt = 1;                        \\\r\n",
"                    prom_cnt += ( _MULT_P * ( x ) ); \\\r\n",
"                }                                    \\\r\n",
"            }                                        \\\r\n",
"        }                                            \\\r\n",
"    }\r\n",
"#define DMAC( x )                                   \\\r\n",
"    {                                               \\\r\n",
"        {                                           \\\r\n",
"            ops_cnt += ( 2 * _MAC_C * ( x ) );      \\\r\n",
"            inst_cnt[_MAC] += ( x );                \\\r\n",
"            {                                       \\\r\n",
"                static int pcnt;                    \\\r\n",
"                if ( !pcnt )                        \\\r\n",
"                {                                   \\\r\n",
"                    pcnt = 1;                       \\\r\n",
"                    prom_cnt += ( _MAC_P * ( x ) ); \\\r\n",
"                }                                   \\\r\n",
"            }                                       \\\r\n",
"        }                                           \\\r\n",
"    }\r\n",
"#define DMOVE( x )                                   \\\r\n",
"    {                                                \\\r\n",
"        {                                            \\\r\n",
"            ops_cnt += ( 2 * _MOVE_C * ( x ) );      \\\r\n",
"            inst_cnt[_MOVE] += ( x );                \\\r\n",
"            {                                        \\\r\n",
"                static int pcnt;                     \\\r\n",
"                if ( !pcnt )                         \\\r\n",
"                {                                    \\\r\n",
"                    pcnt = 1;                        \\\r\n",
"                    prom_cnt += ( _MOVE_P * ( x ) ); \\\r\n",
"                }                                    \\\r\n",
"            }                                        \\\r\n",
"        }                                            \\\r\n",
"    }\r\n",
"#define DSTORE( x )                                   \\\r\n",
"    {                                                 \\\r\n",
"        {                                             \\\r\n",
"            ops_cnt += ( 2 * _STORE_C * ( x ) );      \\\r\n",
"            inst_cnt[_STORE] += ( x );                \\\r\n",
"            {                                         \\\r\n",
"                static int pcnt;                      \\\r\n",
"                if ( !pcnt )                          \\\r\n",
"                {                                     \\\r\n",
"                    pcnt = 1;                         \\\r\n",
"                    prom_cnt += ( _STORE_P * ( x ) ); \\\r\n",
"                }                                     \\\r\n",
"            }                                         \\\r\n",
"        }                                             \\\r\n",
"    }\r\n",
"#define DLOGIC( x )                                   \\\r\n",
"    {                                                 \\\r\n",
"        {                                             \\\r\n",
"            ops_cnt += ( 2 * _LOGIC_C * ( x ) );      \\\r\n",
"            inst_cnt[_LOGIC] += ( x );                \\\r\n",
"            {                                         \\\r\n",
"                static int pcnt;                      \\\r\n",
"                if ( !pcnt )                          \\\r\n",
"                {                                     \\\r\n",
"                    pcnt = 1;                         \\\r\n",
"                    prom_cnt += ( _LOGIC_P * ( x ) ); \\\r\n",
"                }                                     \\\r\n",
"            }                                         \\\r\n",
"        }                                             \\\r\n",
"    }\r\n",
"#define DSHIFT( x )                                   \\\r\n",
"    {                                                 \\\r\n",
"        {                                             \\\r\n",
"            ops_cnt += ( 2 * _SHIFT_C * ( x ) );      \\\r\n",
"            inst_cnt[_SHIFT] += ( x );                \\\r\n",
"            {                                         \\\r\n",
"                static int pcnt;                      \\\r\n",
"                if ( !pcnt )                          \\\r\n",
"                {                                     \\\r\n",
"                    pcnt = 1;                         \\\r\n",
"                    prom_cnt += ( _SHIFT_P * ( x ) ); \\\r\n",
"                }                                     \\\r\n",
"            }                                         \\\r\n",
"        }                                             \\\r\n",
"    }\r\n",
"#define DDIV( x )                                   \\\r\n",
"    {                                               \\\r\n",
"        {                                           \\\r\n",
"            ops_cnt += ( 2 * _DIV_C * ( x ) );      \\\r\n",
"            inst_cnt[_DIV] += ( x );                \\\r\n",
"            {                                       \\\r\n",
"                static int pcnt;                    \\\r\n",
"                if ( !pcnt )                        \\\r\n",
"                {                                   \\\r\n",
"                    pcnt = 1;                       \\\r\n",
"                    prom_cnt += ( _DIV_P * ( x ) ); \\\r\n",
"                }                                   \\\r\n",
"            }                                       \\\r\n",
"        }                                           \\\r\n",
"    }\r\n",
"#define DSQRT( x )                                   \\\r\n",
"    {                                                \\\r\n",
"        {                                            \\\r\n",
"            ops_cnt += ( 2 * _SQRT_C * ( x ) );      \\\r\n",
"            inst_cnt[_SQRT] += ( x );                \\\r\n",
"            {                                        \\\r\n",
"                static int pcnt;                     \\\r\n",
"                if ( !pcnt )                         \\\r\n",
"                {                                    \\\r\n",
"                    pcnt = 1;                        \\\r\n",
"                    prom_cnt += ( _SQRT_P * ( x ) ); \\\r\n",
"                }                                    \\\r\n",
"            }                                        \\\r\n",
"        }                                            \\\r\n",
"    }\r\n",
"#define DTRANS( x )                                   \\\r\n",
"    {                                                 \\\r\n",
"        {                                             \\\r\n",
"            ops_cnt += ( 2 * _TRANS_C * ( x ) );      \\\r\n",
"            inst_cnt[_TRANS] += ( x );                \\\r\n",
"            {                                         \\\r\n",
"                static int pcnt;                      \\\r\n",
"                if ( !pcnt )                          \\\r\n",
"                {                                     \\\r\n",
"                    pcnt = 1;                         \\\r\n",
"                    prom_cnt += ( _TRANS_P * ( x ) ); \\\r\n",
"                }                                     \\\r\n",
"            }                                         \\\r\n",
"        }                                             \\\r\n",
"    }\r\n",
"\r\n",
"extern double ops_cnt;\r\n",
"extern double prom_cnt;\r\n",
"extern double inst_cnt[NUM_INST];\r\n",
"\r\n",
"void reset_wmops( void );\r\n",
"void push_wmops( const char *label );\r\n",
"void pop_wmops( void );\r\n",
"void update_wmops( void );\r\n",
"void update_mem( void );\r\n",
"void print_wmops( void );\r\n",
"\r\n",
"#else /* WMOPS counting disabled */\r\n",
"\r\n",
"#define reset_wmops()\r\n",
"extern int cntr_push_pop;\r\n",
"#define push_wmops( x ) ( cntr_push_pop++ )\r\n",
"#define pop_wmops()     ( cntr_push_pop-- )\r\n",
"#define update_wmops()  ( assert( cntr_push_pop == 0 ) )\r\n",
"#define update_mem()\r\n",
"#define print_wmops()\r\n",
"\r\n",
"#define ADD( x )\r\n",
"#define ABS( x )\r\n",
"#define MULT( x )\r\n",
"#define MAC( x )\r\n",
"#define MOVE( x )\r\n",
"#define STORE( x )\r\n",
"#define LOGIC( x )\r\n",
"#define SHIFT( x )\r\n",
"#define BRANCH( x )\r\n",
"#define DIV( x )\r\n",
"#define SQRT( x )\r\n",
"#define TRANS( x )\r\n",
"#define FUNC( x )\r\n",
"#define LOOP( x )\r\n",
"#define INDIRECT( x )\r\n",
"#define PTR_INIT( x )\r\n",
"#define TEST( x )\r\n",
"#define POWER( x )\r\n",
"#define LOG( x )\r\n",
"#define MISC( x )\r\n",
"\r\n",
"#define DADD( x )\r\n",
"#define DMULT( x )\r\n",
"#define DMAC( x )\r\n",
"#define DMOVE( x )\r\n",
"#define DSTORE( x )\r\n",
"#define DLOGIC( x )\r\n",
"#define DSHIFT( x )\r\n",
"#define DDIV( x )\r\n",
"#define DSQRT( x )\r\n",
"#define DTRANS( x )\r\n",
"\r\n",
"#endif\r\n",
"\r\n",
"#ifndef WMOPS\r\n",
"/* DESACTIVATE the Counting Mechanism */\r\n",
"#define OP_COUNT_( op, n )\r\n",
"\r\n",
"/* DESACTIVATE Operation Counter Wrappers */\r\n",
"#define OP_COUNT_WRAPPER1_( op, val ) ( val )\r\n",
"#define OP_COUNT_WRAPPER2_( expr )\r\n",
"#define OP_COUNT_WRAPPER3_( op, expr ) expr\r\n",
"\r\n",
"/* DESACTIVATE Logical & Ternary Operators */\r\n",
"#define __\r\n",
"#define _\r\n",
"\r\n",
"#else\r\n",
"\r\n",
"/* '*ops_cnt_ptr' is Used to Avoid: \"warning: operation on 'ops_cnt' may be undefined\" with Cygwin gcc Compiler */\r\n",
"static double *ops_cnt_ptr = &ops_cnt;\r\n",
"#define OP_COUNT_( op, x )            ( *ops_cnt_ptr += ( op##_C * ( x ) ), inst_cnt[op] += ( x ) )\r\n",
"\r\n",
"/******************************************************************/\r\n",
"/* NOTES:                                                         */\r\n",
"/*   The 'wmc_flag_' flag is global to avoid declaration in every */\r\n",
"/*   function and 'static' to avoid clashing with other modules   */\r\n",
"/*   that include this header file.                               */\r\n",
"/*                                                                */\r\n",
"/*   The declarations of 'wmc_flag_' and 'wops_' in this header   */\r\n",
"/*   file prevent the addition of a 'C' file to the Project.      */\r\n",
"/******************************************************************/\r\n",
"\r\n",
"/* General Purpose Global Flag */\r\n",
"static int wmc_flag_ = 0;\r\n",
"\r\n",
"/* Operation Counter Wrappers */\r\n",
"#define OP_COUNT_WRAPPER1_( op, val ) ( op, val )\r\n",
"#define OP_COUNT_WRAPPER2_( expr ) \\\r\n",
"    if ( expr, 0 )                 \\\r\n",
"        ;                          \\\r\n",
"    else\r\n",
"#define OP_COUNT_WRAPPER3_( op, expr ) \\\r\n",
"    if ( op, 0 )                       \\\r\n",
"        ;                              \\\r\n",
"    else                               \\\r\n",
"        expr\r\n",
"\r\n",
"#endif\r\n",
"\r\n",
"/* Define all Macros without '{' & '}' (None of these should be called externally!) */\r\n",
"#define ABS_( x )      OP_COUNT_( _ABS, ( x ) )\r\n",
"#define ADD_( x )      OP_COUNT_( _ADD, ( x ) )\r\n",
"#define MULT_( x )     OP_COUNT_( _MULT, ( x ) )\r\n",
"#define MAC_( x )      OP_COUNT_( _MAC, ( x ) )\r\n",
"#define MOVE_( x )     OP_COUNT_( _MOVE, ( x ) )\r\n",
"#define STORE_( x )    OP_COUNT_( _STORE, ( x ) )\r\n",
"#define LOGIC_( x )    OP_COUNT_( _LOGIC, ( x ) )\r\n",
"#define SHIFT_( x )    OP_COUNT_( _SHIFT, ( x ) )\r\n",
"#define BRANCH_( x )   OP_COUNT_( _BRANCH, ( x ) )\r\n",
"#define DIV_( x )      OP_COUNT_( _DIV, ( x ) )\r\n",
"#define SQRT_( x )     OP_COUNT_( _SQRT, ( x ) )\r\n",
"#define TRANS_( x )    OP_COUNT_( _TRANS, ( x ) )\r\n",
"#define POWER_( x )    TRANS_( x )\r\n",
"#define LOG_( x )      TRANS_( x )\r\n",
"#define LOOP_( x )     OP_COUNT_( _LOOP, ( x ) )\r\n",
"#define INDIRECT_( x ) OP_COUNT_( _INDIRECT, ( x ) )\r\n",
"#define PTR_INIT_( x ) OP_COUNT_( _PTR_INIT, ( x ) )\r\n",
"#define FUNC_( x )     ( OP_COUNT_( _MOVE, ( x ) ), OP_COUNT_( _FUNC, 1 ) )\r\n",
"#define MISC_( x )     ABS_( x )\r\n",
"\r\n",
"/* Math Operations */\r\n",
"#define abs_    OP_COUNT_WRAPPER1_( ABS_( 1 ), abs )\r\n",
"#define fabs_   OP_COUNT_WRAPPER1_( ABS_( 1 ), fabs )\r\n",
"#define fabsf_  OP_COUNT_WRAPPER1_( ABS_( 1 ), fabsf )\r\n",
"#define labs_   OP_COUNT_WRAPPER1_( ABS_( 1 ), labs )\r\n",
"#define floor_  OP_COUNT_WRAPPER1_( MISC_( 1 ), floor )\r\n",
"#define floorf_ OP_COUNT_WRAPPER1_( MISC_( 1 ), floorf )\r\n",
"#define sqrt_   OP_COUNT_WRAPPER1_( SQRT_( 1 ), sqrt )\r\n",
"#define sqrtf_  OP_COUNT_WRAPPER1_( SQRT_( 1 ), sqrtf )\r\n",
"#define pow_    OP_COUNT_WRAPPER1_( POWER_( 1 ), pow )\r\n",
"#define powf_   OP_COUNT_WRAPPER1_( POWER_( 1 ), powf )\r\n",
"#define exp_    OP_COUNT_WRAPPER1_( POWER_( 1 ), exp )\r\n",
"#define expf_   OP_COUNT_WRAPPER1_( POWER_( 1 ), expf )\r\n",
"#define log_    OP_COUNT_WRAPPER1_( LOG_( 1 ), log )\r\n",
"#define logf_   OP_COUNT_WRAPPER1_( LOG_( 1 ), logf )\r\n",
"#define log10_  OP_COUNT_WRAPPER1_( LOG_( 1 ), log10 )\r\n",
"#define log10f_ OP_COUNT_WRAPPER1_( LOG_( 1 ), log10f )\r\n",
"#define cos_    OP_COUNT_WRAPPER1_( TRANS_( 1 ), cos )\r\n",
"#define cosf_   OP_COUNT_WRAPPER1_( TRANS_( 1 ), cosf )\r\n",
"#define sin_    OP_COUNT_WRAPPER1_( TRANS_( 1 ), sin )\r\n",
"#define sinf_   OP_COUNT_WRAPPER1_( TRANS_( 1 ), sinf )\r\n",
"#define tan_    OP_COUNT_WRAPPER1_( TRANS_( 1 ), tan )\r\n",
"#define tanf_   OP_COUNT_WRAPPER1_( TRANS_( 1 ), tanf )\r\n",
"#define acos_   OP_COUNT_WRAPPER1_( TRANS_( 1 ), acos )\r\n",
"#define acosf_  OP_COUNT_WRAPPER1_( TRANS_( 1 ), acosf )\r\n",
"#define asin_   OP_COUNT_WRAPPER1_( TRANS_( 1 ), asin )\r\n",
"#define asinf_  OP_COUNT_WRAPPER1_( TRANS_( 1 ), asinf )\r\n",
"#define atan_   OP_COUNT_WRAPPER1_( TRANS_( 1 ), atan )\r\n",
"#define atanf_  OP_COUNT_WRAPPER1_( TRANS_( 1 ), atanf )\r\n",
"#define atan2_  OP_COUNT_WRAPPER1_( TRANS_( 1 ), atan2 )\r\n",
"#define atan2f_ OP_COUNT_WRAPPER1_( TRANS_( 1 ), atan2f )\r\n",
"#define cosh_   OP_COUNT_WRAPPER1_( TRANS_( 1 ), cosh )\r\n",
"#define coshf_  OP_COUNT_WRAPPER1_( TRANS_( 1 ), coshf )\r\n",
"#define sinh_   OP_COUNT_WRAPPER1_( TRANS_( 1 ), sinh )\r\n",
"#define sinhf_  OP_COUNT_WRAPPER1_( TRANS_( 1 ), sinhf )\r\n",
"#define tanh_   OP_COUNT_WRAPPER1_( TRANS_( 1 ), tanh )\r\n",
"#define tanhf_  OP_COUNT_WRAPPER1_( TRANS_( 1 ), tanhf )\r\n",
"#define fmod_   OP_COUNT_WRAPPER1_( DIV_( 1 ), fmod )\r\n",
"#define fmodf_  OP_COUNT_WRAPPER1_( DIV_( 1 ), fmodf )\r\n",
"#define frexp_  OP_COUNT_WRAPPER1_( MISC_( 2 ), frexp )\r\n",
"#define frexpf_ OP_COUNT_WRAPPER1_( MISC_( 2 ), frexpf )\r\n",
"\r\n",
"/* the macros below are instrumented versions of user-defined macros that might be used in the source code \r\n",
"/* representing some well-known and recognized mathematical operations (that are not defined in math.h) */\r\n",
"/* Note: the 'wmc_flag_=wmc_flag_' is used to avoid warning: left-hand operand of comma expression has no effect with gcc */\r\n",
"\r\n",
"#define min_( a, b )     OP_COUNT_WRAPPER1_( MISC_( 1 ), min( ( a ), ( b ) ) )\r\n",
"#define max_( a, b )     OP_COUNT_WRAPPER1_( MISC_( 1 ), max( ( a ), ( b ) ) )\r\n",
"#define MIN_( a, b )     OP_COUNT_WRAPPER1_( MISC_( 1 ), MIN( ( a ), ( b ) ) )\r\n",
"#define MAX_( a, b )     OP_COUNT_WRAPPER1_( MISC_( 1 ), MAX( ( a ), ( b ) ) )\r\n",
"#define Min_( a, b )     OP_COUNT_WRAPPER1_( MISC_( 1 ), Min( ( a ), ( b ) ) )\r\n",
"#define Max_( a, b )     OP_COUNT_WRAPPER1_( MISC_( 1 ), Max( ( a ), ( b ) ) )\r\n",
"#define sqr_( x )        OP_COUNT_WRAPPER1_( MULT_( 1 ), sqr( ( x ) ) )\r\n",
"#define Sqr_( x )        OP_COUNT_WRAPPER1_( MULT_( 1 ), Sqr( ( x ) ) )\r\n",
"#define SQR_( x )        OP_COUNT_WRAPPER1_( MULT_( 1 ), SQR( ( x ) ) )\r\n",
"#define square_( x )     OP_COUNT_WRAPPER1_( MULT_( 1 ), square( ( x ) ) )\r\n",
"#define Square_( x )     OP_COUNT_WRAPPER1_( MULT_( 1 ), Square( ( x ) ) )\r\n",
"#define SQUARE_( x )     OP_COUNT_WRAPPER1_( MULT_( 1 ), SQUARE( ( x ) ) )\r\n",
"#define sign_( x )       OP_COUNT_WRAPPER1_( MOVE_( 1 ), sign( ( x ) ) )\r\n",
"#define Sign_( x )       OP_COUNT_WRAPPER1_( MOVE_( 1 ), Sign( ( x ) ) )\r\n",
"#define SIGN_( x )       OP_COUNT_WRAPPER1_( MOVE_( 1 ), SIGN( ( x ) ) )\r\n",
"#define inv_sqrt_( x )   OP_COUNT_WRAPPER1_( SQRT_( 1 ), inv_sqrt( ( x ) ) )\r\n",
"#define inv_sqrtf_( x )  OP_COUNT_WRAPPER1_( SQRT_( 1 ), inv_sqrtf( ( x ) ) )\r\n",
"#define log_base_2_( x ) OP_COUNT_WRAPPER1_( ( LOG_( 1 ), MULT_( 1 ) ), log_base_2( ( x ) ) )\r\n",
"#define log2_( x   )     OP_COUNT_WRAPPER1_( ( LOG_( 1 ), MULT_( 1 ) ), log2( ( x ) ) )\r\n",
"#define log2f_( x   )    OP_COUNT_WRAPPER1_( ( LOG_( 1 ), MULT_( 1 ) ), log2f( ( x ) ) )\r\n",
"#define log2_f_( x )     OP_COUNT_WRAPPER1_( ( LOG_( 1 ), MULT_( 1 ) ), log2_f( ( x ) ) )\r\n",
"#define _round_( x )     OP_COUNT_WRAPPER1_( wmc_flag_ = wmc_flag_, _round( ( x ) ) )\r\n",
"#define round_( x )      OP_COUNT_WRAPPER1_( wmc_flag_ = wmc_flag_, round( ( x ) ) )\r\n",
"#define round_f_( x )    OP_COUNT_WRAPPER1_( wmc_flag_ = wmc_flag_, round_f( ( x ) ) )\r\n",
"#define roundf_( x )     OP_COUNT_WRAPPER1_( wmc_flag_ = wmc_flag_, roundf( ( x ) ) )\r\n",
"#define set_min_( a, b ) OP_COUNT_WRAPPER3_( ( ADD_( 1 ), BRANCH_( 1 ), MOVE_( 1 ) ), set_min( ( a ), ( b ) ) )\r\n",
"#define set_max_( a, b ) OP_COUNT_WRAPPER3_( ( ADD_( 1 ), BRANCH_( 1 ), MOVE_( 1 ) ), set_max( ( a ), ( b ) ) )\r\n",
"\r\n",
"/* Functions */\r\n",
"#define func_( name, x ) OP_COUNT_WRAPPER1_( FUNC_( x ), name )\r\n",
"\r\n",
"/* Logical Operators */\r\n",
"#ifndef __\r\n",
"#define __ ( BRANCH_( 1 ), 1 ) &&\r\n",
"#endif\r\n",
"\r\n",
"/* Ternary Operators (? and :) */\r\n",
"#ifndef _\r\n",
"#define _ ( BRANCH_( 1 ), 0 ) ? 0:\r\n",
"#endif\r\n",
"\r\n",
"/* Flow Control keywords */\r\n",
"#define if_                            \\\r\n",
"    OP_COUNT_WRAPPER2_( BRANCH_( 1 ) ) \\\r\n",
"    if\r\n",
"#define for_    OP_COUNT_WRAPPER2_(  LOOP_(1)) for\r\n",
"#define while_( c ) \\\r\n",
"    while           \\\r\n",
"    OP_COUNT_WRAPPER1_( BRANCH_( 1 ), ( c ) ) /* needs extra \"()\" if ',' encountered */\r\n",
"#define do_ \\\r\n",
"    do      \\\r\n",
"    {\r\n",
"#define _while    \\\r\n",
"    BRANCH_( 1 ); \\\r\n",
"    }             \\\r\n",
"    while\r\n",
"\r\n",
"#define goto_                          \\\r\n",
"    OP_COUNT_WRAPPER2_( BRANCH_( 1 ) ) \\\r\n",
"    goto\r\n",
"#define break_                         \\\r\n",
"    OP_COUNT_WRAPPER2_( BRANCH_( 1 ) ) \\\r\n",
"    break\r\n",
"#define continue_                      \\\r\n",
"    OP_COUNT_WRAPPER2_( BRANCH_( 1 ) ) \\\r\n",
"    continue\r\n",
"#define return_                                                                     \\\r\n",
"    OP_COUNT_WRAPPER2_( ( wmc_flag_ = stack_tree_level_, STACK_DEPTH_FCT_RETURN ) ) \\\r\n",
"    return\r\n",
"\r\n",
"#define switch_                                           \\\r\n",
"    OP_COUNT_WRAPPER2_( ( BRANCH_( 1 ), wmc_flag_ = 1 ) ) \\\r\n",
"    switch\r\n",
"#define cost_( n ) OP_COUNT_WRAPPER2_( wmc_flag_ ? ( ADD_( n ), BRANCH_( n ), wmc_flag_ = 0 ) : 0 );\r\n",
"\r\n",
"#ifdef WMOPS\r\n",
"\r\n",
"#define ACC 2\r\n",
"#define MUL 1\r\n",
"\r\n",
"/* Counting Function (should not be called externally!) */\r\n",
"static void wops_( const char *ops )\r\n",
"{\r\n",
"    char lm = 0;        /* lm: Last Operation is Math */\r\n",
"    static char lo = 0; /* Last Operation */\r\n",
"\r\n",
"    void ( *fct )( const char *ops ) = wops_;\r\n",
"\r\n",
"st:\r\n",
"    while ( *ops != '\\0' )\r\n",
"    {\r\n",
"        switch ( *ops++ )\r\n",
"        {\r\n",
"            int cnt;\r\n",
"            case '-':\r\n",
"                for ( cnt = 0; ops[cnt] == '>'; cnt++ )\r\n",
"                    ;\r\n",
"                if ( cnt & 1 )\r\n",
"                    goto ind;\r\n",
"            case '+':\r\n",
"                lm = 2;\r\n",
"                if ( lo & MUL )\r\n",
"                {\r\n",
"                    MULT_( -1 );\r\n",
"                    MAC_( 1 );\r\n",
"                    break;\r\n",
"                }\r\n",
"                lo = ACC << 2;\r\n",
"            case 'U':\r\n",
"            case 'D':\r\n",
"                ADD_( 1 );\r\n",
"                break;\r\n",
"            case '*':\r\n",
"                lm = 2;\r\n",
"                if ( lo & ACC )\r\n",
"                {\r\n",
"                    ADD_( -1 );\r\n",
"                    MAC_( 1 );\r\n",
"                    break;\r\n",
"                }\r\n",
"                lo = MUL << 2;\r\n",
"                MULT_( 1 );\r\n",
"                break;\r\n",
"            case '/':\r\n",
"            case '%':\r\n",
"                lm = 2;\r\n",
"                DIV_( 1 );\r\n",
"                break;\r\n",
"            case '&':\r\n",
"            case '|':\r\n",
"            case '^':\r\n",
"                lm = 2;\r\n",
"            case '~':\r\n",
"                LOGIC_( 1 );\r\n",
"                break;\r\n",
"            case '<':\r\n",
"            case '>':\r\n",
"                if ( *ops != ops[-1] )\r\n",
"                    goto error;\r\n",
"                ops++;\r\n",
"            case -85:\r\n",
"            case -69:\r\n",
"                lm = 2;\r\n",
"                SHIFT_( 1 );\r\n",
"                break;\r\n",
"            case 'L':\r\n",
"            case 'G':\r\n",
"                if ( *ops == 't' )\r\n",
"                    goto comp;\r\n",
"            case 'E':\r\n",
"            case 'N':\r\n",
"                if ( *ops != 'e' )\r\n",
"                    goto error;\r\n",
"            comp:\r\n",
"                ops++;\r\n",
"                ADD_( 1 );\r\n",
"                break;\r\n",
"            case '!':\r\n",
"                MISC_( 2 );\r\n",
"                break;\r\n",
"            case 'M':\r\n",
"                MOVE_( 1 );\r\n",
"                break;\r\n",
"            case 'S':\r\n",
"                STORE_( 1 );\r\n",
"                break;\r\n",
"            case 'P':\r\n",
"                PTR_INIT_( 1 );\r\n",
"                break;\r\n",
"            case '[':\r\n",
"            case ']':\r\n",
"                goto st;\r\n",
"            ind:\r\n",
"                ops++;\r\n",
"            case 'I':\r\n",
"            case '.':\r\n",
"                INDIRECT_( 1 );\r\n",
"                break;\r\n",
"            case '=':\r\n",
"                if ( lm )\r\n",
"                    goto st;\r\n",
"            case '\\0':\r\n",
"                /* This Shouldn't Happen */\r\n",
"                /* These are Used to Avoid: \"warning: 'name' defined but not used\" with Cygwin gcc Compiler */\r\n",
"                wmc_flag_ = wmc_flag_;\r\n",
"                ops_cnt_ptr = ops_cnt_ptr;\r\n",
"                fct( \"\" );\r\n",
"            error:\r\n",
"            default:\r\n",
"                fprintf( stderr, \"\\r wops: Invalid Counting Operation '%s'\\n\", ops - 1 );\r\n",
"                exit( -1 );\r\n",
"        }\r\n",
"        lm >>= 1;\r\n",
"        lo >>= 2;\r\n",
"    }\r\n",
"\r\n",
"    return;\r\n",
"}\r\n",
"\r\n",
"#endif\r\n",
"\r\n",
"/* All Other Operations */\r\n",
"#define $( str ) OP_COUNT_WRAPPER2_( wops_( str ) )\r\n",
"\r\n",
"\r\n",
"/*-------------------------------------------------------------------*\r\n",
" * Memory counting tool\r\n",
" *-------------------------------------------------------------------*/\r\n",
"\r\n",
"/* Enhanced Const Data Size Counting (Rounding Up to the Nearest 'Integer' Size) */\r\n",
"#define rsize( item ) ( ( sizeof( item ) + sizeof( int ) - 1 ) / sizeof( int ) * sizeof( int ) )\r\n",
"\r\n",
"#ifdef _MSC_VER\r\n",
"/* Disable \"warning C4210: nonstandard extension used : function given file scope\" with Visual Studio Compiler */\r\n",
"#pragma warning( disable : 4210 )\r\n",
"#endif\r\n",
"\r\n",
"/* Const Data Size and PROM Size Wrapper Functions */\r\n",
"#define Const_Data_Size_Func( file ) Const_Data_Size_##file( void )\r\n",
"#define Get_Const_Data_Size( file, val_ptr )       \\\r\n",
"    {                                              \\\r\n",
"        extern int Const_Data_Size_##file( void ); \\\r\n",
"        *( val_ptr ) = Const_Data_Size_##file();   \\\r\n",
"    }\r\n",
"#define PROM_Size_Func( file ) PROM_Size_##file( void )\r\n",
"#define Get_PROM_Size( file, val_ptr )     \\\r\n",
"    {                                      \\\r\n",
"        int PROM_Size_##file( void );      \\\r\n",
"        *( val_ptr ) = PROM_Size_##file(); \\\r\n",
"    }\r\n",
"\r\n",
"/* ROM Size Lookup Table - contains information about PROM size and Const Data Size in all source files */\r\n",
"/* The print_mem() function looks for this table to print the results of Const Data usage and PROM usage */\r\n",
"typedef struct ROM_Size_Lookup_Table\r\n",
"{\r\n",
"    const char file_spec[255];\r\n",
"    int PROM_size;\r\n",
"    int ( *Get_Const_Data_Size_Func )( void );\r\n",
"} ROM_Size_Lookup_Table;\r\n",
"\r\n",
"/* The WMC tool inserts the following declaration during the innstrumentation process in the .c file where the function print_mem() is located */\r\n",
"/* and modifies it to print_mem(Const_Data_PROM_Table) */\r\n",
"\r\n",
"/* #ifdef WMOPS\r\n",
" * ROM_Size_Lookup_Table Const_Data_PROM_Table[] =\r\n",
" * {\r\n",
" *   {\"../lib_enc/rom_enc.c\", 0, NULL},\r\n",
" *   {\"../lib_com/*.c\", 0, NULL},\r\n",
" *   {\"\", -1, NULL}\r\n",
" * };\r\n",
" * #endif\r\n",
" */\r\n",
"\r\n",
"/*#define MEM_ALIGN_64BITS */ /* Define this when using 64 Bits values in the code (ex: double), otherwise it will align on 32 Bits */\r\n",
"/*#define MEM_COUNT_DETAILS*/\r\n",
"\r\n",
"typedef enum\r\n",
"{\r\n",
"    USE_BYTES = 0,\r\n",
"    USE_16BITS = 1,\r\n",
"    USE_32BITS = 2,\r\n",
"    USE_64BITS = 3\r\n",
"} Counting_Size;\r\n",
"\r\n",
"#if ( defined( _WIN32 ) && ( _MSC_VER <= 1800 ) && ( _MSC_VER >= 1300 ) )\r\n",
"#define __func__ __FUNCTION__\r\n",
"#elif defined( __STDC_VERSION__ ) && __STDC_VERSION__ < 199901L\r\n",
"#if ( __GNUC__ >= 2 )\r\n",
"#define __func__ __FUNCTION__\r\n",
"#else\r\n",
"#define __func__ \"<unknown>\"\r\n",
"#endif\r\n",
"#elif defined( __GNUC__ )\r\n",
"#define __func__ __extension__ __FUNCTION__\r\n",
"#endif\r\n",
"\r\n",
"\r\n",
"#ifdef WMOPS\r\n",
"\r\n",
"void *mem_alloc( const char *func_name, int func_lineno, size_t size, char *alloc_str );\r\n",
"void mem_free( const char *func_name, int func_lineno, void *ptr );\r\n",
"\r\n",
"#define malloc_( size )    mem_alloc( __func__, __LINE__, size, \"m:\" #size )\r\n",
"#define calloc_( n, size ) mem_alloc( __func__, __LINE__, ( n ) * ( size ), \"c:\" #n \", \" #size )\r\n",
"#define free_( ptr )       mem_free( __func__, __LINE__, ptr )\r\n",
"\r\n",
"void reset_mem( Counting_Size cnt_size );\r\n",
"void print_mem( ROM_Size_Lookup_Table Const_Data_PROM_Table[] );\r\n",
"\r\n",
"int push_stack( const char *filename, const char *fctname );\r\n",
"int pop_stack( const char *filename, const char *fctname );\r\n",
"\r\n",
"#ifdef WMOPS_DETAIL\r\n",
"#define STACK_DEPTH_FCT_CALL   ( push_wmops( __FUNCTION__ \" [WMC_AUTO]\" ), push_stack( __FILE__, __FUNCTION__ ) ) /* add push_wmops() in all function calls */\r\n",
"#define STACK_DEPTH_FCT_RETURN ( pop_wmops(), pop_stack( __FILE__, __FUNCTION__ ) )                 /* add pop_wmops() in all function returns */\r\n",
"#else\r\n",
"#define STACK_DEPTH_FCT_CALL   push_stack( __FILE__, __FUNCTION__ )\r\n",
"#define STACK_DEPTH_FCT_RETURN pop_stack( __FILE__, __FUNCTION__ )\r\n",
"#endif\r\n",
"\r\n",
"void reset_stack( void );\r\n",
"#define func_start_ int stack_tree_level_ = STACK_DEPTH_FCT_CALL;\r\n",
"\r\n",
"#else\r\n",
"#define malloc_( n1 )     malloc( n1 )\r\n",
"#define calloc_( n1, n2 ) calloc( n1, n2 )\r\n",
"#define free_( ptr )      free( ptr )\r\n",
"#define reset_mem( cnt_size )\r\n",
"#define print_mem( Const_Data_PROM_Table )\r\n",
"\r\n",
"#define push_stack( file, fct )\r\n",
"#define pop_stack( file, fct )\r\n",
"#define reset_stack()\r\n",
"#define func_start_\r\n",
"\r\n",
"#endif\r\n",
"\r\n",
"\r\n",
"/* Global counter variable for calculation of complexity weight */\r\n",
"typedef struct\r\n",
"{\r\n",
"    unsigned int add;   /* Complexity Weight of 1 */\r\n",
"    unsigned int sub;   /* Complexity Weight of 1 */\r\n",
"    unsigned int abs_s; /* Complexity Weight of 1 */\r\n",
"    unsigned int shl;   /* Complexity Weight of 1 */\r\n",
"    unsigned int shr;   /* Complexity Weight of 1 */\r\n",
"\r\n",
"    unsigned int extract_h; /* Complexity Weight of 1 */\r\n",
"    unsigned int extract_l; /* Complexity Weight of 1 */\r\n",
"    unsigned int mult;      /* Complexity Weight of 1 */\r\n",
"    unsigned int L_mult;    /* Complexity Weight of 1 */\r\n",
"    unsigned int negate;    /* Complexity Weight of 1 */\r\n",
"\r\n",
"    unsigned int round;   /* Complexity Weight of 1 */\r\n",
"    unsigned int L_mac;   /* Complexity Weight of 1 */\r\n",
"    unsigned int L_msu;   /* Complexity Weight of 1 */\r\n",
"    unsigned int L_macNs; /* Complexity Weight of 1 */\r\n",
"    unsigned int L_msuNs; /* Complexity Weight of 1 */\r\n",
"\r\n",
"    unsigned int L_add;    /* Complexity Weight of 1 */\r\n",
"    unsigned int L_sub;    /* Complexity Weight of 1 */\r\n",
"    unsigned int L_add_c;  /* Complexity Weight of 2 */\r\n",
"    unsigned int L_sub_c;  /* Complexity Weight of 2 */\r\n",
"    unsigned int L_negate; /* Complexity Weight of 1 */\r\n",
"\r\n",
"    unsigned int L_shl;  /* Complexity Weight of 1 */\r\n",
"    unsigned int L_shr;  /* Complexity Weight of 1 */\r\n",
"    unsigned int mult_r; /* Complexity Weight of 1 */\r\n",
"    unsigned int shr_r;  /* Complexity Weight of 3 */\r\n",
"    unsigned int mac_r;  /* Complexity Weight of 1 */\r\n",
"\r\n",
"    unsigned int msu_r;       /* Complexity Weight of 1 */\r\n",
"    unsigned int L_deposit_h; /* Complexity Weight of 1 */\r\n",
"    unsigned int L_deposit_l; /* Complexity Weight of 1 */\r\n",
"    unsigned int L_shr_r;     /* Complexity Weight of 3 */\r\n",
"    unsigned int L_abs;       /* Complexity Weight of 1 */\r\n",
"\r\n",
"    unsigned int L_sat;  /* Complexity Weight of 4 */\r\n",
"    unsigned int norm_s; /* Complexity Weight of 1 */\r\n",
"    unsigned int div_s;  /* Complexity Weight of 18 */\r\n",
"    unsigned int norm_l; /* Complexity Weight of 1 */\r\n",
"    unsigned int move16; /* Complexity Weight of 1 */\r\n",
"\r\n",
"    unsigned int move32;  /* Complexity Weight of 2 */\r\n",
"    unsigned int Logic16; /* Complexity Weight of 1 */\r\n",
"    unsigned int Logic32; /* Complexity Weight of 2 */\r\n",
"    unsigned int Test;    /* Complexity Weight of 2 */\r\n",
"    unsigned int s_max;   /* Complexity Weight of 1 */\r\n",
"\r\n",
"    unsigned int s_min;   /* Complexity Weight of 1 */\r\n",
"    unsigned int L_max;   /* Complexity Weight of 1 */\r\n",
"    unsigned int L_min;   /* Complexity Weight of 1 */\r\n",
"    unsigned int L40_max; /* Complexity Weight of 1 */\r\n",
"    unsigned int L40_min; /* Complexity Weight of 1 */\r\n",
"\r\n",
"    unsigned int shl_r;     /* Complexity Weight of 3 */\r\n",
"    unsigned int L_shl_r;   /* Complexity Weight of 3 */\r\n",
"    unsigned int L40_shr_r; /* Complexity Weight of 3 */\r\n",
"    unsigned int L40_shl_r; /* Complexity Weight of 3 */\r\n",
"    unsigned int norm_L40;  /* Complexity Weight of 1 */\r\n",
"\r\n",
"    unsigned int L40_shl;    /* Complexity Weight of 1 */\r\n",
"    unsigned int L40_shr;    /* Complexity Weight of 1 */\r\n",
"    unsigned int L40_negate; /* Complexity Weight of 1 */\r\n",
"    unsigned int L40_add;    /* Complexity Weight of 1 */\r\n",
"    unsigned int L40_sub;    /* Complexity Weight of 1 */\r\n",
"\r\n",
"    unsigned int L40_abs;  /* Complexity Weight of 1 */\r\n",
"    unsigned int L40_mult; /* Complexity Weight of 1 */\r\n",
"    unsigned int L40_mac;  /* Complexity Weight of 1 */\r\n",
"    unsigned int mac_r40;  /* Complexity Weight of 2 */\r\n",
"\r\n",
"    unsigned int L40_msu;      /* Complexity Weight of 1 */\r\n",
"    unsigned int msu_r40;      /* Complexity Weight of 2 */\r\n",
"    unsigned int Mpy_32_16_ss; /* Complexity Weight of 2 */\r\n",
"    unsigned int Mpy_32_32_ss; /* Complexity Weight of 4 */\r\n",
"    unsigned int L_mult0;      /* Complexity Weight of 1 */\r\n",
"\r\n",
"    unsigned int L_mac0; /* Complexity Weight of 1 */\r\n",
"    unsigned int L_msu0; /* Complexity Weight of 1 */\r\n",
"    unsigned int lshl;   /* Complexity Weight of 1 */\r\n",
"    unsigned int lshr;   /* Complexity Weight of 1 */\r\n",
"    unsigned int L_lshl; /* Complexity Weight of 1 */\r\n",
"\r\n",
"    unsigned int L_lshr;   /* Complexity Weight of 1 */\r\n",
"    unsigned int L40_lshl; /* Complexity Weight of 1 */\r\n",
"    unsigned int L40_lshr; /* Complexity Weight of 1 */\r\n",
"    unsigned int s_and;    /* Complexity Weight of 1 */\r\n",
"    unsigned int s_or;     /* Complexity Weight of 1 */\r\n",
"\r\n",
"    unsigned int s_xor; /* Complexity Weight of 1 */\r\n",
"    unsigned int L_and; /* Complexity Weight of 1 */\r\n",
"    unsigned int L_or;  /* Complexity Weight of 1 */\r\n",
"    unsigned int L_xor; /* Complexity Weight of 1 */\r\n",
"    unsigned int rotl;  /* Complexity Weight of 3 */\r\n",
"\r\n",
"    unsigned int rotr;          /* Complexity Weight of 3 */\r\n",
"    unsigned int L_rotl;        /* Complexity Weight of 3 */\r\n",
"    unsigned int L_rotr;        /* Complexity Weight of 3 */\r\n",
"    unsigned int L40_set;       /* Complexity Weight of 3 */\r\n",
"    unsigned int L40_deposit_h; /* Complexity Weight of 1 */\r\n",
"\r\n",
"    unsigned int L40_deposit_l; /* Complexity Weight of 1 */\r\n",
"    unsigned int L40_deposit32; /* Complexity Weight of 1 */\r\n",
"    unsigned int Extract40_H;   /* Complexity Weight of 1 */\r\n",
"    unsigned int Extract40_L;   /* Complexity Weight of 1 */\r\n",
"    unsigned int L_Extract40;   /* Complexity Weight of 1 */\r\n",
"\r\n",
"    unsigned int L40_round;    /* Complexity Weight of 1 */\r\n",
"    unsigned int L_saturate40; /* Complexity Weight of 1 */\r\n",
"    unsigned int round40;      /* Complexity Weight of 1 */\r\n",
"    unsigned int If;           /* Complexity Weight of 4 */\r\n",
"    unsigned int Goto;         /* Complexity Weight of 4 */\r\n",
"\r\n",
"    unsigned int Break;    /* Complexity Weight of 4 */\r\n",
"    unsigned int Switch;   /* Complexity Weight of 8 */\r\n",
"    unsigned int For;      /* Complexity Weight of 3 */\r\n",
"    unsigned int While;    /* Complexity Weight of 4 */\r\n",
"    unsigned int Continue; /* Complexity Weight of 4 */\r\n",
"\r\n",
"    unsigned int L_mls;  /* Complexity Weight of 6 */\r\n",
"    unsigned int div_l;  /* Complexity Weight of 32 */\r\n",
"    unsigned int i_mult; /* Complexity Weight of 3 */\r\n",
"} BASIC_OP;\r\n",
"\r\n",
"#ifdef WMOPS\r\n",
"extern BASIC_OP *multiCounter;\r\n",
"extern int currCounter;\r\n",
"\r\n",
"/* Technical note :\r\n",
"   * The following 3 variables are only used for correct complexity\r\n",
"   * evaluation of the following structure :\r\n",
"   *   IF{\r\n",
"   *     ...\r\n",
"   *   } ELSE IF {\r\n",
"   *     ...\r\n",
"   *   } ELSE IF {\r\n",
"   *     ...\r\n",
"   *   }\r\n",
"   *   ...\r\n",
"   *   } ELSE {\r\n",
"   *     ...\r\n",
"   *   }\r\n",
"   */\r\n",
"extern int funcId_where_last_call_to_else_occurred;\r\n",
"extern long funcid_total_wmops_at_last_call_to_else;\r\n",
"extern int call_occurred;\r\n",
"\r\n",
"extern long TotalWeightedOperation( void );\r\n",
"long DeltaWeightedOperation( void );\r\n",
"\r\n",
"void Set_BASOP_WMOPS_counter( int counterId );\r\n",
"void Reset_BASOP_WMOPS_counter( void );\r\n",
"\r\n",
"#endif\r\n",
"\r\n",
"/*****************************************************************************\r\n",
" *\r\n",
" *  Function Name : FOR\r\n",
" *\r\n",
" *  Purpose :\r\n",
" *\r\n",
" *    The macro FOR should be used instead of the 'for' C statement.\r\n",
" *    The complexity is independent of the number of loop iterations that are\r\n",
" *    performed.\r\n",
" *\r\n",
" *  Complexity weight : 3 (regardless of number of iterations).\r\n",
" *\r\n",
" *****************************************************************************/\r\n",
"#ifndef WMOPS\r\n",
"#define FOR( a) for( a)\r\n",
"\r\n",
"#else \r\n",
"#define FOR( a) if( incrFor(), 0); else for( a)\r\n",
"\r\n",
"static __inline void incrFor( void) {\r\n",
"   multiCounter[currCounter].For++;\r\n",
"}\r\n",
"#endif \r\n",
"\r\n",
"\r\n",
"/*****************************************************************************\r\n",
" *\r\n",
" *  Function Name : WHILE\r\n",
" *\r\n",
" *  Purpose :\r\n",
" *\r\n",
" *    The macro WHILE should be used instead of the 'while' C statement.\r\n",
" *    The complexity is proportional to the number of loop iterations that\r\n",
" *    are performed.\r\n",
" *\r\n",
" *  Complexity weight : 4 x 'number of loop iterations'.\r\n",
" *\r\n",
" *****************************************************************************/\r\n",
"#ifndef WMOPS\r\n",
"#define WHILE( a) while( a)\r\n",
"\r\n",
"#else \r\n",
"#define WHILE( a) while( incrWhile(), a)\r\n",
"\r\n",
"static __inline void incrWhile( void) {\r\n",
"   multiCounter[currCounter].While++;\r\n",
"}\r\n",
"#endif \r\n",
"\r\n",
"\r\n",
"/*****************************************************************************\r\n",
" *\r\n",
" *  Function Name : DO\r\n",
" *\r\n",
" *  Purpose :\r\n",
" *\r\n",
" *    The macro DO should be used instead of the 'do' C statement.\r\n",
" *\r\n",
" *  Complexity weight : 0 (complexity counted by WHILE macro).\r\n",
" *\r\n",
" *****************************************************************************/\r\n",
"#ifndef WMOPS\r\n",
"#define DO do\r\n",
"\r\n",
"#else \r\n",
"#define DO do\r\n",
"\r\n",
"#endif \r\n",
"\r\n",
"\r\n",
"/*****************************************************************************\r\n",
" *\r\n",
" *  Function Name : IF\r\n",
" *\r\n",
" *  Purpose :\r\n",
" *\r\n",
" *    The macro IF should :\r\n",
" *\r\n",
" *    - not be used when :\r\n",
" *      - the 'if' structure does not have any 'else if' nor 'else' statement\r\n",
" *      - and it conditions only one DSP basic operations.\r\n",
" *\r\n",
" *    - be used instead of the 'if' C statement in every other case :\r\n",
" *      - when there is an 'else' or 'else if' statement,\r\n",
" *      - or when the 'if' conditions several DSP basic operations,\r\n",
" *      - or when the 'if' conditions a function call.\r\n",
" *\r\n",
" *  Complexity weight : 4\r\n",
" *\r\n",
" *****************************************************************************/\r\n",
"#ifndef WMOPS\r\n",
"#define IF( a) if( a)\r\n",
"\r\n",
"#else \r\n",
"#define IF( a) if( incrIf(), a)\r\n",
"\r\n",
"static __inline void incrIf( void) {\r\n",
"   /* Technical note :\r\n",
"    * If the \"IF\" operator comes just after an \"ELSE\", its counter\r\n",
"    * must not be incremented.\r\n",
"    */\r\n",
"    if ( ( currCounter != funcId_where_last_call_to_else_occurred ) || ( TotalWeightedOperation() != funcid_total_wmops_at_last_call_to_else ) || ( call_occurred == 1 ) )\r\n",
"    {\r\n",
"        multiCounter[currCounter].If++;\r\n",
"    }\r\n",
"\r\n",
"    call_occurred = 0;\r\n",
"    funcId_where_last_call_to_else_occurred = INT_MAX;\r\n",
"}\r\n",
"#endif \r\n",
"\r\n",
"\r\n",
"/*****************************************************************************\r\n",
" *\r\n",
" *  Function Name : ELSE\r\n",
" *\r\n",
" *  Purpose :\r\n",
" *\r\n",
" *    The macro ELSE should be used instead of the 'else' C statement.\r\n",
" *\r\n",
" *  Complexity weight : 4\r\n",
" *\r\n",
" *****************************************************************************/\r\n",
"#ifndef WMOPS\r\n",
"#define ELSE else\r\n",
"\r\n",
"#else \r\n",
"#define ELSE else if( incrElse(), 0) ; else\r\n",
"\r\n",
"static __inline void incrElse( void) {\r\n",
"   multiCounter[currCounter].If++;\r\n",
"\r\n",
"   /* We keep track of the funcId of the last function\r\n",
"    * which used ELSE {...} structure.\r\n",
"    */\r\n",
"   funcId_where_last_call_to_else_occurred = currCounter;\r\n",
"\r\n",
"   /* We keep track of the number of WMOPS of this funcId\r\n",
"    * when the ELSE macro was called.\r\n",
"    */\r\n",
"   funcid_total_wmops_at_last_call_to_else = TotalWeightedOperation();\r\n",
"\r\n",
"   /* call_occurred is set to 0, in order to count the next IF (if necessary)\r\n",
"    */\r\n",
"   call_occurred = 0;\r\n",
"}\r\n",
"#endif \r\n",
"\r\n",
"\r\n",
"/*****************************************************************************\r\n",
" *\r\n",
" *  Function Name : SWITCH\r\n",
" *\r\n",
" *  Purpose :\r\n",
" *\r\n",
" *    The macro SWITCH should be used instead of the 'switch' C statement.\r\n",
" *\r\n",
" *  Complexity weight : 8\r\n",
" *\r\n",
" *****************************************************************************/\r\n",
"#ifndef WMOPS\r\n",
"#define SWITCH( a) switch( a)\r\n",
"\r\n",
"#else \r\n",
"#define SWITCH( a) switch( incrSwitch(), a)\r\n",
"\r\n",
"static __inline void incrSwitch( void) {\r\n",
"   multiCounter[currCounter].Switch++;\r\n",
"}\r\n",
"#endif \r\n",
"\r\n",
"\r\n",
"/*****************************************************************************\r\n",
" *\r\n",
" *  Function Name : CONTINUE\r\n",
" *\r\n",
" *  Purpose :\r\n",
" *\r\n",
" *    The macro CONTINUE should be used instead of the 'continue' C statement.\r\n",
" *\r\n",
" *  Complexity weight : 4\r\n",
" *\r\n",
" *****************************************************************************/\r\n",
"#ifndef WMOPS\r\n",
"#define CONTINUE continue\r\n",
"\r\n",
"#else \r\n",
"#define CONTINUE if( incrContinue(), 0); else continue\r\n",
"\r\n",
"static __inline void incrContinue( void) {\r\n",
"   multiCounter[currCounter].Continue++;\r\n",
"}\r\n",
"#endif \r\n",
"\r\n",
"\r\n",
"/*****************************************************************************\r\n",
" *\r\n",
" *  Function Name : BREAK\r\n",
" *\r\n",
" *  Purpose :\r\n",
" *\r\n",
" *    The macro BREAK should be used instead of the 'break' C statement.\r\n",
" *\r\n",
" *  Complexity weight : 4\r\n",
" *\r\n",
" *****************************************************************************/\r\n",
"#ifndef WMOPS\r\n",
"#define BREAK break\r\n",
"\r\n",
"#else \r\n",
"#define BREAK if( incrBreak(), 0) break; else break\r\n",
"\r\n",
"static __inline void incrBreak( void) {\r\n",
"   multiCounter[currCounter].Break++;\r\n",
"}\r\n",
"#endif \r\n",
"\r\n",
"\r\n",
"/*****************************************************************************\r\n",
" *\r\n",
" *  Function Name : GOTO\r\n",
" *\r\n",
" *  Purpose :\r\n",
" *\r\n",
" *    The macro GOTO should be used instead of the 'goto' C statement.\r\n",
" *\r\n",
" *  Complexity weight : 4\r\n",
" *\r\n",
" *****************************************************************************/\r\n",
"#ifndef WMOPS\r\n",
"#define GOTO goto\r\n",
"\r\n",
"#else \r\n",
"#define GOTO if( incrGoto(), 0); else goto\r\n",
"\r\n",
"static __inline void incrGoto( void) {\r\n",
"   multiCounter[currCounter].Goto++;\r\n",
"}\r\n",
"#endif \r\n",
"\r\n",
"#endif /* WMOPS_H */\r\n",
"\r\n",
"\r\n",
"\r\n",