"/*\r\n"
" * (C) 2023 copyright VoiceAge Corporation. All Rights Reserved.\r\n"
" *\r\n"
" * This software is protected by copyright law and by international treaties. The source code, and all of its derivations,\r\n"
" * is provided by VoiceAge Corporation under the \"ITU-T Software Tools' General Public License\". Please, read the license file\r\n"
" * or refer to ITU-T Recommendation G.191 on \"SOFTWARE TOOLS FOR SPEECH AND AUDIO CODING STANDARDS\".\r\n"
" *\r\n"
" * Any use of this software is permitted provided that this notice is not removed and that neither the authors nor\r\n"
" * VoiceAge Corporation are deemed to have made any representations as to the suitability of this software\r\n"
" * for any purpose nor are held responsible for any defects of this software. THERE IS NO WARRANTY FOR THIS SOFTWARE.\r\n"
" *\r\n"
" * Authors: Guy Richard, Vladimir Malenovsky (Vladimir.Malenovsky@USherbrooke.ca)\r\n"
" */\r\n"
"\r\n"
"#ifndef WMOPS_H\r\n"
"#define WMOPS_H\r\n"
"\r\n"
"#ifndef EXIT_FAILURE\r\n"
"#include <stdlib.h> /* stdlib is needed for exit() */\r\n"
"#endif\r\n"
"\r\n"
"#ifndef EOF\r\n"
"#include <stdio.h> /* stdio is needed for fprintf() */\r\n"
"#endif\r\n"
"\r\n"
"\r\n"
"/* To Prevent \"warning: '$' in identifier or number\" message under GCC */\r\n"
"#ifdef __GNUC__\r\n"
"#pragma GCC system_header\r\n"
"#endif\r\n"
"\r\n"
"/* Real-time relationships */\r\n"
"#define FRAMES_PER_SECOND 50.0    \r\n"
"#define WMOPS_BOOST_FAC   ( 1.0f ) /* scaling factor for equalizing the difference between automatic and manual instrumentation */\r\n"
"#define FAC               ( FRAMES_PER_SECOND / 1e6 * WMOPS_BOOST_FAC )\r\n"
"\r\n"
"\r\n"
"#ifdef WMOPS\r\n"
"enum instructions\r\n"
"{\r\n"
"    _ADD,\r\n"
"    _ABS,\r\n"
"    _MULT,\r\n"
"    _MAC,\r\n"
"    _MOVE,\r\n"
"    _STORE,\r\n"
"    _LOGIC,\r\n"
"    _SHIFT,\r\n"
"    _BRANCH,\r\n"
"    _DIV,\r\n"
"    _SQRT,\r\n"
"    _TRANS,\r\n"
"    _FUNC,\r\n"
"    _LOOP,\r\n"
"    _INDIRECT,\r\n"
"    _PTR_INIT,\r\n"
"    _TEST,\r\n"
"    _POWER,\r\n"
"    _LOG,\r\n"
"    _MISC,\r\n"
"    NUM_INST\r\n"
"};\r\n"
"\r\n"
"#define _ADD_C      1\r\n"
"#define _ABS_C      1\r\n"
"#define _MULT_C     1\r\n"
"#define _MAC_C      1\r\n"
"#define _MOVE_C     1\r\n"
"#define _STORE_C    1\r\n"
"#define _LOGIC_C    1\r\n"
"#define _SHIFT_C    1\r\n"
"#define _BRANCH_C   4\r\n"
"#define _DIV_C      18\r\n"
"#define _SQRT_C     10\r\n"
"#define _TRANS_C    25\r\n"
"#define _FUNC_C     2 /* need to add number of arguments */\r\n"
"#define _LOOP_C     3\r\n"
"#define _INDIRECT_C 2\r\n"
"#define _PTR_INIT_C 1\r\n"
"#define _TEST_C     2\r\n"
"#define _POWER_C    25\r\n"
"#define _LOG_C      25\r\n"
"#define _MISC_C     1\r\n"
"\r\n"
"#define _ADD_P      1\r\n"
"#define _ABS_P      1\r\n"
"#define _MULT_P     1\r\n"
"#define _MAC_P      1\r\n"
"#define _MOVE_P     1\r\n"
"#define _STORE_P    0\r\n"
"#define _LOGIC_P    1\r\n"
"#define _SHIFT_P    1\r\n"
"#define _BRANCH_P   2\r\n"
"#define _DIV_P      2\r\n"
"#define _SQRT_P     2\r\n"
"#define _TRANS_P    2\r\n"
"#define _FUNC_P     2 /* need to add number of arguments */\r\n"
"#define _LOOP_P     1\r\n"
"#define _INDIRECT_P 2\r\n"
"#define _PTR_INIT_P 1\r\n"
"#define _TEST_P     1\r\n"
"#define _POWER_P    2\r\n"
"#define _LOG_P      2\r\n"
"#define _MISC_P     1\r\n"
"\r\n"
"#define ADD( x )                                    \\\r\n"
"    {                                               \\\r\n"
"        {                                           \\\r\n"
"            ops_cnt += ( _ADD_C * ( x ) );          \\\r\n"
"            inst_cnt[_ADD] += ( x );                \\\r\n"
"            {                                       \\\r\n"
"                static int pcnt;                    \\\r\n"
"                if ( !pcnt )                        \\\r\n"
"                {                                   \\\r\n"
"                    pcnt = 1;                       \\\r\n"
"                    prom_cnt += ( _ADD_P * ( x ) ); \\\r\n"
"                }                                   \\\r\n"
"            }                                       \\\r\n"
"        }                                           \\\r\n"
"    }\r\n"
"#define ABS( x )                                    \\\r\n"
"    {                                               \\\r\n"
"        {                                           \\\r\n"
"            ops_cnt += ( _ABS_C * ( x ) );          \\\r\n"
"            inst_cnt[_ABS] += ( x );                \\\r\n"
"            {                                       \\\r\n"
"                static int pcnt;                    \\\r\n"
"                if ( !pcnt )                        \\\r\n"
"                {                                   \\\r\n"
"                    pcnt = 1;                       \\\r\n"
"                    prom_cnt += ( _ABS_P * ( x ) ); \\\r\n"
"                }                                   \\\r\n"
"            }                                       \\\r\n"
"        }                                           \\\r\n"
"    }\r\n"
"#define MULT( x )                                    \\\r\n"
"    {                                                \\\r\n"
"        {                                            \\\r\n"
"            ops_cnt += ( _MULT_C * ( x ) );          \\\r\n"
"            inst_cnt[_MULT] += ( x );                \\\r\n"
"            {                                        \\\r\n"
"                static int pcnt;                     \\\r\n"
"                if ( !pcnt )                         \\\r\n"
"                {                                    \\\r\n"
"                    pcnt = 1;                        \\\r\n"
"                    prom_cnt += ( _MULT_P * ( x ) ); \\\r\n"
"                }                                    \\\r\n"
"            }                                        \\\r\n"
"        }                                            \\\r\n"
"    }\r\n"
"#define MAC( x )                                    \\\r\n"
"    {                                               \\\r\n"
"        {                                           \\\r\n"
"            ops_cnt += ( _MAC_C * ( x ) );          \\\r\n"
"            inst_cnt[_MAC] += ( x );                \\\r\n"
"            {                                       \\\r\n"
"                static int pcnt;                    \\\r\n"
"                if ( !pcnt )                        \\\r\n"
"                {                                   \\\r\n"
"                    pcnt = 1;                       \\\r\n"
"                    prom_cnt += ( _MAC_P * ( x ) ); \\\r\n"
"                }                                   \\\r\n"
"            }                                       \\\r\n"
"        }                                           \\\r\n"
"    }\r\n"
"#define MOVE( x )                                    \\\r\n"
"    {                                                \\\r\n"
"        {                                            \\\r\n"
"            ops_cnt += ( _MOVE_C * ( x ) );          \\\r\n"
"            inst_cnt[_MOVE] += ( x );                \\\r\n"
"            {                                        \\\r\n"
"                static int pcnt;                     \\\r\n"
"                if ( !pcnt )                         \\\r\n"
"                {                                    \\\r\n"
"                    pcnt = 1;                        \\\r\n"
"                    prom_cnt += ( _MOVE_P * ( x ) ); \\\r\n"
"                }                                    \\\r\n"
"            }                                        \\\r\n"
"        }                                            \\\r\n"
"    }\r\n"
"#define STORE( x )                                    \\\r\n"
"    {                                                 \\\r\n"
"        {                                             \\\r\n"
"            ops_cnt += ( _STORE_C * ( x ) );          \\\r\n"
"            inst_cnt[_STORE] += ( x );                \\\r\n"
"            {                                         \\\r\n"
"                static int pcnt;                      \\\r\n"
"                if ( !pcnt )                          \\\r\n"
"                {                                     \\\r\n"
"                    pcnt = 1;                         \\\r\n"
"                    prom_cnt += ( _STORE_P * ( x ) ); \\\r\n"
"                }                                     \\\r\n"
"            }                                         \\\r\n"
"        }                                             \\\r\n"
"    }\r\n"
"#define LOGIC( x )                                    \\\r\n"
"    {                                                 \\\r\n"
"        {                                             \\\r\n"
"            ops_cnt += ( _LOGIC_C * ( x ) );          \\\r\n"
"            inst_cnt[_LOGIC] += ( x );                \\\r\n"
"            {                                         \\\r\n"
"                static int pcnt;                      \\\r\n"
"                if ( !pcnt )                          \\\r\n"
"                {                                     \\\r\n"
"                    pcnt = 1;                         \\\r\n"
"                    prom_cnt += ( _LOGIC_P * ( x ) ); \\\r\n"
"                }                                     \\\r\n"
"            }                                         \\\r\n"
"        }                                             \\\r\n"
"    }\r\n"
"#define SHIFT( x )                                    \\\r\n"
"    {                                                 \\\r\n"
"        {                                             \\\r\n"
"            ops_cnt += ( _SHIFT_C * ( x ) );          \\\r\n"
"            inst_cnt[_SHIFT] += ( x );                \\\r\n"
"            {                                         \\\r\n"
"                static int pcnt;                      \\\r\n"
"                if ( !pcnt )                          \\\r\n"
"                {                                     \\\r\n"
"                    pcnt = 1;                         \\\r\n"
"                    prom_cnt += ( _SHIFT_P * ( x ) ); \\\r\n"
"                }                                     \\\r\n"
"            }                                         \\\r\n"
"        }                                             \\\r\n"
"    }\r\n"
"#define BRANCH( x )                                    \\\r\n"
"    {                                                  \\\r\n"
"        {                                              \\\r\n"
"            ops_cnt += ( _BRANCH_C * ( x ) );          \\\r\n"
"            inst_cnt[_BRANCH] += ( x );                \\\r\n"
"            {                                          \\\r\n"
"                static int pcnt;                       \\\r\n"
"                if ( !pcnt )                           \\\r\n"
"                {                                      \\\r\n"
"                    pcnt = 1;                          \\\r\n"
"                    prom_cnt += ( _BRANCH_P * ( x ) ); \\\r\n"
"                }                                      \\\r\n"
"            }                                          \\\r\n"
"        }                                              \\\r\n"
"    }\r\n"
"#define DIV( x )                                    \\\r\n"
"    {                                               \\\r\n"
"        {                                           \\\r\n"
"            ops_cnt += ( _DIV_C * ( x ) );          \\\r\n"
"            inst_cnt[_DIV] += ( x );                \\\r\n"
"            {                                       \\\r\n"
"                static int pcnt;                    \\\r\n"
"                if ( !pcnt )                        \\\r\n"
"                {                                   \\\r\n"
"                    pcnt = 1;                       \\\r\n"
"                    prom_cnt += ( _DIV_P * ( x ) ); \\\r\n"
"                }                                   \\\r\n"
"            }                                       \\\r\n"
"        }                                           \\\r\n"
"    }\r\n"
"#define SQRT( x )                                    \\\r\n"
"    {                                                \\\r\n"
"        {                                            \\\r\n"
"            ops_cnt += ( _SQRT_C * ( x ) );          \\\r\n"
"            inst_cnt[_SQRT] += ( x );                \\\r\n"
"            {                                        \\\r\n"
"                static int pcnt;                     \\\r\n"
"                if ( !pcnt )                         \\\r\n"
"                {                                    \\\r\n"
"                    pcnt = 1;                        \\\r\n"
"                    prom_cnt += ( _SQRT_P * ( x ) ); \\\r\n"
"                }                                    \\\r\n"
"            }                                        \\\r\n"
"        }                                            \\\r\n"
"    }\r\n"
"#define TRANS( x )                                    \\\r\n"
"    {                                                 \\\r\n"
"        {                                             \\\r\n"
"            ops_cnt += ( _TRANS_C * ( x ) );          \\\r\n"
"            inst_cnt[_TRANS] += ( x );                \\\r\n"
"            {                                         \\\r\n"
"                static int pcnt;                      \\\r\n"
"                if ( !pcnt )                          \\\r\n"
"                {                                     \\\r\n"
"                    pcnt = 1;                         \\\r\n"
"                    prom_cnt += ( _TRANS_P * ( x ) ); \\\r\n"
"                }                                     \\\r\n"
"            }                                         \\\r\n"
"        }                                             \\\r\n"
"    }\r\n"
"#define LOOP( x )                                    \\\r\n"
"    {                                                \\\r\n"
"        {                                            \\\r\n"
"            ops_cnt += ( _LOOP_C * ( x ) );          \\\r\n"
"            inst_cnt[_LOOP] += ( x );                \\\r\n"
"            {                                        \\\r\n"
"                static int pcnt;                     \\\r\n"
"                if ( !pcnt )                         \\\r\n"
"                {                                    \\\r\n"
"                    pcnt = 1;                        \\\r\n"
"                    prom_cnt += ( _LOOP_P * ( x ) ); \\\r\n"
"                }                                    \\\r\n"
"            }                                        \\\r\n"
"        }                                            \\\r\n"
"    }\r\n"
"#define INDIRECT( x )                                    \\\r\n"
"    {                                                    \\\r\n"
"        {                                                \\\r\n"
"            ops_cnt += ( _INDIRECT_C * ( x ) );          \\\r\n"
"            inst_cnt[_INDIRECT] += ( x );                \\\r\n"
"            {                                            \\\r\n"
"                static int pcnt;                         \\\r\n"
"                if ( !pcnt )                             \\\r\n"
"                {                                        \\\r\n"
"                    pcnt = 1;                            \\\r\n"
"                    prom_cnt += ( _INDIRECT_P * ( x ) ); \\\r\n"
"                }                                        \\\r\n"
"            }                                            \\\r\n"
"        }                                                \\\r\n"
"    }\r\n"
"#define PTR_INIT( x )                                    \\\r\n"
"    {                                                    \\\r\n"
"        {                                                \\\r\n"
"            ops_cnt += ( _PTR_INIT_C * ( x ) );          \\\r\n"
"            inst_cnt[_PTR_INIT] += ( x );                \\\r\n"
"            {                                            \\\r\n"
"                static int pcnt;                         \\\r\n"
"                if ( !pcnt )                             \\\r\n"
"                {                                        \\\r\n"
"                    pcnt = 1;                            \\\r\n"
"                    prom_cnt += ( _PTR_INIT_P * ( x ) ); \\\r\n"
"                }                                        \\\r\n"
"            }                                            \\\r\n"
"        }                                                \\\r\n"
"    }\r\n"
"#define TEST( x )                                    \\\r\n"
"    {                                                \\\r\n"
"        {                                            \\\r\n"
"            ops_cnt += ( _TEST_C * ( x ) );          \\\r\n"
"            inst_cnt[_TEST] += ( x );                \\\r\n"
"            {                                        \\\r\n"
"                static int pcnt;                     \\\r\n"
"                if ( !pcnt )                         \\\r\n"
"                {                                    \\\r\n"
"                    pcnt = 1;                        \\\r\n"
"                    prom_cnt += ( _TEST_P * ( x ) ); \\\r\n"
"                }                                    \\\r\n"
"            }                                        \\\r\n"
"        }                                            \\\r\n"
"    }\r\n"
"#define POWER( x )                                    \\\r\n"
"    {                                                 \\\r\n"
"        {                                             \\\r\n"
"            ops_cnt += ( _POWER_C * ( x ) );          \\\r\n"
"            inst_cnt[_POWER] += ( x );                \\\r\n"
"            {                                         \\\r\n"
"                static int pcnt;                      \\\r\n"
"                if ( !pcnt )                          \\\r\n"
"                {                                     \\\r\n"
"                    pcnt = 1;                         \\\r\n"
"                    prom_cnt += ( _POWER_P * ( x ) ); \\\r\n"
"                }                                     \\\r\n"
"            }                                         \\\r\n"
"        }                                             \\\r\n"
"    }\r\n"
"#define LOG( x )                                    \\\r\n"
"    {                                               \\\r\n"
"        {                                           \\\r\n"
"            ops_cnt += ( _LOG_C * ( x ) );          \\\r\n"
"            inst_cnt[_LOG] += ( x );                \\\r\n"
"            {                                       \\\r\n"
"                static int pcnt;                    \\\r\n"
"                if ( !pcnt )                        \\\r\n"
"                {                                   \\\r\n"
"                    pcnt = 1;                       \\\r\n"
"                    prom_cnt += ( _LOG_P * ( x ) ); \\\r\n"
"                }                                   \\\r\n"
"            }                                       \\\r\n"
"        }                                           \\\r\n"
"    }\r\n"
"#define MISC( x )                                    \\\r\n"
"    {                                                \\\r\n"
"        {                                            \\\r\n"
"            ops_cnt += ( _MISC_C * ( x ) );          \\\r\n"
"            inst_cnt[_MISC] += ( x );                \\\r\n"
"            {                                        \\\r\n"
"                static int pcnt;                     \\\r\n"
"                if ( !pcnt )                         \\\r\n"
"                {                                    \\\r\n"
"                    pcnt = 1;                        \\\r\n"
"                    prom_cnt += ( _MISC_P * ( x ) ); \\\r\n"
"                }                                    \\\r\n"
"            }                                        \\\r\n"
"        }                                            \\\r\n"
"    }\r\n"
"\r\n"
"#define FUNC( x )                                              \\\r\n"
"    {                                                          \\\r\n"
"        {                                                      \\\r\n"
"            ops_cnt += ( _FUNC_C + _MOVE_C * ( x ) );          \\\r\n"
"            inst_cnt[_FUNC]++;                                 \\\r\n"
"            inst_cnt[_MOVE] += ( x );                          \\\r\n"
"            {                                                  \\\r\n"
"                static int pcnt;                               \\\r\n"
"                if ( !pcnt )                                   \\\r\n"
"                {                                              \\\r\n"
"                    pcnt = 1;                                  \\\r\n"
"                    prom_cnt += ( _FUNC_P + _MOVE_P * ( x ) ); \\\r\n"
"                }                                              \\\r\n"
"            }                                                  \\\r\n"
"        }                                                      \\\r\n"
"    }\r\n"
"\r\n"
"#define DADD( x )                                   \\\r\n"
"    {                                               \\\r\n"
"        {                                           \\\r\n"
"            ops_cnt += ( 2 * _ADD_C * ( x ) );      \\\r\n"
"            inst_cnt[_ADD] += ( x );                \\\r\n"
"            {                                       \\\r\n"
"                static int pcnt;                    \\\r\n"
"                if ( !pcnt )                        \\\r\n"
"                {                                   \\\r\n"
"                    pcnt = 1;                       \\\r\n"
"                    prom_cnt += ( _ADD_P * ( x ) ); \\\r\n"
"                }                                   \\\r\n"
"            }                                       \\\r\n"
"        }                                           \\\r\n"
"    }\r\n"
"#define DMULT( x )                                   \\\r\n"
"    {                                                \\\r\n"
"        {                                            \\\r\n"
"            ops_cnt += ( 2 * _MULT_C * ( x ) );      \\\r\n"
"            inst_cnt[_MULT] += ( x );                \\\r\n"
"            {                                        \\\r\n"
"                static int pcnt;                     \\\r\n"
"                if ( !pcnt )                         \\\r\n"
"                {                                    \\\r\n"
"                    pcnt = 1;                        \\\r\n"
"                    prom_cnt += ( _MULT_P * ( x ) ); \\\r\n"
"                }                                    \\\r\n"
"            }                                        \\\r\n"
"        }                                            \\\r\n"
"    }\r\n"
"#define DMAC( x )                                   \\\r\n"
"    {                                               \\\r\n"
"        {                                           \\\r\n"
"            ops_cnt += ( 2 * _MAC_C * ( x ) );      \\\r\n"
"            inst_cnt[_MAC] += ( x );                \\\r\n"
"            {                                       \\\r\n"
"                static int pcnt;                    \\\r\n"
"                if ( !pcnt )                        \\\r\n"
"                {                                   \\\r\n"
"                    pcnt = 1;                       \\\r\n"
"                    prom_cnt += ( _MAC_P * ( x ) ); \\\r\n"
"                }                                   \\\r\n"
"            }                                       \\\r\n"
"        }                                           \\\r\n"
"    }\r\n"
"#define DMOVE( x )                                   \\\r\n"
"    {                                                \\\r\n"
"        {                                            \\\r\n"
"            ops_cnt += ( 2 * _MOVE_C * ( x ) );      \\\r\n"
"            inst_cnt[_MOVE] += ( x );                \\\r\n"
"            {                                        \\\r\n"
"                static int pcnt;                     \\\r\n"
"                if ( !pcnt )                         \\\r\n"
"                {                                    \\\r\n"
"                    pcnt = 1;                        \\\r\n"
"                    prom_cnt += ( _MOVE_P * ( x ) ); \\\r\n"
"                }                                    \\\r\n"
"            }                                        \\\r\n"
"        }                                            \\\r\n"
"    }\r\n"
"#define DSTORE( x )                                   \\\r\n"
"    {                                                 \\\r\n"
"        {                                             \\\r\n"
"            ops_cnt += ( 2 * _STORE_C * ( x ) );      \\\r\n"
"            inst_cnt[_STORE] += ( x );                \\\r\n"
"            {                                         \\\r\n"
"                static int pcnt;                      \\\r\n"
"                if ( !pcnt )                          \\\r\n"
"                {                                     \\\r\n"
"                    pcnt = 1;                         \\\r\n"
"                    prom_cnt += ( _STORE_P * ( x ) ); \\\r\n"
"                }                                     \\\r\n"
"            }                                         \\\r\n"
"        }                                             \\\r\n"
"    }\r\n"
"#define DLOGIC( x )                                   \\\r\n"
"    {                                                 \\\r\n"
"        {                                             \\\r\n"
"            ops_cnt += ( 2 * _LOGIC_C * ( x ) );      \\\r\n"
"            inst_cnt[_LOGIC] += ( x );                \\\r\n"
"            {                                         \\\r\n"
"                static int pcnt;                      \\\r\n"
"                if ( !pcnt )                          \\\r\n"
"                {                                     \\\r\n"
"                    pcnt = 1;                         \\\r\n"
"                    prom_cnt += ( _LOGIC_P * ( x ) ); \\\r\n"
"                }                                     \\\r\n"
"            }                                         \\\r\n"
"        }                                             \\\r\n"
"    }\r\n"
"#define DSHIFT( x )                                   \\\r\n"
"    {                                                 \\\r\n"
"        {                                             \\\r\n"
"            ops_cnt += ( 2 * _SHIFT_C * ( x ) );      \\\r\n"
"            inst_cnt[_SHIFT] += ( x );                \\\r\n"
"            {                                         \\\r\n"
"                static int pcnt;                      \\\r\n"
"                if ( !pcnt )                          \\\r\n"
"                {                                     \\\r\n"
"                    pcnt = 1;                         \\\r\n"
"                    prom_cnt += ( _SHIFT_P * ( x ) ); \\\r\n"
"                }                                     \\\r\n"
"            }                                         \\\r\n"
"        }                                             \\\r\n"
"    }\r\n"
"#define DDIV( x )                                   \\\r\n"
"    {                                               \\\r\n"
"        {                                           \\\r\n"
"            ops_cnt += ( 2 * _DIV_C * ( x ) );      \\\r\n"
"            inst_cnt[_DIV] += ( x );                \\\r\n"
"            {                                       \\\r\n"
"                static int pcnt;                    \\\r\n"
"                if ( !pcnt )                        \\\r\n"
"                {                                   \\\r\n"
"                    pcnt = 1;                       \\\r\n"
"                    prom_cnt += ( _DIV_P * ( x ) ); \\\r\n"
"                }                                   \\\r\n"
"            }                                       \\\r\n"
"        }                                           \\\r\n"
"    }\r\n"
"#define DSQRT( x )                                   \\\r\n"
"    {                                                \\\r\n"
"        {                                            \\\r\n"
"            ops_cnt += ( 2 * _SQRT_C * ( x ) );      \\\r\n"
"            inst_cnt[_SQRT] += ( x );                \\\r\n"
"            {                                        \\\r\n"
"                static int pcnt;                     \\\r\n"
"                if ( !pcnt )                         \\\r\n"
"                {                                    \\\r\n"
"                    pcnt = 1;                        \\\r\n"
"                    prom_cnt += ( _SQRT_P * ( x ) ); \\\r\n"
"                }                                    \\\r\n"
"            }                                        \\\r\n"
"        }                                            \\\r\n"
"    }\r\n"
"#define DTRANS( x )                                   \\\r\n"
"    {                                                 \\\r\n"
"        {                                             \\\r\n"
"            ops_cnt += ( 2 * _TRANS_C * ( x ) );      \\\r\n"
"            inst_cnt[_TRANS] += ( x );                \\\r\n"
"            {                                         \\\r\n"
"                static int pcnt;                      \\\r\n"
"                if ( !pcnt )                          \\\r\n"
"                {                                     \\\r\n"
"                    pcnt = 1;                         \\\r\n"
"                    prom_cnt += ( _TRANS_P * ( x ) ); \\\r\n"
"                }                                     \\\r\n"
"            }                                         \\\r\n"
"        }                                             \\\r\n"
"    }\r\n"
"\r\n"
"extern double ops_cnt;\r\n"
"extern double prom_cnt;\r\n"
"extern double inst_cnt[NUM_INST];\r\n"
"extern int ops_cnt_activ;\r\n"
"\r\n"
"void reset_wmops( void );\r\n"
"void push_wmops( const char *label );\r\n"
"void pop_wmops( void );\r\n"
"void update_wmops( void );\r\n"
"void update_mem( void );\r\n"
"void print_wmops( void );\r\n"
"\r\n"
"#else /* WMOPS counting disabled */\r\n"
"\r\n"
"#define reset_wmops()\r\n"
"extern int cntr_push_pop;\r\n"
"#define push_wmops( x ) ( cntr_push_pop++ )\r\n"
"#define pop_wmops()     ( cntr_push_pop-- )\r\n"
"#define update_wmops()  ( assert( cntr_push_pop == 0 ) )\r\n"
"#define update_mem()\r\n"
"#define print_wmops()\r\n"
"\r\n"
"#define ADD( x )\r\n"
"#define ABS( x )\r\n"
"#define MULT( x )\r\n"
"#define MAC( x )\r\n"
"#define MOVE( x )\r\n"
"#define STORE( x )\r\n"
"#define LOGIC( x )\r\n"
"#define SHIFT( x )\r\n"
"#define BRANCH( x )\r\n"
"#define DIV( x )\r\n"
"#define SQRT( x )\r\n"
"#define TRANS( x )\r\n"
"#define FUNC( x )\r\n"
"#define LOOP( x )\r\n"
"#define INDIRECT( x )\r\n"
"#define PTR_INIT( x )\r\n"
"#define TEST( x )\r\n"
"#define POWER( x )\r\n"
"#define LOG( x )\r\n"
"#define MISC( x )\r\n"
"\r\n"
"#define DADD( x )\r\n"
"#define DMULT( x )\r\n"
"#define DMAC( x )\r\n"
"#define DMOVE( x )\r\n"
"#define DSTORE( x )\r\n"
"#define DLOGIC( x )\r\n"
"#define DSHIFT( x )\r\n"
"#define DDIV( x )\r\n"
"#define DSQRT( x )\r\n"
"#define DTRANS( x )\r\n"
"\r\n"
"#endif\r\n"
"\r\n"
"/* mac & msu (Non Instrumented Versions) */\r\n"
"#ifndef mac\r\n"
"#define mac( a, b, c ) ( ( a ) + ( b ) * ( c ) )\r\n"
"#endif\r\n"
"#ifndef mac\r\n"
"#define msu( a, b, c ) ( ( a ) - ( b ) * ( c ) )\r\n"
"#endif\r\n"
"\r\n"
"#ifndef WMOPS\r\n"
"/* DESACTIVATE the Counting Mechanism */\r\n"
"#define OP_COUNT_( op, n )\r\n"
"\r\n"
"/* DESACTIVATE Operation Counter Wrappers */\r\n"
"#define OP_COUNT_WRAPPER1_( op, val ) ( val )\r\n"
"#define OP_COUNT_WRAPPER2_( expr )\r\n"
"#define OP_COUNT_WRAPPER3_( op, expr ) expr\r\n"
"\r\n"
"/* DESACTIVATE Logical & Ternary Operators */\r\n"
"#define __\r\n"
"#define _\r\n"
"\r\n"
"#else\r\n"
"\r\n"
"/* '*ops_cnt_ptr' is Used to Avoid: \"warning: operation on 'ops_cnt' may be undefined\" with Cygwin gcc Compiler */\r\n"
"static double *ops_cnt_ptr = &ops_cnt;\r\n"
"#define OP_COUNT_( op, x )            ( *ops_cnt_ptr += ( op##_C * ( x ) ), inst_cnt[op] += ( x ) )\r\n"
"\r\n"
"/******************************************************************/\r\n"
"/* NOTES:                                                         */\r\n"
"/*   The 'wmc_flag_' flag is global to avoid declaration in every */\r\n"
"/*   function and 'static' to avoid clashing with other modules   */\r\n"
"/*   that include this header file.                               */\r\n"
"/*                                                                */\r\n"
"/*   The declarations of 'wmc_flag_' and 'wops_' in this header   */\r\n"
"/*   file prevent the addition of a 'C' file to the Project.      */\r\n"
"/******************************************************************/\r\n"
"\r\n"
"/* General Purpose Global Flag */\r\n"
"static int wmc_flag_ = 0;\r\n"
"\r\n"
"/* Operation Counter Wrappers */\r\n"
"#define OP_COUNT_WRAPPER1_( op, val ) ( op, val )\r\n"
"#define OP_COUNT_WRAPPER2_( expr ) \\\r\n"
"    if ( expr, 0 )                 \\\r\n"
"        ;                          \\\r\n"
"    else\r\n"
"#define OP_COUNT_WRAPPER3_( op, expr ) \\\r\n"
"    if ( op, 0 )                       \\\r\n"
"        ;                              \\\r\n"
"    else                               \\\r\n"
"        expr\r\n"
"\r\n"
"#endif\r\n"
"\r\n"
"/* Define all Macros without '{' & '}' (None of these should be called externally!) */\r\n"
"#define ABS_( x )      OP_COUNT_( _ABS, ( x ) / WMOPS_BOOST_FAC )\r\n"
"#define ADD_( x )      OP_COUNT_( _ADD, ( x ) / WMOPS_BOOST_FAC )\r\n"
"#define MULT_( x )     OP_COUNT_( _MULT, ( x ) / WMOPS_BOOST_FAC )\r\n"
"#define MAC_( x )      OP_COUNT_( _MAC, ( x ) / WMOPS_BOOST_FAC )\r\n"
"#define MOVE_( x )     OP_COUNT_( _MOVE, ( x ) / WMOPS_BOOST_FAC )\r\n"
"#define STORE_( x )    OP_COUNT_( _STORE, ( x ) / WMOPS_BOOST_FAC )\r\n"
"#define LOGIC_( x )    OP_COUNT_( _LOGIC, ( x ) / WMOPS_BOOST_FAC )\r\n"
"#define SHIFT_( x )    OP_COUNT_( _SHIFT, ( x ) / WMOPS_BOOST_FAC )\r\n"
"#define BRANCH_( x )   OP_COUNT_( _BRANCH, ( x ) / WMOPS_BOOST_FAC )\r\n"
"#define DIV_( x )      OP_COUNT_( _DIV, ( x ) / WMOPS_BOOST_FAC )\r\n"
"#define SQRT_( x )     OP_COUNT_( _SQRT, ( x ) / WMOPS_BOOST_FAC )\r\n"
"#define TRANS_( x )    OP_COUNT_( _TRANS, ( x ) / WMOPS_BOOST_FAC )\r\n"
"#define POWER_( x )    TRANS_( x )\r\n"
"#define LOG_( x )      TRANS_( x )\r\n"
"#define LOOP_( x )     OP_COUNT_( _LOOP, ( x ) / WMOPS_BOOST_FAC )\r\n"
"#define INDIRECT_( x ) OP_COUNT_( _INDIRECT, ( x ) / WMOPS_BOOST_FAC )\r\n"
"#define PTR_INIT_( x ) OP_COUNT_( _PTR_INIT, ( x ) / WMOPS_BOOST_FAC )\r\n"
"#define FUNC_( x )     ( OP_COUNT_( _MOVE, ( x ) / WMOPS_BOOST_FAC ), OP_COUNT_( _FUNC, 1 ) )\r\n"
"#define MISC_( x )     ABS_( x )\r\n"
"\r\n"
"/* Math Operations */\r\n"
"#define abs_   OP_COUNT_WRAPPER1_( ABS_( 1 ), abs )\r\n"
"#define fabs_  OP_COUNT_WRAPPER1_( ABS_( 1 ), fabs )\r\n"
"#define labs_  OP_COUNT_WRAPPER1_( ABS_( 1 ), labs )\r\n"
"#define floor_ OP_COUNT_WRAPPER1_( MISC_( 1 ), floor )\r\n"
"#define sqrt_  OP_COUNT_WRAPPER1_( SQRT_( 1 ), sqrt )\r\n"
"#define pow_   OP_COUNT_WRAPPER1_( POWER_( 1 ), pow )\r\n"
"#define exp_   OP_COUNT_WRAPPER1_( POWER_( 1 ), exp )\r\n"
"#define log_   OP_COUNT_WRAPPER1_( LOG_( 1 ), log )\r\n"
"#define log10_ OP_COUNT_WRAPPER1_( LOG_( 1 ), log10 )\r\n"
"#define cos_   OP_COUNT_WRAPPER1_( TRANS_( 1 ), cos )\r\n"
"#define sin_   OP_COUNT_WRAPPER1_( TRANS_( 1 ), sin )\r\n"
"#define tan_   OP_COUNT_WRAPPER1_( TRANS_( 1 ), tan )\r\n"
"#define acos_  OP_COUNT_WRAPPER1_( TRANS_( 1 ), acos )\r\n"
"#define asin_  OP_COUNT_WRAPPER1_( TRANS_( 1 ), asin )\r\n"
"#define atan_  OP_COUNT_WRAPPER1_( TRANS_( 1 ), atan )\r\n"
"#define atan2_ OP_COUNT_WRAPPER1_( TRANS_( 1 ), atan2 )\r\n"
"#define cosh_  OP_COUNT_WRAPPER1_( TRANS_( 1 ), cosh )\r\n"
"#define sinh_  OP_COUNT_WRAPPER1_( TRANS_( 1 ), sinh )\r\n"
"#define tanh_  OP_COUNT_WRAPPER1_( TRANS_( 1 ), tanh )\r\n"
"#define fmod_  OP_COUNT_WRAPPER1_( DIV_( 1 ), fmod )\r\n"
"/* these macros use any local macros already defined */\r\n"
"/* min/max and their Variants */\r\n"
"#define min_( a, b ) OP_COUNT_WRAPPER1_( MISC_( 1 ), min( ( a ), ( b ) ) )\r\n"
"#define max_( a, b ) OP_COUNT_WRAPPER1_( MISC_( 1 ), max( ( a ), ( b ) ) )\r\n"
"#define MIN_( a, b ) OP_COUNT_WRAPPER1_( MISC_( 1 ), MIN( ( a ), ( b ) ) )\r\n"
"#define MAX_( a, b ) OP_COUNT_WRAPPER1_( MISC_( 1 ), MAX( ( a ), ( b ) ) )\r\n"
"#define Min_( a, b ) OP_COUNT_WRAPPER1_( MISC_( 1 ), Min( ( a ), ( b ) ) )\r\n"
"#define Max_( a, b ) OP_COUNT_WRAPPER1_( MISC_( 1 ), Max( ( a ), ( b ) ) )\r\n"
"/* Square and its Variants */\r\n"
"#define sqr_( x )    OP_COUNT_WRAPPER1_( MULT_( 1 ), sqr( ( x ) ) )\r\n"
"#define Sqr_( x )    OP_COUNT_WRAPPER1_( MULT_( 1 ), Sqr( ( x ) ) )\r\n"
"#define SQR_( x )    OP_COUNT_WRAPPER1_( MULT_( 1 ), SQR( ( x ) ) )\r\n"
"#define square_( x ) OP_COUNT_WRAPPER1_( MULT_( 1 ), square( ( x ) ) )\r\n"
"#define Square_( x ) OP_COUNT_WRAPPER1_( MULT_( 1 ), Square( ( x ) ) )\r\n"
"#define SQUARE_( x ) OP_COUNT_WRAPPER1_( MULT_( 1 ), SQUARE( ( x ) ) )\r\n"
"/* Sign and its Variants */\r\n"
"#define sign_( x ) OP_COUNT_WRAPPER1_( MOVE_( 1 ), sign( ( x ) ) )\r\n"
"#define Sign_( x ) OP_COUNT_WRAPPER1_( MOVE_( 1 ), Sign( ( x ) ) )\r\n"
"#define SIGN_( x ) OP_COUNT_WRAPPER1_( MOVE_( 1 ), SIGN( ( x ) ) )\r\n"
"/* Square Root and its Variants */\r\n"
"#define sqrtf_( x ) OP_COUNT_WRAPPER1_( SQRT_( 1 ), sqrtf( ( x ) ) )\r\n"
"/* Invert Square Root and its Variants */\r\n"
"#define inv_sqrt_( x ) OP_COUNT_WRAPPER1_( SQRT_( 1 ), inv_sqrt( ( x ) ) )\r\n"
"/* Others */\r\n"
"#define log_base_2_( x ) OP_COUNT_WRAPPER1_( ( LOG_( 1 ), MULT_( 1 ) ), log_base_2( ( x ) ) )\r\n"
"#define log2_f_( x )     OP_COUNT_WRAPPER1_( ( LOG_( 1 ), MULT_( 1 ) ), log2_f( ( x ) ) )\r\n"
"/* The 'wmc_flag_=wmc_flag_' is Used to Avoid: \"warning: left-hand operand of comma expression has no effect\"\r\n"
"   with Cygwin gcc Compiler */\r\n"
"#define _round_( x )  OP_COUNT_WRAPPER1_( wmc_flag_ = wmc_flag_, _round( ( x ) ) )\r\n"
"#define round_f_( x ) OP_COUNT_WRAPPER1_( wmc_flag_ = wmc_flag_, round_f( ( x ) ) )\r\n"
"#define _squant_( x ) OP_COUNT_WRAPPER1_( wmc_flag_ = wmc_flag_, _squant( ( x ) ) )\r\n"
"/* Set Min/Max */\r\n"
"#define set_min_( a, b ) OP_COUNT_WRAPPER3_( ( ADD_( 1 ), BRANCH_( 1 ), MOVE_( 1 ) ), set_min( ( a ), ( b ) ) )\r\n"
"#define set_max_( a, b ) OP_COUNT_WRAPPER3_( ( ADD_( 1 ), BRANCH_( 1 ), MOVE_( 1 ) ), set_max( ( a ), ( b ) ) )\r\n"
"/* mac & msu (Instrumented Versions) */\r\n"
"#define mac_( a, b, c ) OP_COUNT_WRAPPER1_( MAC_( 1 ), mac( a, b, c ) )\r\n"
"#define msu_( a, b, c ) OP_COUNT_WRAPPER1_( MAC_( 1 ), msu( a, b, c ) )\r\n"
"\r\n"
"/* Functions */\r\n"
"#define func_( name, x ) OP_COUNT_WRAPPER1_( FUNC_( x ), name )\r\n"
"\r\n"
"/* Logical Operators */\r\n"
"#ifndef __\r\n"
"#define __ ( BRANCH_( 1 ), 1 ) &&\r\n"
"#endif\r\n"
"\r\n"
"/* Ternary Operators (? and :) */\r\n"
"#ifndef _\r\n"
"#define _ ( BRANCH_( 1 ), 0 ) ? 0:\r\n"
"#endif\r\n"
"\r\n"
"/* Flow Control keywords */\r\n"
"#define if_                            \\\r\n"
"    OP_COUNT_WRAPPER2_( BRANCH_( 1 ) ) \\\r\n"
"    if\r\n"
"#define for_    OP_COUNT_WRAPPER2_(  LOOP_(1)) for\r\n"
"#define while_( c ) \\\r\n"
"    while           \\\r\n"
"    OP_COUNT_WRAPPER1_( BRANCH_( 1 ), ( c ) ) /* needs extra \"()\" if ',' encountered */\r\n"
"#define do_ \\\r\n"
"    do      \\\r\n"
"    {\r\n"
"#define _while    \\\r\n"
"    BRANCH_( 1 ); \\\r\n"
"    }             \\\r\n"
"    while\r\n"
"\r\n"
"#define goto_                          \\\r\n"
"    OP_COUNT_WRAPPER2_( BRANCH_( 1 ) ) \\\r\n"
"    goto\r\n"
"#define break_                         \\\r\n"
"    OP_COUNT_WRAPPER2_( BRANCH_( 1 ) ) \\\r\n"
"    break\r\n"
"#define continue_                      \\\r\n"
"    OP_COUNT_WRAPPER2_( BRANCH_( 1 ) ) \\\r\n"
"    continue\r\n"
"#define return_                                                                     \\\r\n"
"    OP_COUNT_WRAPPER2_( ( wmc_flag_ = stack_tree_level_, STACK_DEPTH_FCT_RETURN ) ) \\\r\n"
"    return\r\n"
"\r\n"
"#define switch_                                           \\\r\n"
"    OP_COUNT_WRAPPER2_( ( BRANCH_( 1 ), wmc_flag_ = 1 ) ) \\\r\n"
"    switch\r\n"
"#define cost_( n ) OP_COUNT_WRAPPER2_( wmc_flag_ ? ( ADD_( n ), BRANCH_( n ), wmc_flag_ = 0 ) : 0 );\r\n"
"\r\n"
"#ifdef WMOPS\r\n"
"\r\n"
"#define ACC 2\r\n"
"#define MUL 1\r\n"
"\r\n"
"/* Counting Function (should not be called externally!) */\r\n"
"static void wops_( const char *ops )\r\n"
"{\r\n"
"    char lm = 0;        /* lm: Last Operation is Math */\r\n"
"    static char lo = 0; /* Last Operation */\r\n"
"\r\n"
"    void ( *fct )( const char *ops ) = wops_;\r\n"
"\r\n"
"st:\r\n"
"    while ( *ops != '\\0' )\r\n"
"    {\r\n"
"        switch ( *ops++ )\r\n"
"        {\r\n"
"            int cnt;\r\n"
"            case '-':\r\n"
"                for ( cnt = 0; ops[cnt] == '>'; cnt++ )\r\n"
"                    ;\r\n"
"                if ( cnt & 1 )\r\n"
"                    goto ind;\r\n"
"            case '+':\r\n"
"                lm = 2;\r\n"
"                if ( lo & MUL )\r\n"
"                {\r\n"
"                    MULT_( -1 );\r\n"
"                    MAC_( 1 );\r\n"
"                    break;\r\n"
"                }\r\n"
"                lo = ACC << 2;\r\n"
"            case 'U':\r\n"
"            case 'D':\r\n"
"                ADD_( 1 );\r\n"
"                break;\r\n"
"            case '*':\r\n"
"                lm = 2;\r\n"
"                if ( lo & ACC )\r\n"
"                {\r\n"
"                    ADD_( -1 );\r\n"
"                    MAC_( 1 );\r\n"
"                    break;\r\n"
"                }\r\n"
"                lo = MUL << 2;\r\n"
"                MULT_( 1 );\r\n"
"                break;\r\n"
"            case '/':\r\n"
"            case '%':\r\n"
"                lm = 2;\r\n"
"                DIV_( 1 );\r\n"
"                break;\r\n"
"            case '&':\r\n"
"            case '|':\r\n"
"            case '^':\r\n"
"                lm = 2;\r\n"
"            case '~':\r\n"
"                LOGIC_( 1 );\r\n"
"                break;\r\n"
"            case '<':\r\n"
"            case '>':\r\n"
"                if ( *ops != ops[-1] )\r\n"
"                    goto error;\r\n"
"                ops++;\r\n"
"            case -85:\r\n"
"            case -69:\r\n"
"                lm = 2;\r\n"
"                SHIFT_( 1 );\r\n"
"                break;\r\n"
"            case 'L':\r\n"
"            case 'G':\r\n"
"                if ( *ops == 't' )\r\n"
"                    goto comp;\r\n"
"            case 'E':\r\n"
"            case 'N':\r\n"
"                if ( *ops != 'e' )\r\n"
"                    goto error;\r\n"
"            comp:\r\n"
"                ops++;\r\n"
"                ADD_( 1 );\r\n"
"                break;\r\n"
"            case '!':\r\n"
"                MISC_( 2 );\r\n"
"                break;\r\n"
"            case 'M':\r\n"
"                MOVE_( 1 );\r\n"
"                break;\r\n"
"            case 'S':\r\n"
"                STORE_( 1 );\r\n"
"                break;\r\n"
"            case 'P':\r\n"
"                PTR_INIT_( 1 );\r\n"
"                break;\r\n"
"            case '[':\r\n"
"            case ']':\r\n"
"                goto st;\r\n"
"            ind:\r\n"
"                ops++;\r\n"
"            case 'I':\r\n"
"            case '.':\r\n"
"                INDIRECT_( 1 );\r\n"
"                break;\r\n"
"            case '=':\r\n"
"                if ( lm )\r\n"
"                    goto st;\r\n"
"            case '\\0':\r\n"
"                /* This Shouldn't Happen */\r\n"
"                /* These are Used to Avoid: \"warning: 'name' defined but not used\" with Cygwin gcc Compiler */\r\n"
"                wmc_flag_ = wmc_flag_;\r\n"
"                ops_cnt_ptr = ops_cnt_ptr;\r\n"
"                fct( \"\" );\r\n"
"            error:\r\n"
"            default:\r\n"
"                fprintf( stderr, \"\\r wops: Invalid Counting Operation '%s'\\n\", ops - 1 );\r\n"
"                exit( -1 );\r\n"
"        }\r\n"
"        lm >>= 1;\r\n"
"        lo >>= 2;\r\n"
"    }\r\n"
"\r\n"
"    return;\r\n"
"}\r\n"
"\r\n"
"#endif\r\n"
"\r\n"
"/* All Other Operations */\r\n"
"#define $( str ) OP_COUNT_WRAPPER2_( wops_( str ) )\r\n"
"\r\n"
"\r\n"
"/*-------------------------------------------------------------------*\r\n"
" * Memory counting tool\r\n"
" *-------------------------------------------------------------------*/\r\n"
"\r\n"
"/* Enhanced Const Data Size Counting (Rounding Up to the Nearest 'Integer' Size) */\r\n"
"#define rsize( item ) ( ( sizeof( item ) + sizeof( int ) - 1 ) / sizeof( int ) * sizeof( int ) )\r\n"
"\r\n"
"#ifdef _MSC_VER\r\n"
"/* Disable \"warning C4210: nonstandard extension used : function given file scope\" with Visual Studio Compiler */\r\n"
"#pragma warning( disable : 4210 )\r\n"
"#endif\r\n"
"\r\n"
"/* Const Data Size and PROM Size Wrapper Functions */\r\n"
"#define Const_Data_Size_Func( file ) Const_Data_Size_##file( void )\r\n"
"#define Get_Const_Data_Size( file, val_ptr )       \\\r\n"
"    {                                              \\\r\n"
"        extern int Const_Data_Size_##file( void ); \\\r\n"
"        *( val_ptr ) = Const_Data_Size_##file();   \\\r\n"
"    }\r\n"
"#define PROM_Size_Func( file ) PROM_Size_##file( void )\r\n"
"#define Get_PROM_Size( file, val_ptr )     \\\r\n"
"    {                                      \\\r\n"
"        int PROM_Size_##file( void );      \\\r\n"
"        *( val_ptr ) = PROM_Size_##file(); \\\r\n"
"    }\r\n"
"\r\n"
"/* ROM Size Lookup Table - contains information about PROM size and Const Data Size in all source files */\r\n"
"/* The print_mem() function looks for this table to print the results of Const Data usage and PROM usage */\r\n"
"typedef struct ROM_Size_Lookup_Table\r\n"
"{\r\n"
"    const char file_spec[255];\r\n"
"    int PROM_size;\r\n"
"    int ( *Get_Const_Data_Size_Func )( void );\r\n"
"} ROM_Size_Lookup_Table;\r\n"
"\r\n"
"/* The WMC tool inserts the following declaration during the innstrumentation process in the .c file where the function print_mem() is located */\r\n"
"/* and modifies it to print_mem(Const_Data_PROM_Table) */\r\n"
"\r\n"
"/* #ifdef WMOPS\r\n"
" * ROM_Size_Lookup_Table Const_Data_PROM_Table[] =\r\n"
" * {\r\n"
" *   {\"../lib_enc/rom_enc.c\", 0, NULL},\r\n"
" *   {\"../lib_com/*.c\", 0, NULL},\r\n"
" *   {\"\", -1, NULL}\r\n"
" * };\r\n"
" * #endif\r\n"
" */\r\n"
"\r\n"
"/*#define MEM_ALIGN_64BITS */ /* Define this when using 64 Bits values in the code (ex: double), otherwise it will align on 32 Bits */\r\n"
"/*#define MEM_COUNT_DETAILS*/\r\n"
"\r\n"
"typedef enum\r\n"
"{\r\n"
"    USE_BYTES = 0,\r\n"
"    USE_16BITS = 1,\r\n"
"    USE_32BITS = 2\r\n"
"} Counting_Size;\r\n"
"\r\n"
"#if ( defined( _WIN32 ) && ( _MSC_VER <= 1800 ) && ( _MSC_VER >= 1300 ) )\r\n"
"#define __func__ __FUNCTION__\r\n"
"#elif defined( __STDC_VERSION__ ) && __STDC_VERSION__ < 199901L\r\n"
"#if ( __GNUC__ >= 2 )\r\n"
"#define __func__ __FUNCTION__\r\n"
"#else\r\n"
"#define __func__ \"<unknown>\"\r\n"
"#endif\r\n"
"#elif defined( __GNUC__ )\r\n"
"#define __func__ __extension__ __FUNCTION__\r\n"
"#endif\r\n"
"\r\n"
"\r\n"
"#ifdef WMOPS\r\n"
"\r\n"
"void *mem_alloc( const char *func_name, int func_lineno, size_t size, char *alloc_str );\r\n"
"void mem_free( const char *func_name, int func_lineno, void *ptr );\r\n"
"\r\n"
"#define malloc_( size )    mem_alloc( __func__, __LINE__, size, \"m:\" #size )\r\n"
"#define calloc_( n, size ) mem_alloc( __func__, __LINE__, ( n ) * ( size ), \"c:\" #n \", \" #size )\r\n"
"#define free_( ptr )       mem_free( __func__, __LINE__, ptr )\r\n"
"\r\n"
"void reset_mem( Counting_Size cnt_size );\r\n"
"void print_mem( ROM_Size_Lookup_Table Const_Data_PROM_Table[] );\r\n"
"\r\n"
"int push_stack( const char *filename, const char *fctname );\r\n"
"int pop_stack( const char *filename, const char *fctname );\r\n"
"\r\n"
"#ifdef WMOPS_DETAIL\r\n"
"#define STACK_DEPTH_FCT_CALL   ( push_wmops( __FUNCTION__ \" [WMC_AUTO]\" ), push_stack( __FILE__, __FUNCTION__ ) ) /* add push_wmops() in all function calls */\r\n"
"#define STACK_DEPTH_FCT_RETURN ( pop_wmops(), pop_stack( __FILE__, __FUNCTION__ ) )                 /* add pop_wmops() in all function returns */\r\n"
"#else\r\n"
"#define STACK_DEPTH_FCT_CALL   push_stack( __FILE__, __FUNCTION__ )\r\n"
"#define STACK_DEPTH_FCT_RETURN pop_stack( __FILE__, __FUNCTION__ )\r\n"
"#endif\r\n"
"\r\n"
"void reset_stack( void );\r\n"
"#define func_start_ int stack_tree_level_ = STACK_DEPTH_FCT_CALL;\r\n"
"\r\n"
"#else\r\n"
"#define malloc_( n1 )     malloc( n1 )\r\n"
"#define calloc_( n1, n2 ) calloc( n1, n2 )\r\n"
"#define free_( ptr )      free( ptr )\r\n"
"#define reset_mem( cnt_size )\r\n"
"#define print_mem( Const_Data_PROM_Table )\r\n"
"\r\n"
"#define push_stack( file, fct )\r\n"
"#define pop_stack( file, fct )\r\n"
"#define reset_stack()\r\n"
"#define func_start_\r\n"
"\r\n"
"#endif\r\n"
"\r\n"
"#endif /* WMOPS_H */\r\n"
"\r\n"