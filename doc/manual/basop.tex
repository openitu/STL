%=============================================================================
% ..... THIS IS chapter{BASOP: ITU-T Basic Operators } .....
% ... Revision:
% Nov.2000 - SG16 Plenary
% Apr.2005 - STL2005 revision -- Cyril Guillaumé & Stéphane Ragot - stephane.ragot@francetelecom.com
%                                Karim Djafarian - k-djafarian@ti.com
% Nov.2008 - STL2009 revision -- Yusuke Hiwasaki, Noboru Harada, NTT
%                             - Balazs Kovesi, Claude Lamblin, France Telecom
% Jun.2013 - STL2014 revision -- Yusuke Hiwasaki, NTT
%=============================================================================
\chapter{BASOP: ITU-T Basic Operators}
%=============================================================================

%\newcommand{\newop}{\ensuremath{\Rightarrow} \textsc{New in v2.0}}
\def\newop20{\begin{math} \rightarrow \textsc{New in v2.0} \end{math}}

%----------------------------------------------------------------------
\section{Overview of basic operator libraries}
%----------------------------------------------------------------------

Since the standardization of G.729 and G.723.1
\footnote{For older standards (G.711, G.726, G722, G.727, G.728), their C-codes are included in the software tools library.},
ANSI-C source codes constitute integral parts of the ITU-T speech and audio coding Recommendations and their specification relies on bit-exact fixed-point C code using library of basic operators that simulates DSP operations.
The fixed-point descriptions of G.723.1 and G.729 are based on 16- and 32-bit arithmetic operations defined by ETSI in 1993 for the standardisation of the half-rate GSM speech codec.
These operations are also used to define the GSM enhanced full-rate (EFR) and adaptive multi-rate (AMR) speech codecs \cite{G.191}.

In STL2005, the version 2.0 of the ITU-T Basic Operators bears the following additional features compared to the version 1.x:
\begin{enumerate}
    \item New 16-bit and 32-bit operators;
    \item New 40-bit operators;
    \item New control flow operators;
    \item Revised complexity weight of version 1.x basic operators in order to reflect the evolution of processor capabilities.
\end{enumerate}

In STL2009, that is version 2.3, in addition to some minor fixes in the ITU-T Basic Operators and guidelines of data move counters, the following new additional tools were added:
\begin{itemize}
    \item Program ROM estimation tool for fixed-point C Code;
    \item Complexity evaluation tool for floating-point C Code.
\end{itemize}

In STL2018, new operators were introduced to account for modern DSP architectures:
\begin{enumerate}
    \item Enhanced 32-bit operators;
    \item New unsigned 32-bit operators;
    \item New 64-bit operators;
    \item New complex operators;
    \item New control flow operators;
    \item Revised complexity weights in order to reflect the evolution of processor capabilities.
\end{enumerate}

%----------------------------------------------------------------------
\section{Description of the 16-bit and 32-bit basic operators and associated weights}
%----------------------------------------------------------------------

This section describes the different 16-bit and 32-bit basic operators available in the STL, and are organized by complexity (``weights'').
The complexity values to be considered (since the publication of the STL2005) are the ones related to the version 2.0 and subsequent versions of the module.
When the basic operator had a different complexity value in the previous version of the library(version 1.x), the previous complexity value is indicated for information.
When the basic operator did not exist in the previous version of the library (version 1.x), it is highlighted as follows:
\newop20 . In STL2009, {\tt round()} operator was renamed as {\tt round\_fx()} and {\tt saturate()}, function was made unaccessible from applications, because it was an internal procedure.

\subsection{Variable definitions}

The variables used in the operators are signed integers in 2's complements representation, defined by:

{\tt v1}, {\tt v2}: 16-bit variables\\
{\tt L\_v1}, {\tt L\_v2}, {\tt L\_v3}: 32-bit variables


%-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.
\subsection{Operators with complexity weight of 1}
\subsubsection{Arithmetic operators (multiplication excluded)}

%........................................................
\NewOperator{add(v1, v2)}

Performs the addition ({\tt v1}+{\tt v2}) with overflow control and saturation; the 16-bit result is set at {\tt +32767} when overflow occurs or at {\tt -32768} when underflow occurs.

%........................................................
\NewOperator{sub(v1, v2)}

Performs the subtraction ({\tt v1}-{\tt v2}) with overflow control and saturation; the 16-bit result is set at {\tt +32767} when overflow occurs or at {\tt -32768} when underflow occurs.

%........................................................
\NewOperator{abs\_s(v1)}

Absolute value of v1.
If {\tt v1} is {\tt -32768}, returns {\tt 32767}.

%........................................................
\NewOperator{shl(v1, v2)}

Arithmetically shift the 16-bit input {\tt v1} left {\tt v2} positions.
Zero fill the {\tt v2} LSB of the result.
If {\tt v2} is negative, arithmetically shift {\tt v1} right by {\tt -v2} with sign extension.
Saturate the result in case of underflows or overflows.

%........................................................
\NewOperator{shr(v1, v2)}

Arithmetically shift the 16-bit input {\tt v1} right {\tt v2} positions with sign extension.
If v2 is negative, arithemtically shift {\tt v1} left by {\tt -v2} and zero fill the {\tt -v2} LSB of the result:

\rulex{2mm}{\tt shr(v1, v2) = shl(v1, -v2)}

Saturate the result in case of underflows or overflows.

%........................................................
\NewOperator{negate(v1)}

Negate {\tt v1} with saturation, saturate in the case when input is {\tt -32768}:

\rulex{2mm}{\tt negate(v1) = sub(0, v1)}

%........................................................
\NewOperator{s\_max(v1, v2)} \newop20

Compares two 16-bit variables {\tt v1} and {\tt v2} and returns the maximum value.

%........................................................
\NewOperator{s\_min(v1, v2)} \newop20

Compares two 16-bit variables {\tt v1} and {\tt v2} and returns the minimum value.

%........................................................
\NewOperator{norm\_s(v1)}

Produces the number of left shifts needed to normalize the 16-bit
variable {\tt v1} for positive values on the interval with minimum
of {\tt 16384} and maximum {\tt 32767}, and for negative values on
the interval with minimum of {\tt -32768} and maximum of {\tt
-16384}; in order to normalise the result, the following operation
must be done:

\rulex{2mm}{\tt norm\_v1 = shl(v1, norm\_s(v1))}

\textbf{Note:} \hfill \pbox{145mm}{In v1.x, the complexity weight of this operator was 15.}

%........................................................
\NewOperator{L\_add(L\_v1, L\_v2)}

This operator implements 32-bit addition of the two 32-bit
variables ({\tt L\_v1}+{\tt L\_v2}) with overflow control and
saturation; the result is set at {\tt +2147483647} when overflow
occurs or at {\tt -2147483648} when underflow occurs.

\textbf{Note:} \hfill \pbox{145mm}{In v1.x, the complexity weight of this operator was  2.}

%........................................................
\NewOperator{L\_sub(L\_v1, L\_v2)}

32-bit subtraction of the two 32-bit variables ({\tt L\_v1}--{\tt
L\_v2}) with overflow control and saturation; the result is set at
{\tt +2147483647} when overflow occurs or at {\tt -2147483648}
when underflow occurs.

\textbf{Note:} \hfill \pbox{145mm}{In v1.x, the complexity weight of this operator was  2.}

%........................................................
\NewOperator{L\_abs(L\_v1)}

Absolute value of {\tt L\_v1}, with {\tt
L\_abs(-2147483648)=\-2147483647}.

\textbf{Note:} \hfill \pbox{145mm}{In v1.x, the complexity weight of this operator was  2.}

%........................................................
\NewOperator{L\_shl(L\_v1, v2)}

Arithmetically shift the 32-bit input {\tt L\_v1} left {\tt v2}
positions. Zero fill the {\tt v2} LSB of the result. If {\tt v2}
is negative, arithmetically shift {\tt L\_v1} right by {\tt -v2}
with sign extension. Saturate the result in case of underflows or
overflows.

\textbf{Note:} \hfill \pbox{145mm}{In v1.x, the complexity weight of this operator was  2.}

%........................................................
\NewOperator{L\_shr(L\_v1, v2)}

Arithmetically shift the 32-bit input {\tt L\_v1} right {\tt v2}
positions with sign extension. If {\tt v2} is negative,
arithemtically shift {\tt L\_v1} left by {\tt -v2} and zero fill
the {\tt -v2} LSB of the result. Saturate the result in case of
underflows or overflows.

\textbf{Note:} \hfill \pbox{145mm}{In v1.x, the complexity weight of this operator was  2.}

%........................................................
\NewOperator{L\_negate(L\_v1)}

Negate the 32-bit {\tt L\_v1} parameter with saturation, saturate in the
case where input is {\tt -2147483648}.

\textbf{Note:} \hfill \pbox{145mm}{In v1.x, the complexity weight of this operator was  2.}

%........................................................
\NewOperator{L\_max(L\_v1, L\_v2)} \newop20

Compares two 32-bit variables L\_v1 and L\_v2 and returns the
maximum value.

%........................................................
\NewOperator{L\_min(L\_v1, L\_v2)} \newop20

Compares two 32-bit variables L\_v1 and L\_v2 and returns the
minimum value.

%........................................................
\NewOperator{norm\_l(L\_v1)}

Produces the number of left shifts needed to normalise the 32-bit
variable {\tt L\_v1} for positive values on the interval with
minimum of {\tt 1073741824} and maximum {\tt 2147483647}, and for
negative values on the interval with minimum of {\tt -2147483648}
and maximum of {\tt -1073741824}; in order to normalise the
result, the following operation must be done:

\rulex{2mm}{\tt L\_norm\_v1 = L\_shl(L\_v1, norm\_l(L\_v1))}

\textbf{Note:} \hfill \pbox{145mm}{In v1.x, the complexity weight of this operator was  30.}

%------------------------------------------------------------------
\subsubsection{Multiplication operators}

%........................................................
\NewOperator{L\_mult(v1, v2)}

Operator {\tt L\_mult} implements the 32-bit result of the
multiplication of {\tt v1} times {\tt v2} with one shift left,
i.e.

\rulex{2mm}{\tt L\_mult(v1, v2) = L\_shl((v1 $\times$ v2), 1)}

Note that {\tt L\_mult(-32768,-32768) = 2147483647}.

%........................................................
\NewOperator{L\_mult0(v1, v2)}

Operator {\tt L\_mult0} implements the 32-bit result of the
multiplication of {\tt v1} times {\tt v2} {\em without} left
shift, i.e.

\rulex{2mm}{\tt L\_mult0(v1, v2) = (v1 $\times$ v2)}

%........................................................
\NewOperator{mult(v1, v2)}

Performs the multiplication of {\tt v1} by {\tt v2} and gives a 16-bit
result which is scaled, i.e.

\rulex{2mm}{\tt mult(v1, v2) =  extract\_l(L\_shr((v1 times v2),15))}

Note that {\tt mult(-32768,-32768) = 32767}.

%........................................................
\NewOperator{mult\_r(v1, v2)}

Same as {\tt mult()} but with rounding, i.e.

\rulex{2mm}{\tt mult\_r(v1, v2)
= extract\_l(L\_shr(((v1 $\times$ v2)+16384), 15))}

and {\tt mult\_r(-32768, -32768) = 32767}.

\textbf{Note:} \hfill \pbox{145mm}{In v1.x, the complexity weight of this operator was  2.}

%........................................................
\NewOperator{L\_mac(L\_v3, v1, v2)}

Multiply {\tt v1} by {\tt v2} and shift the result left by 1. Add the
32-bit result to {\tt L\_v3} with saturation, return a 32-bit result:

\rulex{2mm}{\tt L\_mac(L\_v3, v1, v2) = L\_add(L\_v3, L\_mult(v1, v2))}

%........................................................
\NewOperator{L\_mac0(L\_v3, v1, v2)}

Multiply {\tt v1} by {\tt v2} {\em without} left shift. Add the 32-bit
result to {\tt L\_v3} with saturation, returning a 32-bit result:

\rulex{2mm}{\tt L\_mac0(L\_v3, v1, v2) = L\_add(L\_v3, L\_mult0(v1,
v2))}

%........................................................
\NewOperator{L\_macNs(L\_v3, v1, v2)}

Multiply {\tt v1} by {\tt v2} and shift the result left by 1. Add the
32-bit result to {\tt L\_v3} without saturation, return a 32-bit
result. Generates carry and overflow values:

\rulex{2mm}{\tt L\_macNs(L\_v3, v1, v2) = L\_add\_c(L\_v3,
L\_mult(v1, v2))}

%........................................................
\NewOperator{mac\_r(L\_v3, v1, v2)}

Multiply {\tt v1} by {\tt v2} and shift the result left by 1. Add
the 32-bit result to {\tt L\_v3} with saturation. Round the 16
least significant bits of the result into the 16 most significant
bits with saturation and shift the result right by 16. Returns a
16-bit result.

\rulex{2mm}{\tt mac\_r(L\_v3, v1, v2) = \\
\rulex{5mm} round\_fx(L\_mac(L\_v3, v1, v2))=\\
\rulex{5mm} extract\_h(L\_add(L\_add(L\_v3, L\_mult(v1, v2)), 32768))}

\textbf{Note:} \hfill \pbox{145mm}{In v1.x, the complexity weight of this operator was  2.}

%........................................................
\NewOperator{L\_msu(L\_v3, v1, v2)}

Multiply {\tt v1} by {\tt v2} and shift the result left by 1. Subtract
the 32-bit result from {\tt L\_v3} with saturation, return a 32-bit
result:

\rulex{2mm}{\tt L\_msu(L\_v3, v1, v2) = L\_sub(L\_v3, L\_mult(v1, v2))}.

%........................................................
\NewOperator{L\_msu0(L\_v3, v1, v2)}

Multiply {\tt v1} by {\tt v2} {\em without} left shift. Subtract the
32-bit result from {\tt L\_v3} with saturation, returning a 32-bit
result:

\rulex{2mm}{\tt L\_msu0(L\_v3, v1, v2) = L\_sub(L\_v3, L\_mult0(v1,
v2))}.

%........................................................
\NewOperator{L\_msuNs(L\_v3, v1, v2)}

\textcolor{blue}{
%
Caution: The sub-routine {\tt L\_sub\_c} evoked from this function
is reported to have a carry problem. Use of this operator in current
and past release of STL is NOT recommended.
%
}

Multiply {\tt v1} by {\tt v2} and shift the result left by 1. Subtract
the 32-bit result from {\tt L\_v3} without saturation, return a 32-bit
result. Generates carry and overflow values:


\rulex{2mm}{\tt L\_msuNs(L\_v3, v1, v2) = L\_sub\_c(L\_v3, L\_mult(v1, v2))}

%........................................................
\NewOperator{msu\_r(L\_v3, v1, v2)}

Multiply {\tt v1} by {\tt v2} and shift the result left by 1.
Subtract the 32-bit result from {\tt L\_v3} with saturation. Round
the 16 least significant bits of the result into the 16 bits with
saturation and shift the result right by 16. Returns a 16-bit
result.

\ \\
\rulex{2mm}{\tt msu\_r(L\_v3, v1, v2) = \\
\rulex{5mm} round\_fx(L\_msu(L\_v3, v1, v2))= \\
\rulex{5mm} extract\_h(L\_add(L\_sub(L\_v3, L\_mult(v1, v2)), 32768))}

\textbf{Note:} \hfill \pbox{145mm}{In v1.x, the complexity weight of this operator was  2.}

\subsubsection{Logical operators}

%........................................................
\NewOperator{s\_and(v1, v2)} \newop20

Performs a bit wise AND between the two 16-bit variables v1 and
v2.

%........................................................
\NewOperator{s\_or(v1, v2)} \newop20

Performs a bit wise OR between the two 16-bit variables v1 and
v2.

%........................................................
\NewOperator{s\_xor(v1, v2)} \newop20

Performs a bit wise XOR between the two 16-bit variables v1 and
v2.

%........................................................
\NewOperator{lshl(v1, v2)} \newop20

Logically shifts left the 16-bit variable v1 by v2 positions:

\rulex{10mm} -- \pbox{150mm}{if v2 is negative, v1 is shifted to the least
significant bits by (-v2) positions with insertion of 0 at the
most significant bit.}

\rulex{10mm} -- \pbox{150mm}{if v2 is positive, v1 is shifted to the most
significant bits by (v2) positions without saturation control.}



%........................................................
\NewOperator{lshr(v1, v2)} \newop20

Logically shifts right the 16-bit variable v1 by v2 positions:

\rulex{10mm} -- \pbox{150mm}{if v2 is positive, v1 is shifted to the least
significant bits by (v2) positions with insertion of 0 at the most
significant bit.}

\rulex{10mm} -- \pbox{150mm}{if v2 is negative, v1 is shifted to the most
significant bits by (-v2) positions without saturation control.}


%........................................................
\NewOperator{L\_and(L\_v1, L\_v2)} \newop20

Performs a bit wise AND between the two 32-bit variables {\tt
L\_v1} and {\tt L\_v2}.


%........................................................
\NewOperator{L\_or(L\_v1, L\_v2)} \newop20

Performs a bit wise OR between the two 32-bit variables {\tt
L\_v1} and {\tt L\_v2}.


%........................................................
\NewOperator{L\_xor(L\_v1, L\_v2)} \newop20

Performs a bit wise XOR between the two 32-bit variables {\tt
L\_v1} and {\tt L\_v2}.


%........................................................
\NewOperator{L\_lshl(L\_v1, v2)} \newop20

Logically shifts left the 32-bit variable {\tt L\_v1} by v2 positions:

\rulex{10mm} -- \pbox{150mm}{if v2 is negative, {\tt L\_v1} is shifted
to the least significant bits by (-v2) positions with insertion of 0
at the most significant bit.}

\rulex{10mm} -- \pbox{150mm}{if v2 is positive, {\tt L\_v1} is shifted
to the most significant bits by (v2) positions without saturation
control.}


%........................................................
\NewOperator{L\_lshr(L\_v1, v2)} \newop20

Logically shifts right the 32-bit variable {\tt L\_v1} by v2
positions:

\rulex{10mm} -- \pbox{150mm}{if v2 is positive, {\tt L\_v1} is shifted
to the least significant bits by (v2) positions with insertion of 0 at
the most significant bit.}

\rulex{10mm} -- \pbox{150mm}{if v2 is negative, {\tt L\_v1} is shifted
to the most significant bits by (-v2) positions without saturation
control.}


\subsubsection{Data type conversion operators}

%........................................................
\NewOperator{extract\_h(L\_v1)}

Return the 16 MSB of {\tt L\_v1}.

%........................................................
\NewOperator{extract\_l(L\_v1)}

Return the 16 LSB of {\tt L\_v1}.

%........................................................
\NewOperator{round\_fx(L\_v1)}

Round the lower 16 bits of the 32-bit input number into the most
significant 16 bits with saturation. Shift the resulting bits
right by 16 and return the 16-bit number:

\rulex{2mm}{\tt round\_fx(L\_v1) = extract\_h(L\_add(L\_v1, 32768))}

Initially, this operator was named ``{\tt round()}'', however to avoid
the conflict with C standard libraries, this operator was renamed from
version 2.3. There are no functionality changes.

%........................................................
\NewOperator{L\_deposit\_h(v1)}

Deposit the 16-bit {\tt v1} into the 16 most significant bits
of the 32-bit output. The 16 least significant bits of the output
are zeroed.

\textbf{Note:} \hfill \pbox{145mm}{In v1.x, the complexity weight of this operator was  2.}

%........................................................
\NewOperator{L\_deposit\_l(v1)}

Deposit the 16-bit {\tt v1} into the 16 least significant bits
of the 32-bit output. The 16 most significant bits of the output
are sign-extended.

\textbf{Note:} \hfill \pbox{145mm}{In v1.x, the complexity weight of this operator was  2.}

%........................................................
\NewOperator{L\_sat(L\_v1)}

The 32-bit variable L\_v1 is set to {\tt 2147483647} if an overflow occurred, or {\tt -2147483648} if an underflow occurred, on the most recent {\tt L\_add\_c()}, {\tt L\_sub\_c()}, {\tt L\_macNs()} or {\tt L\_msuNs()} operations.
The carry and overflow values are binary variables which can be tested and assigned values.

\textbf{Note:} \hfill \pbox{145mm}{In v2.3, the complexity weight of this operator was  4. }


\subsection{Operators with complexity weight of 2}

%........................................................
\NewOperator{L\_add\_c(L\_v1, L\_v2)}

Performs the 32-bit addition with carry. No saturation. Generates
carry and overflow values. The carry and overflow values are
binary variables which can be tested and assigned values.

%........................................................
\ \\
\NewOperator{L\_sub\_c(L\_v1, L\_v2)}

\textcolor{blue}{
%
  Caution: This {\tt L\_sub\_c} operator is reported to have a carry problem.
  This problem has not been mended and volunteers are seeked to correct it.
  Use of this operator in current and past release of STL is NOT recommended.
%
}

Performs the 32-bit subtraction with carry (borrow). Generates
carry (borrow) and overflow values. No saturation. The carry and
overflow values are binary variables which can be tested and
assigned values.

%........................................................
\NewOperator{shr\_r(v1, v2)}

Same as {\tt shr()} but with rounding. Saturate the result in case
of underflows or overflows.

{\tt
\rulex{2mm} if (v2$>$0) then\\
\rulex{4mm} if (sub(shl(shr(v1,v2),1), shr(v1,sub(v2,1)))==0) \\
\rulex{4mm} then shr\_r(v1, v2) = shr(v1, v2)\\
\rulex{4mm} else shr\_r(v1, v2) = add(shr(v1, v2), 1)

\rulex{2mm} else if (v2 $\leq$ 0) \\
\rulex{4mm} then shr\_r(v1, v2) = shr(v1, v2)}

\textcolor{purple} {
\textbf{Note:} \hfill \pbox{145mm}{In v2.3, the complexity weight of this operator was  3.}
}

%........................................................
\NewOperator{L\_shr\_r(L\_v1, v2)}


Same as {\tt L\_shr(v1,v2)} but with rounding. Saturate the result
in case of underflows or overflows:

{\tt
\rulex{2mm} if (v2 $>$ 0) then\\
\rulex{4mm} if (L\_sub(L\_shl(L\_shr(L\_v1,v2),1), L\_shr(L\_v1, sub(v2,1)))) == 0 \\
\rulex{4mm} then L\_shr\_r(L\_v1, v2) = L\_shr(L\_v1, v2)\\
\rulex{4mm} else L\_shr\_r(L\_v1, v2) = L\_add(L\_shr(L\_v1, v2), 1)

\rulex{2mm} if (v2 $\leq$ 0) \\
\rulex{4mm} then L\_shr\_r(L\_v1, v2) = L\_shr(L\_v1, v2)}

\textbf{Note:} \hfill \pbox{145mm}{In v2.3, the complexity weight of this operator was  3.}


\subsection{Operators with complexity weight of 3}
\subsubsection{Arithmetic operators}

%........................................................
\NewOperator{shl\_r(v1, v2)}

Same as {\tt shl()} but with rounding. Saturate the result in case
of underflows or overflows:

\rulex{2mm}{\tt shl\_r(v1, v2) = shr\_r(v1, -v2)}

\textbf{Note:} \hfill \pbox{145mm}{In v1.x, the complexity weight of
this operator was  2. Additionally, please note that in v1.x this
operator was called \textbf{shift\_r(v1, v2)}; in the STL2005, both
names can be used.}


%........................................................
\NewOperator{L\_shl\_r(L\_v1, v2)}

Same as {\tt L\_shl(L\_v1,v2)} but with rounding. Saturate the
result in case of underflows or overflows.

\rulex{2mm}{\tt L\_shl\_r(L\_v1, v2) = L\_shr\_r(L\_v1, -v2)}

In v1.x, this operator is called \textbf{L\_shift\_r(L\_v1, v2}) ;
both names can be used.

%........................................................
\NewOperator{i\_mult(v1, v2)}

Multiply two 16-bit words {\tt v1} and {\tt v2} returning a 16-bit
word with overflow control.

\textbf{Note:} \hfill \pbox{145mm}{In v1.x, the complexity weight of
this operator was  1. The complexity update to the
weight of 3 was motivated by the fact that the primitive is performing
something equivalent to extract\_h( L\_shl( L\_mult0( v1, v2), 16)).}

\subsubsection{Logical Operators}

%........................................................
\NewOperator{rotl(v1, v2, * v3)} \newop20

Rotates the 16-bit variable v1 by 1 bit to the most significant
bits. Bit 0 of v2 is copied to the least significant bit of the
result before it is returned. The most significant bit of v1 is
copied to the bit 0 of v3 variable.

%........................................................
\NewOperator{rotr(v1, v2, * v3)} \newop20

Rotates the 16-bit variable v1 by 1 bit to the least significant
bits. Bit 0 of v2 is copied to the most significant bit of the
result before it is returned. The least significant bit of v1 is
copied to the bit 0 of v3 variable.


%........................................................
\NewOperator{L\_rotl(L\_v1, v2, * v3)} \newop20

Rotates the 32-bit variable L\_v1 by 1 bit to the most significant
bits. Bit 0 of v2 is copied to the least significant bit of the
result before it is returned. The most significant bit of L\_v1 is
copied to the bit 0 of v3 variable.


%........................................................
\NewOperator{L\_rotr(L\_v1, v2, * v3)} \newop20

Rotates the 32-bit variable L\_v1 by 1 bit to the least significant bits.
Bit 0 of v2 is copied to the most significant bit of the result before it is returned.
The least significant bit of L\_v1 is copied to the bit 0 of v3 variable.


\subsection{Operators with complexity weight of 4}


\enlargethispage*{10mm}

\subsection{Operators with complexity weight of 5}

%........................................................
\NewOperator{L\_mls(L\_v1, v2)}

Performs a multiplication of a 32-bit variable {\tt L\_v1} by a 16-bit
variable {\tt v2}, returning a 32-bit value.

\textbf{Note:} \hfill \pbox{145mm}{In v1.x, the complexity weight of this operator was  6.}

%-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.
\subsection{Operators with complexity weight of 18}


%........................................................
\NewOperator{div\_s(v1, v2)}

Produces a result which is the fractional integer division of {\tt
v1} by {\tt v2}. Values in {\tt v1} and {\tt v2} must be positive
and {\tt v2} must be greater than or equal to {\tt v1}. The result
is positive (leading bit equal to 0) and truncated to 16 bits. If
{\tt v1}={\tt v2}, then {\tt div(v1, v2) = 32767}.

\subsection{Operators with complexity weight of 32}

%........................................................
\NewOperator{div\_l(L\_v1, v2)} %\rulex{1mm}

Produces a result which is the fractional integer division of a
positive 32-bit value {\tt L\_v1} by a positive 16-bit value {\tt
v2}. The result is positive (leading bit equal to 0) and truncated
to 16 bits.

%--------------------------------------------------
\subsection{Basic operator usage across standards}
%--------------------------------------------------

Table \ref{tbl:basop-in-recs} contains a survey of the 16-bit and
32-bit basic operators which are used in various standards.
Follows some notes associated to \ref{tbl:basop-in-recs}:

\begin{enumerate}
    \item abs\_s(v1) is referred to as abs(v1) in GSM 06.10 (GSM full-rate).
    \item shl(v1,v2) is written as v1$<<$v2 in GSM 06.10.
    \item shr(v1,v2) is written as v1$>>$v2 in GSM 06.10.
    \item v2=extract\_h(L\_v1) is written as v2 = L\_v1 in GSM 06.10.
    \item negate(v1) is written as --v1 in GSM 06.10.
    \item L\_negate(L\_v1) is written as --L\_v1 in GSM 06.10.
    \item L\_shl(L\_v1,v2) is written as L\_v1$<<$v2 in GSM 06.10.
    \item L\_shr(L\_v1,v2) is written as L\_v1$>>$v2 in GSM 06.10.
    \item L\_v2=deposit\_l(v1) is written as L\_v2=v1 in GSM 06.10.
    \item div\_s(v1,v2) is written as div(v1,v2) in GSM 06.10.
    \item norm\_l(L\_v1) is written as norm(L\_v1) in GSM 06.10.
    \item GSM 06.20 uses shift\_r(v1,v2), which can be implemented
    as shr\_r(v1,--v2).
    \item GSM 06.20 uses L\_shift\_r(L\_v1,v2), which can be
    implemented as L\_shr\_r(L\_v1,--v2).
    \item div\_s(v1,v2) is written as divide\_s(v1,v2) in GSM 06.20.
    \item Operator is not part of the original ETSI library.
    \item Operator is not part of the original ETSI library but was
    accepted in the TETRA standard.
\end{enumerate}


%-----------------------------------------------------------------
% Table with Basic operators in ITU Recs
%-----------------------------------------------------------------
\begin{table}[th]
    \Caption{14cm}{\SF Use of 32-bit basic operators in G.723.1, G.729
    and ETSI GSM speech coding recommendations.
    \label{tbl:basop-in-recs}}
    \begin{center}
        \footnotesize
        \begin{tabular}{|l|c|c|c|c|c|c|c|c|}
            \hline
            Operation &Weight &FR GSM &HR GSM &EFR GSM &AMR GSM &G.729 &G.723.1 &TETRA\\
            \hline \hline
            {\tt add()}     &1 &X &X &X &X &X &X &X\\
            {\tt sub()}     &1 &X &X &X &X &X &X &X\\
            {\tt abs\_s()}  &1 &X (1) &X &X &X &X &X &X\\
            {\tt shl()}     &1 &X (2) &X &X &X &X &X &X\\
            {\tt shr()}     &1 &X (3) &X &X &X &X &X &X\\
            {\tt extract\_h()}      &1 & &X &X &X &X &X &X\\
            {\tt extract\_l()}      &1 &X (4) &X &X &X &X &X &X\\
            {\tt mult()}    &1 &X &X &X &X &X &X &X\\
            {\tt L\_mult()} &1 &X &X &X &X &X &X &X\\
            {\tt negate()}  &1 &X (5) &X &X &X &X &X & \\
            {\tt round\_fx()}   &1 & &X &X &X &X &X &X\\
            {\tt L\_mac()}  &1 & &X &X &X &X &X &X\\
            {\tt L\_msu()}  &1 & &X &X &X &X &X &X\\
            {\tt L\_macNs()}        &1 & & &X & &X &X & \\
            {\tt L\_msuNs()}        &1 & & & & &X &X & \\
            {\tt L\_add()}  &1 &X &X &X &X &X &X &X\\
            {\tt L\_sub()}  &1 &X &X &X &X &X &X &X\\
            {\tt L\_negate()}       &1 &X (6) &X &X &X &X &X &X\\
            {\tt L\_shl()}  &1 &X (7) &X &X &X &X &X &X\\
            {\tt L\_shr()}  &1 &X (8) &X &X &X &X &X &X\\
            {\tt mult\_r()} &1 &X &X &X &X &X &X &X\\
            {\tt mac\_r()}  &1 & &X & & & &X & \\
            {\tt msu\_r()}  &1 & &X & & & &X & \\
            {\tt L\_deposit\_h()}   &1 & &X &X &X &X &X &X\\
            {\tt L\_deposit\_l()}   &1 &X (9) &X &X &X &X &X &X\\
            {\tt L\_abs()}  &1 & &X &X &X &X &X &X\\
            {\tt norm\_s()}         &1 & &X &X &X &X &X & \\
            {\tt norm\_l()} &1 &X (11) &X &X &X &X &X &X\\
            {\tt L\_add\_c()}       &2 & & & & & &X & \\
            {\tt L\_sub\_c()}       &2 & & & & & &X & \\
            {\tt shr\_r()}  &3 & &X (12) &X &X &X &X & \\
            {\tt L\_shr\_r()}       &3 & &X (13) &X &X &X &X &X\\
            {\tt L\_sat()}  &4 & & & & &X &X &\\
            {\tt div\_s()}  &18 &X (10) &X (14) &X &X &X &X &X\\
            \hline
            {\tt i\_mult()} &3 & & & & & &X (15) & \\
            {\tt L\_mls()}  &5 & & & & & &X (15) & \\
            {\tt div\_l()}  &32 & & & & & &X (15) & \\
            \hline
            {\tt L\_mult0()} &1 & & & & & & &X (16)\\
            {\tt L\_mac0()}  &1 & & & & & & &X (16)\\
            {\tt L\_msu0()}  &1 & & & & & & &X (16)\\
            \hline
        \end{tabular}
    \end{center}
\end{table}

%-----------------------------------------------------------------
\flushfloats

%----------------------------------------------------------------------
\section{Description of the 40-bit basic operators and associated weights}
%----------------------------------------------------------------------

This section describes the different 40-bit basic operators
available in the STL, and are organized by complexity ("weights").
The complexity values to be considered (since the publication of
the STL2005) are the ones related to the version 2.0 and subsequent versions of the library. These basic operators did not exist in the previous
version of the library (version 1.x).

A set of coding guidelines must be followed in order to avoid
algorithm complexity miss-evaluation. This section describes also
these guidelines.

\subsection{Variable definitions}

The variables used in the operators are signed integers in 2's
complements representation, defined by:

{\tt v1}, {\tt v2}: 16-bit variables\\
{\tt L\_v1}, {\tt L\_v2}, {\tt L\_v3}: 32-bit variables\\
{\tt L40\_v1}, {\tt L40\_v2}, {\tt L40\_v3}: 40-bit variables\\

%-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.
\subsection{Operators with complexity weight of 1}
\subsubsection{Arithmetic operators (multiplication excluded)}

%........................................................
\NewOperator{L40\_add(L40\_v1, L40\_v2)}

Adds the two 40-bit variables L40\_v1 and L40\_v2 \textbf{without}
40-bit saturation control. It will exit execution if it detects a 40-bit overflow.


%........................................................
\NewOperator{L40\_sub(L40\_v1, L40\_v2)}

Subtracts the two 40-bit variables L40\_v2 from L40\_v1
\textbf{without} 40-bit saturation control.
It will exit execution if it detects a 40-bit overflow.

%........................................................
\NewOperator{L40\_abs(L40\_v1)}

Returns the absolute value of the 40-bit variable L40\_v1 without
40-bit saturation control.
It will exit execution if it detects a 40-bit overflow.

%........................................................
\NewOperator{L40\_shl(L40\_v1, v2)}

Arithmetically shifts left the 40-bit variable L40\_v1 by v2
positions:

\rulex{10mm} -- \pbox{150mm}{if v2 is negative, L40\_v1 is shifted to the least
significant bits by (-v2) positions with extension of the sign bit.}

\rulex{10mm} -- \pbox{150mm}{if v2 is positive, L40\_v1 is shifted to the most
significant bits by (v2) positions \textbf{without} 40-bit saturation
control. It will exit execution if it detects a 40-bit overflow.}

%........................................................
\NewOperator{L40\_shr(L40\_v1, v2)}

Arithmetically shifts right the 40-bit variable L40\_v1 by v2
positions:

\rulex{10mm} -- \pbox{150mm}{if v2 is positive, L40\_v1 is shifted to the least
significant bits by (v2) positions with extension of the sign bit.}

\rulex{10mm} -- \pbox{150mm}{if v2 is negative, L40\_v1 is shifted to the most
significant bits by (-v2) positions \textbf{without} 40-bit saturation
control. It will exit execution if it detects a 40-bit overflow.}

%........................................................
\NewOperator{L40\_negate(L40\_v1)}

Negates the 40-bit variable L40\_v1 \textbf{without} 40-bit saturation
control. It will exit execution if it detects a 40-bit overflow.

%........................................................
\NewOperator{L40\_max(L40\_v1, L40\_v2)}

Compares two 40-bit variables L40\_v1 and L40\_v2 and returns the
maximum value.

%........................................................
\NewOperator{L40\_min(L40\_v1, L40\_v2)}

Compares two 40-bit variables L40\_v1 and L40\_v2 and returns the
minimum value.

%........................................................
\NewOperator{norm\_L40(L40\_v1)}

Produces the number of left shifts needed to normalize the 40-bit
variable L40\_v1 for positive values on the interval with minimum
of 1073741824 and maximum 2147483647, and for negative values on
the interval with minimum of -2147483648 and maximum of
-1073741824; in order to normalize the result, the following
operation must be done:

\rulex{5mm}
{\tt L40\_norm\_v1 = L40\_shl( L40\_v1, norm\_L40( L40\_v1))}

\subsubsection{Multiplication operators}

%........................................................
\NewOperator{L40\_mult(v1, v2)}

Multiplies the 2 signed 16-bit variables v1 and v2 \textbf{without}
40-bit saturation control.  It will exit execution if it detects a 40-bit
overflow. The operation is performed \textbf{in fractional mode}:

\rulex{10mm} -- \pbox{150mm}{v1 and v2 are supposed to be in 1Q15 format.}

\rulex{10mm} -- \pbox{150mm}{The result is produced in 9Q31 format.}

%........................................................
\NewOperator{L40\_mac(L40\_v3, v1, v2)}

Equivalent to: {\tt L40\_add( L40\_v1, L40\_mult( v2, v3)) }

%........................................................
\NewOperator{L40\_msu(L40\_v3, v1, v2)}

Equivalent to: {\tt L40\_sub( L40\_v1, L40\_mult( v2, v3)) }

\subsubsection{Logical operators}

%........................................................
\NewOperator{L40\_lshl(L40\_v1, v2)}

Logically shifts left the 40-bit variable L40\_v1 by v2 positions:

\rulex{10mm} -- \pbox{150mm}{if v2 is negative, L40\_v1 is shifted to
the least significant bits by (-v2) positions with insertion of 0 at
the most significant bit.}

\rulex{10mm} -- \pbox{150mm}{if v2 is positive, L40\_v1 is shifted to
the most significant bits by (v2) positions without saturation
control.}

%........................................................
\NewOperator{L40\_lshr(L40\_v1, v2)}

Logically shifts right the 40-bit variable L40\_v1 by v2 positions:

\rulex{10mm} -- \pbox{150mm}{if v2 is positive, L40\_v1 is shifted to
the least significant bits by (v2) positions with insertion of 0 at
the most significant bit.}

\rulex{10mm} -- \pbox{150mm}{if v2 is negative, L40\_v1 is shifted to
the most significant bits by (-v2) positions without saturation
control.}

\subsubsection{Data type conversion operators}

%........................................................
\NewOperator{Extract40\_H(L40\_v1)}

Returns the bits [31..16] of L40\_v1.

%........................................................
\NewOperator{Extract40\_L(L40\_v1)}

Returns the bits [15..00] of L40\_v1.

%........................................................
\NewOperator{round40(L40\_v1)}

Equivalent to:\\
{\tt extract\_h( L\_saturate40( L40\_round( L40\_v1))) }

%........................................................
\NewOperator{L\_Extract40(L40\_v1)}

Returns the bits [31..00] of L40\_v1.

%........................................................
\NewOperator{L\_saturate40(L40\_v1)}

If L40\_v1 is greater than 2147483647, the operator returns 2147483647. \\
If L40\_v1 is lower than -2147483648, the operator returns -2147483648. \\
Otherwise, it is equivalent to {\tt L\_Extract40(L40\_v1)}.


%........................................................
\NewOperator{L40\_deposit\_h(v1)}

Deposits the 16-bit variable v1 in the bits [31..16] of the return
value: the return value bits [15..0] are set to 0 and the bits
[39..32] sign extend v1 sign bit.

%........................................................
\ \\
\NewOperator{L40\_deposit\_l(v1)}

Deposits the 16-bit variable v1 in the bits [15..0] of the return
value: the return value bits [39..16] sign extend v1 sign bit.

%........................................................
\NewOperator{L40\_deposit32(L\_v1)}

Deposits the 32-bit variable L\_v1 in the bits [31..0] of the
return value: the return value bits [39..32] sign extend L\_v1
sign bit.

%........................................................
\NewOperator{L40\_round(L40\_v1)}

Performs a rounding to the infinite on the 40-bit variable
L40\_v1. 32768 is added to L40\_v1 \textbf{without} 40-bit saturation
control. It will exit execution if it detects a 40-bit overflow.  The
end-result 16 LSBits are cleared to 0.


\subsection{Operators with complexity weight of 2}

%........................................................
\NewOperator{mac\_r40(L40\_v1, v2, v3)}

Equivalent to: \\
{\tt round40( L40\_mac( L40\_v1, v2, v3)) }

%........................................................
\NewOperator{msu\_r40(L40\_v1, v2, v3) }

Equivalent to: \\
{\tt round40( L40\_msu( L40\_v1, v2, v3)) }

%........................................................
\NewOperator{Mpy\_32\_16\_ss(L\_v1, v2, *L\_v3\_h, *v3\_l)}

\textbf{Multiplies the 2 signed values} L\_v1 (32-bit) and v2 (16-bit)
with saturation control on 48-bit. The operation is performed in
\textbf{fractional mode}: \\
When L\_v1 is in 1Q31 format, and v2 is in 1Q15 format, the result is
produced in 1Q47 format: L\_v3\_h bears the 32 most significant bits
while v3\_l bears the 16 least significant bits.

\subsection{Operators with complexity weight of 3}

%........................................................
\NewOperator{L40\_shr\_r(L40\_v1, v2)}

Arithmetically shifts the 40-bit variable L40\_v1 by v2 positions to
the least significant bits and rounds the result. It is equivalent to
{\tt L40\_shr( L40\_v1, v2)} except that if v2 is positive and the last
shifted out bit is 1, then the shifted result is increment by 1
\textbf{without} 40-bit saturation control. It will exit execution if
it detects a 40-bit overflow.

%........................................................
\newpage
\NewOperator{L40\_shl\_r(L40\_v1, v2)}

Arithmetically shifts the 40-bit variable L40\_v1 by v2 positions
to the most significant bits and rounds the result. It is
equivalent to {\tt L40\_shl( L40\_var1, v2)} except if v2 is negative.
In this case, it does the same as {\tt L40\_shr\_r( L40\_v1, (-v2))}.

%........................................................
\NewOperator{L40\_set(L40\_v1)}

Assigns a 40-bit constant to the returned 40-bit variable.

\subsection{Operators with complexity weight of 4}

%........................................................
\NewOperator{Mpy\_32\_32\_ss(L\_v1, L\_v2, *L\_v3\_h, *L\_v3\_l)}

Multiplies the two signed 32-bit values L\_v1 and L\_v2 with saturation
control on 64-bit. The operation is performed in \textbf{fractional
mode}: when L\_v1 and L\_v2 are in 1Q31 format, the result is produced
in 1Q63 format; L\_v3\_h bears the 32 most significant bits while
L\_v3\_l bears the 32 least significant bits.

\subsection{Coding Guidelines}

The following recommendations must be followed in the usage of the
40-bit operators:
\begin{enumerate}
    \item Only 40-bit variables local to functions can be declared.
    Declaration of arrays and structures containing 40-bit elements
    must not be done.
    \item 40-bit basic operators and 16/32-bit basic
    operators must not be mixed within the same loop initialized with
    a FOR(), DO or WHILE() control basic operator.

    When nested loop software structure is implemented, this
    recommendation applies to the most inner loops. This enables to
    have, for instance, an outer loop containing 2 inner loops, with
    the 1st inner loop using 40-bit basic operators and the 2nd inner
    loop using 16/32-bit basic operators. However, whenever possible,
    even such 2 level loop structure configuration should only use
    either 40-bit basic operators or 16/32-bit basic operators.

    Current version (2.0) of the operator implementation does not
    evaluate the complexity associated to the mixing of 40-bit and
    16/32-bit operators. Subsequent versions may do so.
\end{enumerate}

%-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.
\section{Description of the control basic operators and associated weights}

This section describes the different control basic operators
available in the STL and their associated complexity weights. The
complexity values to be considered (since the publication of the
STL2005) are the ones related to 2.0 and subsequent versions of the library.
These basic operators did not exist in the previous version of the
library (version 1.x).

\textbf{A set of coding guidelines must be followed} in order to
avoid algorithm complexity miss-evaluation. This section describes
also these guidelines.

\subsection{Operators and complexity weights}
Nine macros are defined to enable the evaluation of the complexity
associated to control instructions that are frequently used in C.

\begin{list}{o}{}
    \item The \textbf{IF(expression)} and \textbf{ELSE} macros
    evaluate the cost of the C statement:
    {\small
    \begin{verbatim}
        if (expression) {...}[[else if(expression2) {...}] else {...}]
    \end{verbatim}}
    \item The \textbf{SWITCH(expression)} macro evaluates the cost of the C
    statement:
    {\small
    \begin{verbatim}
        switch (expression) {...}
    \end{verbatim}}
    \item The \textbf{WHILE (expression)} macro evaluates the cost of the C
    statement:
    {\small
    \begin{verbatim}
        while (expression) {...}
    \end{verbatim}}
    \item The \textbf{FOR (expr1;expr2; expr3)} macro evaluates the cost
    of the C statement:
    {\small
    \begin{verbatim}
        for (expr1; expr2; expr3) {...}
    \end{verbatim}}
    \item The \textbf{DO} and \textbf{WHILE(expression)} macros evaluates
    the cost of the C statement:
    {\small
    \begin{verbatim}
        do {...} while (expression)
    \end{verbatim}}
    \item The \textbf{CONTINUE} macro evaluates the cost of the C statement:\\
    {\small
    \begin{verbatim}
        while (expression) {
        ...
        continue;
        ...
        }
    \end{verbatim}}
    or
    {\small
    \begin{verbatim}
        for (expr1; expr2; expr3) {
        ...
        continue;
        ...
        }
    \end{verbatim}}
    \item The \textbf{BREAK} macro evaluates the cost of the C statement:
    {\small
    \begin{verbatim}
        while(expression)
        {
        ...
        break;
        ...
        }
    \end{verbatim}}
    or
    {\small
    \begin{verbatim}
        for (expr1; expr2; expr3) {
        ...
        break;
        ...
        }
    \end{verbatim}}
    or
    {\small
    \begin{verbatim}
        switch(...) {
        ...
        break;
        ...
        }
    \end{verbatim}}
    \item The \textbf{GOTO} macro evaluates the cost of the C statement:
    {\small
    \begin{verbatim}
        goto label;
    \end{verbatim}}
\end{list}

Table \ref{tbl:control-basicop} summarizes the control basic
operators and their associated complexity.

%-------------------------------------------------------------------------
% Table with the control basic operators and their associated complexity.
%-------------------------------------------------------------------------
\begin{table}[th]
    \Caption{14cm}{\SF Control basic operators and associated
    complexity. \label{tbl:control-basicop}}
    \begin{center}
        \footnotesize
        \begin{tabular}{|c|l|l|}
            \hline Complexity Weight  & Basic Operator  & Description\\
            \hline \hline {0}    & \textbf{DO}\{...\} while(expression) &
            \parbox[t]{70mm}{\SF The
            macro DO must be used instead of the 'do' C statement.}\\
            \hline {3} & \textbf{FOR}(expr1; expr2; expr3) \{...\} &
            \parbox[t]{70mm}{\SF The macro FOR must be used instead of the
            'for' C statement. The complexity is \textbf{independent} of the
            number of loop iterations that are performed.} \\
            \hline {0} & \parbox[t]{60mm}{\SF \textbf{if}(expression)
            \textbf{one\_and\_only\_one\_basic\_operator (control operators
            excluded)}} & \parbox[t]{70mm}{\SF \textbf{The macro IF must not
            be used} when the 'if' structure does not have any 'else if' nor
            'else' statement and it conditions only one basic operator
            (control operators excluded)}. \\
            \hline {4} & \parbox[t]{60mm}{\SF \textbf{IF}(expression) \{...\}}
            &
            \parbox[t]{70mm}{\SF The macro IF must be used instead of the 'if'
            C statement \textbf{in every other case}: when there is an 'else'
            or 'else if' statement, or when the 'if' conditions several basic
            operators, or when the 'if' conditions a function call or when the
            'if' conditions a control operator.}\\
            \hline {4} & \parbox[t]{60mm}{\SF if(expression) \{...\} [[\\
            \textbf{ELSE} if(expression2)\{...\}]\\ \textbf{ELSE} \{...\}]} &
            \parbox[t]{70mm}{\SF The macro ELSE must be used instead of the
            'else' C
            statement.}\\
            \hline {8} & \textbf{SWITCH}(expression) \{...\} &
            \parbox[t]{70mm}{\SF The macro SWITCH must be used instead of the
            'switch' C statement.}\\
            \hline {4} & \textbf{WHILE}(expression) \{...\} &
            \parbox[t]{70mm}{\SF The macro WHILE must be used instead of the
            'while' C statement.\\
            The complexity is \textbf{proportional} to the number of loop
            iterations that are performed.}\\
            \hline {4} & \parbox[t]{60mm}{\SF while(expression) \{ \\...
            \textbf{CONTINUE}; ...\\ \}\\ or\\ for(expr1; expr2; expr3) \{
            \\...\\ \textbf{CONTINUE}; \\...\\ \}\\ } &
            \parbox[t]{70mm}{\SF The macro CONTINUE must be used instead of
            the 'continue' C statement.}\\
            \hline {4} & \parbox[t]{60mm}{\SF while(expression) \{ \\...
            \textbf{BREAK}; ...\\ \}\\ or\\ for(expr1; expr2; expr3) \{
            \\...\\ \textbf{BREAK}; \\...\\ \}\\or\\
            switch(var) \{ \\...\\ \textbf{BREAK};\\...\\\}
            } &
            \parbox[t]{70mm}{\SF The macro BREAK must be used instead of
            the 'break' C statement.}\\
            \hline {4} &  \textbf{GOTO}  & \parbox[t]{60mm}{\SF The macro GOTO
            must be used instead of the 'goto' C statement.}\\
            \hline
        \end{tabular}
    \end{center}
\end{table}

%\flushfloats

\subsection{Coding guidelines}
\subsubsection{When to use IF() instead of if()?}

The \textbf{IF}() macro must be used instead of the classical C
statement \textbf{if}(), wherever:
\begin{list}{}
    \item o There is an else or else if statement, \item o There is
    \textbf{strictly more than one basic operators} to condition, \item
    o There is at least a function call to condition. \item o There is
    a control basic operator to condition.
\end{list}
An example code:
{\small
\begin{verbatim}
    if (x == 0)
    z = add(z, sub(y, x)); /* more than one basic ops */
    if (z == 0)
    Decode(); /* function call */
    something();
\end{verbatim}}
must be written as:
{\small
\begin{verbatim}
    IF (x == 0)
    z = add(z, sub(y, x));
    IF (z == 0)
    Decode();
    something();
\end{verbatim}}

While below code must stay untouched since \textbf{only one} basic
operator
is conditioned.
{\small
\begin{verbatim}
    if (x == 0)
    z = add(z, x); /* one basic op */
    something();
\end{verbatim}}

\subsubsection{When to use FOR() and WHILE() macros?}

The {\tt FOR()} and {\tt WHILE()} macros must be used to differentiate
loops which can be handled by a h/w loop controller from complex loops
which need to be controlled by additional control software.

\flushfloats

\begin{list}{o}
    \item Follows an example of a \textbf{simple h/w loop} that must
    be designed with the \textbf{FOR()} macro. It will iterate
    C-statement E0 to E20 a number of times \textbf{known at loop
    entry} (and at least once). Therefore, for such loops, there is no
    complexity associated to the computation of the decision to loop
    back or not:
    {\small
    \begin{verbatim}
        /* var1 > 0 is ensured  */
        FOR (n = 0; n < var1; n++) {
        E0;
        /* never do anything that impacts "var1" nor "n" value */
        E20;
        }
    \end{verbatim}}

    \item Follows an example of a \textbf{complex s/w loop} that must be
    designed with the \textbf{WHILE()}. It will iterate C-statement E0 to
    E20 a number of times \textbf{undefined} at loop entry (eventually 0
    times). Indeed, at the end of one loop iteration, the decision to loop
    back depends on the processing done within the elapsed iteration.
    {\small
    \begin{verbatim}
        /* do not need to ensure n < var1 at loop entry */
        WHILE (n < var1) {
        E0;
        /* can do anything that impacts "var1" or "n" value */
        E20;
        }
    \end{verbatim}}
\end{list}

ANSI-C defines \textbf{for}() structures with \textbf{while}()
structures, but by differencing the \textbf{FOR}() and
\textbf{WHILE}() macro usage, a better complexity evaluation of
the loop controlling is made.

\begin{list}{}
    \item o A loop defined with FOR() macro:
    \begin{list}{}
        \item - \textbf{Only counts the initial set-up} of the h/w loop controller with a complexity weight of 3.
        \item - \textbf{Must iterate at least once}.
        \item - Has a complexity \textbf{independent} of the number of iterations that are performed.
    \end{list}
    \item o A Loop defined with WHILE() macro:
    \begin{list}{}
        \item - Counts, at \textbf{every single iteration} which is executed,
        \textbf{the complexity associated to the computation of the
        decision to loop back or not}.
        \item - \textbf{Can be executed 0 times.}
        \item - Has a complexity \textbf{proportional} (by a factor
        of  4) to the number of iterations that are performed.
    \end{list}
\end{list}

\subsubsection{When to use DO and WHILE() macros?}
It is important to \textbf{modify} below C code:
{\small
\begin{verbatim}
    do {
    x = sub(x, y)
    } while (x < 0);
\end{verbatim}}
into following one: \\
{\small
\begin{verbatim}
    DO {
    x = sub(x, y)
    } WHILE (x < 0);
\end{verbatim}}

The following code is also possible but, although the associated
complexity computation will be identical, it can generate parsing
errors by some source code editors which perform on-the-fly syntax
checking.
{\small
\begin{verbatim}
    do {
    x = sub(x, y)
    } WHILE (x < 0);
\end{verbatim}}

\subsubsection {Testing an expression equality}

\textbf{\emph{if(expression) \{...\} and while(expression) \{...\}
C statements.}}

All arithmetic tests on data must be presented as a comparison to
zero. To perform comparison between two variables (or a variable
and a non-zero constant), a subtraction (\textbf{sub} or
\textbf{L\_sub} or \textbf{L40\_sub}) must be performed first.

For example, below examples leads to an under evaluation of the
complexity:
{\small
\begin{verbatim}
    if (a > 3) { }
    while (a != 5) { } ...
\end{verbatim}}

While, below examples leads to a correct evaluation of the
complexity:
{\small
\begin{verbatim}
    if (sub(a,3) > 0) { }
    while (sub(a, 5) != 0) { } ...
\end{verbatim}}

If multiple condition need to be evaluated and merged, one
\textbf{test}() operator must be used for each additional test to be
done.

Example 1:

The following code ...

\rulex{10mm}if ( (a $>$ b) \&\& (c $>$ d)) \{\}

... must be modified to:

\rulex{10mm}\textbf{test}(); \\
\rulex{10mm}if ( (sub( a, b) $>$ 0) \&\& (sub( c, d) $>$ 0)) \{\}

Example 2:

The following code ...\\
\rulex{10mm}if ( (a $>$ b) \\
\rulex{10mm}\&\& (c $>$ d) \\
\rulex{10mm}$||$(e $>$ f)) \{\}

... must be modified to:\\
\rulex{10mm}\textbf{test}(); \\
\rulex{10mm}\textbf{test}(); \\
\rulex{10mm}if (  (sub( a, b) $>$ 0)\\
\rulex{10mm}\&\& ( sub( c, d) $>$ 0)\\
\rulex{10mm}$||$ (sub( e, f) $>$ 0)) \{\}\\

\ \\
\textbf{\emph{(condition) ? (statement1) : (statement2)}}

The ternary operator ``\textbf{? \ :}'' must not be used since it does
not enable the evaluation of the associated complexity.

Therefore, instead of writing: \\
\rulex{10mm}(condition) ? (statement1) : (statement2)

One must write: \\
\rulex{10mm}IF(condition)\\
\rulex{15mm}{statement1};\\
\rulex{10mm}ELSE\\
\rulex{15mm}{statement2};

Whenever it is possible to avoid the \textbf{else} clause, one should write:\\
\rulex{10mm}{statement2};\\
\rulex{10mm}IF(condition)\\
\rulex{15mm}{statement1};

And whenever \textbf{statement1} is \textbf{one and only one basic
operator} (control operator excluded), one can write:\\
\rulex{10mm}{statement2};\\
\rulex{10mm}if(condition)\\
\rulex{15mm}{one\_and\_only\_one\_basic\_operator};\\

\textbf{\emph{for(expresion1; expression2; expression3)}}

A ``\textbf{for}'' C statement must be limited to initializing,
testing and incrementing the loop counter. The following C code
statement is an example of incorrect usage:

\rulex{10mm}for(i=0, j=0; i$<$N \& w$>$0 ; i++, j+=3)

It must be replaced by: \\
\rulex{10mm}j=0;\\
\rulex{10mm}for(i=0; i$<$N ; i++) \{\\
\rulex{15mm}j = add(j,3);\\
\rulex{15mm}if(w $>$ 0)\\
\rulex{18mm}break; \\
\rulex{10mm}\}

Actually, in order to respect the other recommendations, it must
be replaced by: \\
\rulex{10mm}j=0;\\
\rulex{10mm}FOR(i=0; i$<$N ; i++) \{\\
\rulex{15mm}j = add(j,3);\\
\rulex{15mm}if(w $>$ 0)\{\\
\rulex{18mm}BREAK; \\
\rulex{15mm}\}\\
\rulex{10mm}\}

%\subsubsection{}

\section{Complexity associated with data moves and other operations}

\subsection{Data moves}

Each data move between two 16-bit or two 32-bit variables, \textbf{move16}() and \textbf{move32}() operators respectively, has a complexity weight of 1.

\textbf{Note:} \hfill \pbox{145mm}{In v2.3, the complexity weight of \textbf{move32}() operator was  2. }

\begin{enumerate}{}{}
    \item A 16-bit variable cannot be directly moved to a 32-bit or 40-bit variable.
    \item A 32-bit variable cannot be directly moved to a 16-bit or 40-bit variable.
    \item A 40-bit variable cannot be directly moved to a 16-bit or 32-bit variable.
\end{enumerate}

For above 3 types of moves, functions such as the following ones
must be used:
\begin{center}
    \begin{tabular}{|c|c|c|}
        \hline
        \hline round\_fx() & round40()   & L\_saturate40()\\
        \hline extract\_h() & Extract40\_H()   & L\_Extract40()\\
        \hline extract\_l() & Extract40\_L()   & L40\_deposit32()\\
        \hline L\_deposit\_h()   & L40\_deposit\_h() & \\
        \hline L\_deposit\_l()   & L40\_deposit\_l() & \\
        \hline
    \end{tabular}
\end{center}

There will be no extra weighting for data move when using above
functions: the weighting of the data move is already included in
the weighting of these functions.

Data moves are only counted in
the following cases:
\begin{enumerate}
    \item A data move from a constant to a variable;
    \item A data move from a variable to a variable;
    \item A data move of the result of a basic operation to an array;
    \item A typecast from a Word8 to a Word16 variable;
    \item A typecast from a Word8 to a Word32 variable.
\end{enumerate}

\subsubsection{Is it necessary to count the complexity of typecast
from Word8 to Word16 or Word32?}
Following example shows necessity:
{\tt\small
\begin{verbatim}
    const Word8 tbl[2] = {0x1, 0x2};

    Word16 tmp;
    tmp = add((Word16 )tbl[0], (Word16 )tbl[1]); move16(); move16();
    a = my_function((Word16 )tbl[0], (Word16 )tbl[1]); move16(); move16();
    /* assuming my_function requires 2 Word16 parameters. */
\end{verbatim}
}

\subsubsection{Is it necessary to count an address calculation when initializing a pointer?}
For a case when initializing a pointer with an address, extra weight
count, e.g. move16(), is not necessary because address computation is
not counted as a part of the complexity. For example:
{\tt\small
\begin{verbatim}
    Word16 *p;
    p = &(array[1]); /* move16() not necessary */
\end{verbatim}
}% \textcolor{green}{[EDNOTE: \#02]}

\subsubsection{Does return value assignment need to be counted?}
When a return value of a function is assigned, it does not require
move16() count. For example:
{\tt\small
\begin{verbatim}
    Word16 a = function(b); /* move16() not necessary */
\end{verbatim}
}% \textcolor{green}{[EDNOTE: \#04]}
Here is another example that does not require copy count:
{\tt\small
\begin{verbatim}
    Word16 function(Word16 b) {
    return (add(b, 1)); /* move16() not necessary */.
    }
\end{verbatim}
}% \textcolor{green}{[EDNOTE: \#05 and \#07]}

Introducing dummy functions to avoid extra basop
counts must be avoided. % \textcolor{green}{[EDNOTE: \#08]}
% \textcolor{green}{[EDNOTE: \#05 and \#07]}
% \textcolor{green}{%
%
% However, the following is an example that takes advantage of no
% penalty counts for the return value assignment, and this \textbf{must be
% avoided}:
% }
% {\tt\small
% \begin{verbatim}
%   /* following dummy function to save move16() must avoided */
%   Word16 function(Word16 b) {
%      if(b>0) {b=1;move16();}
%      return b;
%   }
% \end{verbatim}
% } \Textcolor{green}{[EDNOTE: \#08]}

\subsubsection{What to do with return value of a macro?}
When copying return value of a complex macro to a variable, it does
not require extra weight count as in a return value of a function:
{\tt\small
\begin{verbatim}
    Word32 w = Mpy_32(); /* move32() not required */
\end{verbatim}
} % \textcolor{green}{[EDNOTE: \#12]}

\subsection{Other operations}

Address computation must be excluded from the complexity
evaluation. However, when extremely complex address computations
are done, these address computations should be resolved using the
basic operations, in order to account for the associated
complexity.

For example, incrementation of an address by one does not require an
extra count, but followings would be considered complex:
{\tt\small
\begin{verbatim}
    j=0; move16();
    FOR( i=0; i<5; i++) {
    sum = add(sum, array[j]);
    j = add(j,i);
    }"
\end{verbatim}
} % \textcolor{green}{[EDNOTE: \#09]}

%----------------------------------------------------------------------
\section{Program ROM estimation tool for fixed-point C Code}
%----------------------------------------------------------------------

\subsection{Tool Description }
This tool is developed to help the estimation of program ROM of
applications written using ITU-T Basic Operator libraries. This tool
counts the number of calls to basic operators in a C source file, and
also the number of calls to user defined functions. The sum of these
two numbers gives an estimation of the required PROM for this C source
file. Note that RAM and data ROM have to be estimated by other means.

The tool is meant to provide a consistent, platform independent method
of obtaining and reporting program ROM estimates.

This tool works as follows:
\begin{list}{-}
    \item In a first step, a pre-processing removes C and C++ style
    comments to avoid counting functions that are commented out. The
    result is written in the file with extension {\tt .c\_pre}.\\
    Note that the pre-processor directives are not taken into account,
    so functions of the source code deactivated by a pre-processor
    directive are counted by the tool.
    \item In a second step, the pre-processed file is analysed and the
    number of basic operators (first group) and all other functions
    (second group) are counted. This second group of other functions is
    divided into two sub-groups as it is possible to define a so called
    "black list" that contains functions that should not be counted in
    the program ROM. Typically these functions are memory allocation
    functions (malloc, free,\dots), file manipulation functions (fopen,
    fclose, fwrite, printf,\dots) or even functions related to complexity
    counting (setCounter, WMOPS\_output, fwc,\dots). This list is
    already initialized and can be further edited and completed if
    needed. The other subgroup is called user defined functions as it
    consists of all functions which are neither basic operators nor
    blacklist functions.
\end{list}

At the end of the execution, the results are printed out on the
standard output indicating the names of the C file and of the
pre-processed file, the number of calls to basic operators, the number
of calls to user defined functions, and the number of calls to
blacklist functions.

When a result file name is also given as second optional argument of
the command line, a summary of the results is written in this result
file in append mode. Thus, to estimate the program ROM of a given
application, the tool has to be run for all C files of the application
using the same result file. Each call adds a new line in for the input
C file. Though the format of the result file is a text file with tab
separators, it is advised to name it with .xls extension and open it
with Microsoft Excel.

The Excel file has as many rows as the number of C files. For each
row, there are four columns: the first column contains the ANSI C
input file name, the second the number of calls to basic operators,
the third the number of calls to user defined functions and the fourth
the number of calls to blacklist functions. In this way the program
ROM of an application containing several C source files can be easily
estimated as the sum of the numbers in the second and third columns.

By defining the pre-pocessor directives {\tt VERBOSE\_BASOP}, {\tt
VERBOSE\_FUNC} or\\ {\tt VERBOSE\_BLACKLIST\_FUNC} the detailed list
of called function for basic operator functions, user defined
functions and blacklist functions respectively, is also printed
out. This allows an easy cross-check of the results.

This tool is optimized for the basic operators of STL2005 or later. In
case of estimating the program ROM of an application written using
earlier STL basic operators, it is advised to define the pre-processor
directive {\tt OLD\_STL}. In this case some C operators like if, do
are not counted directly as they should be accompanied by the basic
operator {\tt test()}, and this later is counted by the tool.

\textcolor{blue}{
%
In STL2014 release, the following modifications were made:
\begin{itemize}
    \item Addition of functions in the blacklist;
    \item Functionality that prints out PROM is added;
    \item An update for change to {\tt round()} function to {\tt
    round\_fx()} (introduced in STL2009); and
    \item Bug correction in user function computation
\end{itemize}
%
}


\subsection{Tool implementation}
The tool consists of one ANSI C file {\tt basop\_cnt.c}.

To use this tool the C source file {\tt basop\_cnt.c} has to be
compiled and linked. The resulted executable file has to be called for
each C source file of the examined application, with the following
syntax:
\begin{verbatim}
basop_cnt input.c [result_file_name.txt]}
\end{verbatim}
where $input.c$ is an ANSI C file and $result\_file\_name.txt$ the
ouput result file.

If needed to further edit the black list of functions that should not
be counted in the program ROM, modify {\tt const char blacklist[][20]
= \{{\dots}\}} in basop\_cnt.c before compilation.


\subsection{Example}
This tool was first used to estimate the program ROM of the G.722 PLC
candidate algorithms.  The example below gives the execution of this
tool with part of G.722 appendix IV\footnote{this example does not
give the total complexity of G.722 appendix IV}.\\
- without a result file:  {\tt basop\_cnt g722.c} \\
the output is : \\
\texttt{
\begin{tabbing}
Output pre-processed file:..\=\kill
Input file:   \>g722.c\\
Output pre-processed file:\>g722.c\_pre\\
~~87 ~calls to STL basicops\\
~~28 ~calls to user-defined functions\\
~~~8 ~calls to blacklist tokens\\
\end{tabbing}
}
If the pre-processor directive {\tt VERBOSE\_BLACKLIST\_FUNC} is
defined, the list of the 8 blacklist functions found is also given:
\\ \texttt{
\begin{tabbing}
line..XXX:.\=blacklist X...\=x:\kill
line  ~86:\>blacklist \#  \>1:                          \`          return \\
line  160:\>blacklist \#  \>2:                          \`          calloc \\
line  160:\>blacklist \#  \>3:                          \`          sizeof \\
line  230:\>blacklist \#  \>4:                          \`            free \\
line  271:\>blacklist \#  \>5:                          \`          return \\
line  303:\>blacklist \#  \>6:                          \`          calloc \\
line  303:\>blacklist \#  \>7:                          \`          sizeof \\
line  318:\>blacklist \#  \>8:                          \`            free \\
\end{tabbing}
}
Note that the line numbers correspond to the comment free pre-processed file.

- with a result file g722appIV\_summary.xls:\\
\texttt{
\begin{itemize}
\item basop\_cnt g722.c g722appIV\_summary.xls
\item basop\_cnt funcg722.c	g722appIV\_summary.xls
\end{itemize}
}
After the first call, the result file contains:\\
\begin{tabbing}
\begin{tabular}{|p{3cm}|r|r|r|}
\hline
g722.c & \hspace{6mm}87 & \hspace{6mm}28 & \hspace{7mm}8 \\
\hline
\end{tabular}\\
\end{tabbing}

After the second call, the result file contains:\\
\begin{tabbing}
\begin{tabular}{|p{3cm}|r|r|r|}
\hline
g722.c & \hspace{6mm}87 & \hspace{6mm}28 & \hspace{7mm}8 \\
\hline
funcg722.c & 389 & 41 & 19 \\
\hline
\end{tabular}\\
\end{tabbing}


\textcolor{blue}{
%----------------------------------------------------------------------
\section{Dynamic RAM counting tool}
%----------------------------------------------------------------------
%
\subsection{Introduction}
During the completion of G.729.1 Annex E \cite{G.729.1E} and
G.718 Annex B \cite{G.718B}, another tool was developed to help
the estimation of the dynamic random access memory (DRAM).
\subsection{Tool Description}
The DRAM estimation tool enables to estimate the dynamic RAM of
software written in C. If all functions used in the software are
instrumented using this tool, it gives the highest memory allocation
occurred during the execution~\cite{AC-1004-Q10-15}. A resulting and
detailed summary is printed in the file {\tt dyn\_ram\_max\_info.txt},
containing the max dynamic ram usage in bytes and the call graph of
the worst case path.}
%
\textcolor{blue}{
\subsection{Usage}
How to use this tool:
}
\begin{enumerate}
\item \textcolor{blue}{%
Define the preprocessor directive {\tt DYN\_RAM\_CNT}
}
\item \textcolor{blue}{%
Define the following variables in a global position before the
main function:
}
\begin{verbatim}
int dyn_ram_level_cnt;
unsigned long *dyn_ram_table_ptr;
unsigned long dyn_ram_table[DYN_RAM_MAX_LEVEL];
char dyn_ram_name_table[DYN_RAM_MAX_LEVEL][DYN_RAM_MAX_NAME_LENGTH];
unsigned long dyn_ram_current_value;
unsigned long dyn_ram_max_value;
unsigned long dyn_ram_max_counter;
\end{verbatim}
\item \textcolor{blue}{%
At the beginning of the main function call the init function
{\tt DYN\_RAM\_INIT()};
}
\item \textcolor{blue}{%
Include in each {\tt .c} source file the {\tt dyn\_ram\_cnt.h} file
}
\item \textcolor{blue}{%
At the beginning of each function (or at the beginning of blocks
where new dynamic RAM is allocated or after a dynamic memory
allocation using malloc or calloc) copy this part and fill in the
exact numbers for each type of variables:
}
\begin{verbatim}
{
unsigned long drsize = 0;
drsize += (UWord32) (n16 * SIZE_Word16);
drsize += (UWord32) (n32 * SIZE_Word32);
drsize += (UWord32) (nptr * SIZE_Ptr);
DYN_RAM_PUSH(drsize,"identifier name");
}
\end{verbatim}
\textcolor{blue}{%
where:
\begin{itemize}
\item n16 is the number of Word16 variables in the function (or in the block)
\item n32 is the number of Word32 variables in the function (or in the block)
\item nptr is the number of pointer variables in the function (or in the block)
\item identifier name is a text identifying the function (or the
block).
\item the identifier name is used in the report printed in the file
{\tt dyn\_ram\_max\_info.txt} to describe the call graph of the worst case
path.
\end{itemize}
}
\item \textcolor{blue}{%
At the end of each function (or at the end of blocks where new
dynamic RAM was allocated or after the free of a dynamic memory
allocation using free) call the function: {\tt DYN\_RAM\_POP()};
}
\item \textcolor{blue}{%
Optional: At the end of the main function call the report
function: {\tt DYN\_RAM\_REPORT()}; This prints out on the screen
the found maximum dynamic RAM usage in bytes and some other
information that can be useful like the verification result for
PUSH-POP pairs or an identification number that helps to put a
conditional breakpoint to stop the execution at the moment when the
worst case situation happens. In this way this tool gives another
possibility to check in which configuration the max memory need
occurred.
}
\end{enumerate}

%----------------------------------------------------------------------
\section{Complexity evaluation tool for floating-point C Code}
%----------------------------------------------------------------------

\subsection{Introduction}
The Complexity evaluation tool for floating-point C Code enables to
estimate the number of WMOPS (Weighted Million Operations per Second)
and Program ROM of a floating-point implementation of speech and audio
codecs. An estimation of the complexity that would be obtained
after conversion of a floating-point source code into the corresponding
fixed-point implementation is also computed.

\subsection{Tool Description }
This tool consists of complexity counters (macros) collected in an ANSI
C library. The library is intended to be included in a codec algorithm,
each line of which is instrumented with the complexity counters. The
tool measures the computational complexity and program ROM based on a
floating-point C source code instrumented with the counters. Note that
RAM and table ROM have to be estimated by other means.

The tool is meant to provide a consistent, platform independent method
of obtaining and reporting complexity estimates. The weights assigned
with arithmetic operations reflect as much as possible those of the
ITU-T Fixed-point Basic Operators. It should be noted, however, that the methodology
cannot give an exact correspondence with the complexity of the fixed-point implementation and only estimation is given. Among several other
reasons, this is because the scaling related operations (including
saturation and overflow control) used in the fixed-point implementation
have no correspondence in the floating-point implementation.

The essential feature of the tool is that the instructions need to be
executed to be counted. Therefore the codec should be executed in
conditions that give the broadest possible coverage of the source code
(i.e. usually at the highest bitrate in frame-error conditions).

\subsection{Complexity Verification Method}
The computational complexity associated with a given speech and audio
codec can be specified in terms of the number of instructions required
per frame. The type and number of operations returned by the algorithm
on a per-frame basis are specified for both the encoder and the
decoder. Algorithms are broken down into sub-processing elements, each
having a detailed breakdown of the types of operations and the number
of operations required to complete the sub-processing element. Certain
operations require several instructions in order to be computed. Thus
all operations have associated with them a weight, indicative of this
expansion, and given in Table \ref{tbl:flp-counters} (column
Complexity Weights).

The total number of instructions required per frame is then given by
summing the total number of weighted operations. This number represents
the basic computational complexity of the codec in instructions per
frame. The complexity in WMOPS is then obtained by dividing the number
of operations per frame by the length of the frame in seconds. The
complexity estimates are computed assuming average and worst case
number of operations both per frame and per second. The complexity
is computed separately for the encoder and the decoder.

The operation count performed for the complexity measurement is re-used
to get an estimate of the program memory. This operation count specifies
operations in loops, loop counters, operations in subroutines, and
subroutine counters. Each operation is weighted using the memory weights
from the Table \ref{tbl:flp-counters} (column Memory Weights) to produce
a memory usage in words. Operations inside loops are counted only once.
Similarly operations inside subroutines are counted only once.

\subsection{Tool implementation}
The tool consists of one header file \textit{flc.h} and one ANSI C library
file \textit{flc.c}. Both files must be included into the project to use
this tool. Further, the code must be instrumented using counters defined
in the Table \ref{tbl:flp-counters} (column Counter). Finally the following
functions are needed:
\begin{itemize}
\item To initialize internal data structures, the function
{\tt FLC\_init()} must be called before any counters are defined,
usually at the beginning of the codec algorithm.
\item The function {\tt FLC\_frame\_update()} must be called at the
end of the frame loop in order the FLC tool can keep track of the
per-frame maxima to evaluate the worst-case conditions.
\item The function {\tt FLC\_end()} computes and prints the complexity
of the program and is called usually at the end of the codec algorithm.
\item The separate complexity of subroutine/subsection is estimated by
calling the function {\tt FLC\_sub\_start(name\_of\_subroutine)} that
must be matched with calling the function {\tt FLC\_sub\_end()} at
the end of the subsection/subroutine.
\end{itemize}

Note that once the code is instrumented using the complexity counters
and functions, the compilation switch {\tt DONT\_COUNT} can be
activated to suppress the functionality of the tool with no need of
removing the complexity counters and functions from the code.

\textcolor{blue}{
%
In STL2014, the most important modifications made to the tool is
that incorrect instrumentation that does not match the number of
{\tt FLC\_sub\_start()} and {\tt FLC\_sub\_end()} now halts the
execution of the tool such that the erroneous output results or
crash of the instrumented code is avoided.
%
}

\subsection{Scaling factor}
A scaling factor is used to estimate and print the complexity that
would be obtained after conversion of a floating-point source code
into the corresponding fixed-point implementation. The scaling factor
({\tt FLC\_SCALEFAC}) is defined in file \textit{flc.h} and its value
is set to 1.1.

\subsection{List of complexity measurement counters}

\begin{center}
\begin{longtable}{|m{3.5cm}|m{2.2cm}|m{3.5cm}|m{2.8cm}|m{1.5cm}|}
\caption{\SF Floating-point Complexity Measurement Counters}
\label{tbl:flp-counters}
\\
\hline
Operation&Counter&Example&Complexity Weights (Cycles)&Memory Weights (words)
\endfirsthead
\multicolumn{5}{l}{\small\sl (Table~\ref{tbl:flp-counters} continued from previous page)}\\
\hline
Operation&Counter&Example&Complexity Weights (Cycles)&Memory Weights (words)\\
\hline
\endhead
\hline
\multicolumn{5}{r}{\small\sl (continued on to next page)}\\
\endfoot
\hline
\endlastfoot
\hline
Addition	& ADD()	& a=b+c	& 1	& 1\\
\hline
Multiplication	& MULT()	& a=b*c &	1	& 1 \\
\hline
Multiplication-Addition	& MAC() &	a+=b*c	& 1 &	1 \\
\hline
Move	& MOVE()	& a=b, a[i]=b[i] ONLY assignment or copy	& 1 &	1 \\
\hline
Storing Arithmetic Result in Array	& STORE()	& a[i]=b[i]+c[i]	& 1 (for move only)	& 0\\
\hline
\pagebreak
Logical	& LOGIC()	 & AND, OR, etc.	& 1 &	1 \\
\hline
Shift	& SHIFT()	& a=b$>>$c	& 1 &	1 \\
\hline
Branch (tested with zero)	& BRANCH()	& if, if...then...else...Count 1
BRANCH for each "if" possibility	& 4 &	2 \\
\hline
Division & DIV() &	a=b/c, a=b\%c & 18	& 2 \\
\hline
Square-root	& SQRT()	&a=sqrt(b), a=isqrt(b), a=1/sqrt(b)	& 10	& 2\\
\hline
Transcendental	& TRANS()	& sine, log, arctan	& 25 & 2\\
\hline
Function call	& FUNC()	& a=func(b, c, d) &	2+i, where i=number of arguments passed \& returned	& 2\\
\hline
Loop initialization	&LOOP()	&for (i=0; i$<$n; i++)&	3	&1\\
\hline
\multirow{3}{*}{Indirect addressing}& \multirow{3}{*}{INDIRECT()}	& a=b.c, a=b[c], a=b[c][d],
a=*b, a=*(b+c) & \multirow{3}{*}{2}	&\multirow{3}{*}{2}\\
& & st$->$array & 	& \\
& & st$->$value	&	&\\
\hline
Pointer initialization &	PTR\_INIT()	&a[i]	&1 (charged outside the loop)	&1\\
\hline
Double Precision Addition	&DADD()	&a=b+c	&2&	1\\
\hline
Double Precision Multiplication	&DMULT()	&a=b*c	& 2&	1\\
\hline
Double Precision Move	&DMOVE()	&a=b&	2	&1\\
\hline
Double Precision Division	&DDIV()&	a=b/c	&36&	2\\
\hline
Exponential	& POWER()	& pow, 1.0/x, exp(n)	&25	&2 \\
\hline
Logarithm	&LOG()&	log2, log10, Ln	&25	&2\\
\hline
Extra conditional test& 	TEST()&	used in conjunction with BRANCH &	2	&1\\
\hline
All other operations&	MISC()&	e.g. ABS&	1	&1\\
\hline
\end{longtable}
\end{center}

%% \begin{center}
%%   \tablefirsthead{
%%     \hline
%%     Operation&Counter&Example&Complexity Weights (Cycles)&Memory Weights (words)\\
%%     \hline}
%%   \tablehead{
%%     \hline
%%     \multicolumn{5}{|l|}{\small\sl continued from previous page}\\
%%     \hline
%%     Operation&Counter&Example&Complexity Weights (Cycles)&Memory Weights (words)\\
%%     \hline}
%%   \tabletail{
%%     \hline
%%     \multicolumn{5}{|r|}{\small\sl continued on next page}\\
%%     \hline}
%%   \tablelasttail{\hline}
%%   % \bottomcaption{\SF Floating-point Complexity Measurement Counters
%%   % 		\label{tbl:flp-counters}}
%%   \topcaption{\SF Floating-point Complexity Measurement Counters
%%     \label{tbl:flp-counters}}
%%   \begin{supertabular}{|m{4cm}|m{2.2cm}|m{3.6cm}|m{3.6cm}|m{2cm}|}
%%     \hline
%%     Addition	& ADD()	& a=b+c	& 1	& 1\\
%%     \hline
%%     Multiplication	& MULT()	& a=b*c &	1	& 1 \\
%%     \hline
%%     Multiplication-Addition	& MAC() &	a+=b*c	& 1 &	1 \\
%%     \hline
%%     Move	& MOVE()	& a=b, a[i]=b[i] ONLY assignment or copy	& 1 &	1 \\
%%     \hline
%%     Storing Arithmetic Result in Array	& STORE()	& a[i]=b[i]+c[i]	& 1 (for move only)	& 0\\
%%     \hline
%%     Logical	& LOGIC()	 & AND, OR, etc.	& 1 &	1 \\
%%     \hline
%%     Shift	& SHIFT()	& a=b$>>$c	& 1 &	1 \\
%%     \hline
%%     Branch (tested with zero)	& BRANCH()	& if, if...then...else...Count 1
%%     BRANCH for each "if" possibility	& 4 &	2 \\
%%     \hline
%%     Division & DIV() &	a=b/c, a=b\%c & 18	& 2 \\
%%     \hline
%%     Square-root	& SQRT()	&a=sqrt(b), a=isqrt(b), a=1/sqrt(b)	& 10	& 2\\
%%     \hline
%%     Transcendental	& TRANS()	& sine, log, arctan	& 25 & 2\\
%%     \hline
%%     Function call	& FUNC()	& a=func(b, c, d) &	2+i, where i=number of arguments passed \& returned	& 2\\
%%     \hline
%%     Loop initialization	&LOOP()	&for (i=0; i$<$n; i++)&	3	&1\\
%%     \hline
%%     \multirow{3}{*}{Indirect addressing}& \multirow{3}{*}{INDIRECT()}	& a=b.c, a=b[c], a=b[c][d],
%%     a=*b, a=*(b+c) & \multirow{3}{*}{2}	&\multirow{3}{*}{2}\\
%%     & & st$->$array & 	& \\
%%     & & st$->$value	&	&\\
%%     \hline
%%     Pointer initialization &	PTR\_INIT()	&a[i]	&1 (charged outside the loop)	&1\\
%%     \hline
%%     Double Precision Addition	&DADD()	&a=b+c	&2&	1\\
%%     \hline
%%     Double Precision Multiplication	&DMULT()	&a=b*c	& 2&	1\\
%%     \hline
%%     Double Precision Move	&DMOVE()	&a=b&	2	&1\\
%%     \hline
%%     Double Precision Division	&DDIV()&	a=b/c	&36&	2\\
%%     \hline
%%     Exponential	& POWER()	& pow, 1.0/x, exp(n)	&25	&2 \\
%%     \hline
%%     Logarithm	&LOG()&	log2, log10, Ln	&25	&2\\
%%     \hline
%%     Extra conditional test& 	TEST()&	used in conjunction with BRANCH &	2	&1\\
%%     \hline
%%     All other operations&	MISC()&	e.g. ABS&	1	&1\\
%%     \hline
%%   \end{supertabular}
%% \end{center}

\subsection{Examples of instrumentation of the code}
The rules to compute the complexity are general and when they are
implemented, some choices must be done. Table \ref{tbl:flp-usage}
contains some examples to show where the counters should be placed.

\begin{center}
\begin{longtable}{|m{4.5cm}|m{4.5cm}|m{4cm}|m{2.0cm}|}
\caption{\SF Usage of floating-point complexity measurement counters
\label{tbl:flp-usage}}
\\
\hline
Operation	& Counter used &	Explanation	& Reference\\
\hline
\endfirsthead
\multicolumn{4}{l}{\small\sl (Table~\ref{tbl:flp-usage} continued from previous page)}\\
\hline
Operation	& Counter used &	Explanation	& Reference\\
\hline
\endhead
\hline
\multicolumn{4}{r}{\small\sl (continued on to next page)}\\
\endfoot
\hline
\endlastfoot
if (a!=b $||$ c==d)\{...\}	& ADD(2); BRANCH(1); TEST(1);	&
BRANCH for if, TEST for additional condition, ADD for
two tests against non-zero value	&\\
\hline
if (a!=b \&\& c==d)\{\} else if( a==c )\{\} & ADD(3);
BRANCH(2);TEST(1); & & \\
\hline
b = a / L	& MULT(1); &	When L is constant; (1/L) is a constant too,
So b = a * (1/L)	& \\
\hline
*a = *b	& MOVE(1);	& Copy 	& Table \ref{tbl:flp-counters}, Move\\
\hline
for(i=0;i$<$L;i++) \{x[i]=a[i]+b[i];\}	& LOOP(1);(before)
ADD(1); STORE(1);(inside)	& When a loop begins with an offset,
initialization of pointer is counted	 & \\
for(i=c;i$<$L;i++) \{x[i]=a[i]+b[i];\}	& PTR\_INIT(3), LOOP(1); (before)
ADD(1); STORE(1); (inside)	& 	& \\
\hline
\&pt = \&(a+L)	& PTR\_INIT(1);	& if L is constant and b is variable,
ADD is counted		& \\
\&pt = \&(a+b)	&ADD(1); PTR\_INIT(1);	& & \\
\hline
a=func(b) or a[i]=func(b)	& FUNC(2);	&The value returned by function is counted in FUNC().
MOVE or STORE are not counted in that case	&\\
\hline
a = *b	& INDIRECT(1);	& &	Table \ref{tbl:flp-counters}, Pointer Initialization \\
for(i=0;i$<$L;i++) \{a=*b++;\} a=*b;	& MOVE(1) in the loop MOVE(1) outside the loop
& Use of MOVE outside the loop because the pointer is already initialized
&	Table \ref{tbl:flp-counters}, Move \\
\hline
pt\_a += M	& PTR\_INIT(1);	& M is constant, so this is equivalent to pt\_a=\&pt\_a+M	&\\
\hline
pt\_a += m	& ADD(1); PTR\_INIT(1);	& m is variable, so this is equivalent to  pt\_a=\&pt\_a+m	& \\
\hline
*a=0.99*b	& MULT(1); STORE(1); &	A mathematical result is stored with a pointer & \\
for(i=0;i$<$L;i++) \{a=*b+a;\} & PTR\_INIT(1); (before loop) ADD(1); (inside)
& If a pointer is initialized before the loop, no need to count INDIRECT(1) inside
& \\
\hline
a[b][c]=x[y][z]	& MOVE(1);	& &	Table \ref{tbl:flp-counters}, Move \\
\hline
switch(a)\{ & & Can be replaced by: &\\
case b:break; & \multirow{2}{4.5cm}{ADD(2); BRANCH(2) before switch} &
if (a==b) \{...\} &\\
case c: break; & & else if (a==c) \{...\} &\\
default:break; & & else\{...\} &\\
\} & & & \\
\hline
& & \multirow{4}{4cm}{Use INDIRECT(2) to remove
double indirection and call MOVE(2) to copy data}	& \\
st$->$a[0]=t[2]; & INDIRECT(2); & \\
st$->$a[1]=t[3];	& MOVE(2) & & \\
& & &\\
& & &\\
%& & &\\
\hline
(*rnd\_T0)++	& ADD(1); STORE(1);	&it can be replaced by
*rnd\_T0=*rnd\_T0+1;	& \\
\hline
pit\_shrp( code,  &	FUNC(4);&	  \multirow{2}{4cm}{*round\_T0 is passed by indirection}	&\\
PIT\_SHARP, *round\_T0, L\_SUBFR); &	INDIRECT(1);& 	&\\
\hline
indice[0] = & \multirow{2}{*}{INDIRECT(2);}	& \multirow{2}{*}{Double indirection} &\\
indirect\_dico1[indice[0]];	& & &\\
\hline
sqr = indice[0] +indice[1] +indice[2] +indice[3] +indice[4];&	PTR\_INIT(1);
ADD(4);	&Can be done in a loop	&\\
\hline
\end{longtable}
\end{center}

%% \begin{center}
%% \tablefirsthead{
%% \hline
%% Operation	& Counter used &	Explanation	& Reference \\
%% \hline}
%% \tablehead{
%% \hline
%% \multicolumn{4}{|l|}{\small\sl continued from previous page}\\
%% \hline
%% Operation	& Counter used &	Explanation	& Reference \\
%% \hline}
%% \tabletail{
%% \hline
%% \multicolumn{4}{|r|}{\small\sl continued on next page}\\
%% \hline}
%% \tablelasttail{\hline}
%% \bottomcaption{\SF Usage of floating-point complexity measurement counters
%%          \label{tbl:flp-usage}}
%% \renewcommand{\arraystretch}{1.5}
%% \begin{supertabular}{|m{4.5cm}|m{4.5cm}|m{4cm}|m{2.5cm}|}
%% \hline
%% if (a!=b $||$ c==d)\{...\}	& ADD(2); BRANCH(1); TEST(1);	&
%% BRANCH for if, TEST for additional condition, ADD for
%% two tests against non-zero value	&\\
%% \hline
%% if (a!=b \&\& c==d)\{\} else if( a==c )\{\} & ADD(3);
%% BRANCH(2);TEST(1); & & \\
%% \hline
%% b = a / L	& MULT(1); &	When L is constant; (1/L) is a constant too,
%% So b = a * (1/L)	& \\
%% \hline
%% *a = *b	& MOVE(1);	& Copy 	& Table \ref{tbl:flp-counters}, Move\\
%% \hline
%% for(i=0;i$<$L;i++) \{x[i]=a[i]+b[i];\}	& LOOP(1);(before)
%% ADD(1); STORE(1);(inside)	& When a loop begins with an offset,
%% initialization of pointer is counted	 & \\
%% for(i=c;i$<$L;i++) \{x[i]=a[i]+b[i];\}	& PTR\_INIT(3), LOOP(1); (before)
%%  ADD(1); STORE(1); (inside)	& 	& \\
%% \hline
%% \&pt = \&(a+L)	& PTR\_INIT(1);	& if L is constant and b is variable,
%% ADD is counted		& \\
%% \&pt = \&(a+b)	&ADD(1); PTR\_INIT(1);	& & \\
%% \hline
%% a=func(b) or a[i]=func(b)	& FUNC(2);	&The value returned by function is counted in FUNC().
%% MOVE or STORE are not counted in that case	&\\
%% \hline
%% a = *b	& INDIRECT(1);	& &	Table \ref{tbl:flp-counters}, Pointer Initialization \\
%% for(i=0;i$<$L;i++) \{a=*b++;\} a=*b;	& MOVE(1) in the loop MOVE(1) outside the loop
%% & Use of MOVE outside the loop because the pointer is already initialized
%% &	Table \ref{tbl:flp-counters}, Move \\
%% \hline
%% pt\_a += M	& PTR\_INIT(1);	& M is constant, so this is equivalent to pt\_a=\&pt\_a+M	&\\
%% \hline
%% pt\_a += m	& ADD(1); PTR\_INIT(1);	& m is variable, so this is equivalent to  pt\_a=\&pt\_a+m	& \\
%% \hline
%% *a=0.99*b	& MULT(1); STORE(1); &	A mathematical result is stored with a pointer & \\
%% for(i=0;i$<$L;i++) \{a=*b+a;\} & PTR\_INIT(1); (before loop) ADD(1); (inside)
%% & If a pointer is initialized before the loop, no need to count INDIRECT(1) inside
%% & \\
%% \hline
%% a[b][c]=x[y][z]	& MOVE(1);	& &	Table \ref{tbl:flp-counters}, Move \\
%% \hline
%% switch(a)\{
%% case b:break;
%% case c: break;
%% default:break;
%% \} & ADD(2); BRANCH(2) before switch	& Can be replaced by
%% if (a==b) \{...\} else if(a==c) \{...\} else \{...\} & \\
%% \hline
%% & & &\\
%% st$->$a[0]=t[2]; & INDIRECT(2); 	& \multirow{3}{4cm}{Use INDIRECT(2) to remove
%% double indirection and call MOVE(2) to copy data}	& \\
%% st$->$a[1]=t[3];	& MOVE(2) & & \\
%% & & &\\
%% %& & &\\
%% %& & &\\
%% \hline
%% (*rnd\_T0)++	& ADD(1); STORE(1);	&it can be replaced by
%% *rnd\_T0=*rnd\_T0+1;	& \\
%% \hline
%% pit\_shrp( code,  &	FUNC(4);&	  \multirow{2}{4cm}{*round\_T0 is passed by indirection}	&\\
%% PIT\_SHARP, *round\_T0, L\_SUBFR); &	INDIRECT(1);& 	&\\
%% \hline
%% indice[0] = & \multirow{2}{*}{INDIRECT(2);}	& \multirow{2}{*}{Double indirection} &\\
%% indirect\_dico1[indice[0]];	& & &\\
%% \hline
%% sqr = indice[0] +indice[1] +indice[2] +indice[3] +indice[4];&	PTR\_INIT(1);
%% ADD(4);	&Can be done in a loop	&\\
%% \hline
%% \end{supertabular}
%% \end{center}

\subsection{Tests and Portability}
Compiled and tested on a PC (Windows XP) platform with MS Visual C++ 2005 and
in Cygwin with gcc (version 3.4.4).

\subsection{Example code}
A demonstration program, \textit{flc\_example.c}, serves as an example
and guideline for the illustration of the tool usage. To compile a
demonstration program, Windows MSVC and Cygwin gcc makefiles are
enclosed as \textit{makefile.cl} and \textit{makefile.unx},
respectively.

Below you can find the output screen when executing the demonstration program.
\begin{verbatim}
===== Call Graph and total ops per function =====
Function                     Calls              Ops         Ops/Call
-----------
ROOT                             1                0                0
-Autocorr                      100           975900             9759
--Set_Zero                     200             4100             20.5
-Lev_dur                       100            99600              996

===== Program Memory Usage by Function =====\\

Function            ADD  MULT   MAC  MOVE STORE LOGIC SHIFT BRNCH   DIV
-----------
Set_Zero              0     0     0     1     0     0     0     0     0
Autocorr              1     4    17     0    21     0     0     2     0
Lev_dur               0     2     5     5     3     0     1     1     2
ROOT                  0     0     0     0     0     0     0     0     0
-----------
totals                1     6    22     6    24     0     1     3     2

--------------------------------


Function           SQRT TRANC  FUNC  LOOP   IND   PTR  MISC
-----------
Set_Zero              0     0     0     1     0     1     0
Autocorr              0     0     2     2     1     6     0
Lev_dur               0     0     0     3     4     5     0
ROOT                  0     0     2     0     0     0     0
-----------
totals                0     0     4     6     5    12     0


===== SUMMARY =====
Total Ops: 1.0796e+06
Total Program ROM usage: 83  (word)


===== Per Frame Summary =====
Number of Frames: 100
Average Ops/frame: 10796.00   Max Ops/frame: 10796

===== ESTIMATED COMPLEXITY (Frame length is 20.00 ms) =====
Maximum complexity: 0.539800 WMOPS
Average complexity: 0.539800 WMOPS

Estimated fixed point complexity with 1.1 scaling factor:
Maximum complexity: 0.593780 WMOPS
Average complexity: 0.593780 WMOPS

\end{verbatim}
