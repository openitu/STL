%=============================================================================
% ..... THIS IS chapter{BASOP: ITU-T Basic Operators } .....
% ... Revision:
% Nov.2000 - SG16 Plenary
% Apr.2005 - STL2005 revision -- Cyril Guillaumé & Stéphane Ragot - stephane.ragot@francetelecom.com
%                                Karim Djafarian - k-djafarian@ti.com
% Nov.2008 - STL2009 revision -- Yusuke Hiwasaki, Noboru Harada, NTT
%                             - Balazs Kovesi, Claude Lamblin, France Telecom
% Jun.2013 - STL2014 revision -- Yusuke Hiwasaki, NTT
%=============================================================================
\chapter{BASOP: ITU-T Basic Operators}
%=============================================================================

%\newcommand{\newop}{\ensuremath{\Rightarrow} \textsc{New in v2.0}}
\def\newop20{\begin{math} \rightarrow \textsc{New in v2.0} \end{math}}

%----------------------------------------------------------------------
\section{Overview of basic operator libraries}
%----------------------------------------------------------------------

Since the standardization of G.729 and G.723.1
\footnote{For older standards (G.711, G.726, G722, G.727, G.728), their C-codes are included in the software tools library.},
ANSI-C source codes constitute integral parts of the ITU-T speech and audio coding Recommendations and their specification relies on bit-exact fixed-point C code using library of basic operators that simulates DSP operations.
The fixed-point descriptions of G.723.1 and G.729 are based on 16- and 32-bit arithmetic operations defined by ETSI in 1993 for the standardisation of the half-rate GSM speech codec.
These operations are also used to define the GSM enhanced full-rate (EFR) and adaptive multi-rate (AMR) speech codecs \cite{G.191}.

In STL2005, the version 2.0 of the ITU-T Basic Operators bears the following additional features compared to the version 1.x:
\begin{enumerate}
    \item New 16-bit and 32-bit operators;
    \item New 40-bit operators;
    \item New control flow operators;
    \item Revised complexity weight of version 1.x basic operators in order to reflect the evolution of processor capabilities.
\end{enumerate}

In STL2009, that is version 2.3, in addition to some minor fixes in the ITU-T Basic Operators and guidelines of data move counters, the following new additional tools were added:
\begin{itemize}
    \item Program ROM estimation tool for fixed-point C Code;
    \item Complexity evaluation tool for floating-point C Code.
\end{itemize}

In STL2019, new operators were introduced to account for modern DSP architectures:
\begin{enumerate}
    \item Enhanced 32-bit operators;
    \item New unsigned 32-bit operators;
    \item New 64-bit operators;
    \item New complex operators;
    \item New control flow operators;
    \item Revised complexity weights in order to reflect the evolution of processor capabilities.
\end{enumerate}

Table \ref{tbl:operators-weight} provides an overview of the complexity weight history for each basic operator.

%----------------------------------------------------------------------
\section{Description of the 16-bit and 32-bit basic operators and associated weights}
%----------------------------------------------------------------------

This section describes the different 16-bit and 32-bit basic operators available in the STL, and are organized by complexity (``weights'').
The complexity values to be considered (since the publication of the STL2005) are the ones related to the version 2.0 and subsequent versions of the module.
When the basic operator did not exist in the previous version of the library (version 1.x), it is highlighted as follows:
\newop20 . In STL2009, {\tt round()} operator was renamed as {\tt round\_fx()} and {\tt saturate()}, function was made unaccessible from applications, because it was an internal procedure.

\subsection{Variable definitions}

The variables used in the operators are signed integers in 2's complements representation, defined by:

{\tt v1}, {\tt v2}: 16-bit variables\\
{\tt L\_v1}, {\tt L\_v2}, {\tt L\_v3}: 32-bit variables

%-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.
\subsection{Operators with complexity weight of 1}
\subsubsection{Arithmetic operators (multiplication excluded)}

%........................................................
\NewOperator{add(v1, v2)}

Performs the addition ({\tt v1}+{\tt v2}) with overflow control and saturation; the 16-bit result is set at {\tt +32767} when overflow occurs or at {\tt -32768} when underflow occurs.

%........................................................
\NewOperator{sub(v1, v2)}

Performs the subtraction ({\tt v1}-{\tt v2}) with overflow control and saturation; the 16-bit result is set at {\tt +32767} when overflow occurs or at {\tt -32768} when underflow occurs.

%........................................................
\NewOperator{abs\_s(v1)}

Absolute value of v1.
If {\tt v1} is {\tt -32768}, returns {\tt 32767}.

%........................................................
\NewOperator{shl(v1, v2)}

Arithmetically shift the 16-bit input {\tt v1} left {\tt v2} positions.
Zero fill the {\tt v2} LSB of the result.
If {\tt v2} is negative, arithmetically shift {\tt v1} right by {\tt -v2} with sign extension.
Saturate the result in case of underflows or overflows.

%........................................................
\NewOperator{shr(v1, v2)}

Arithmetically shift the 16-bit input {\tt v1} right {\tt v2} positions with sign extension.
If v2 is negative, arithemtically shift {\tt v1} left by {\tt -v2} and zero fill the {\tt -v2} LSB of the result:

\rulex{2mm}{\tt shr(v1, v2) = shl(v1, -v2)}

Saturate the result in case of underflows or overflows.

%........................................................
\NewOperator{negate(v1)}

Negate {\tt v1} with saturation, saturate in the case when input is {\tt -32768}:

\rulex{2mm}{\tt negate(v1) = sub(0, v1)}

%........................................................
\NewOperator{s\_max(v1, v2)} \newop20

Compares two 16-bit variables {\tt v1} and {\tt v2} and returns the maximum value.

%........................................................
\NewOperator{s\_min(v1, v2)} \newop20

Compares two 16-bit variables {\tt v1} and {\tt v2} and returns the minimum value.

%........................................................
\NewOperator{norm\_s(v1)}

Produces the number of left shifts needed to normalize the 16-bit variable {\tt v1} for positive values on the interval with minimum of {\tt 16384} and maximum {\tt 32767}, and for negative values on the interval with minimum of {\tt -32768} and maximum of {\tt
-16384};
in order to normalise the result, the following operation must be done:

\rulex{2mm}{\tt norm\_v1 = shl(v1, norm\_s(v1))}

%........................................................
\NewOperator{L\_add(L\_v1, L\_v2)}

This operator implements 32-bit addition of the two 32-bit variables ({\tt L\_v1}+{\tt L\_v2}) with overflow control and saturation;
the result is set at {\tt +2147483647} when overflow occurs or at {\tt -2147483648} when underflow occurs.

%........................................................
\NewOperator{L\_sub(L\_v1, L\_v2)}

32-bit subtraction of the two 32-bit variables ({\tt L\_v1}--{\tt L\_v2}) with overflow control and saturation;
the result is set at {\tt +2147483647} when overflow occurs or at {\tt -2147483648} when underflow occurs.

%........................................................
\NewOperator{L\_abs(L\_v1)}

Absolute value of {\tt L\_v1}, with {\tt L\_abs(-2147483648)=\-2147483647}.

%........................................................
\NewOperator{L\_shl(L\_v1, v2)}

Arithmetically shift the 32-bit input {\tt L\_v1} left {\tt v2} positions.
Zero fill the {\tt v2} LSB of the result.
If {\tt v2} is negative, arithmetically shift {\tt L\_v1} right by {\tt -v2} with sign extension.
Saturate the result in case of underflows or overflows.

%........................................................
\NewOperator{L\_shr(L\_v1, v2)}

Arithmetically shift the 32-bit input {\tt L\_v1} right {\tt v2} positions with sign extension.
If {\tt v2} is negative, arithmetically shift {\tt L\_v1} left by {\tt -v2} and zero fill the {\tt -v2} LSB of the result.
Saturate the result in case of underflows or overflows.


%........................................................
\NewOperator{L\_negate(L\_v1)}

Negate the 32-bit {\tt L\_v1} parameter with saturation, saturate in the case where input is {\tt -2147483648}.

%........................................................
\NewOperator{L\_max(L\_v1, L\_v2)} \newop20

Compares two 32-bit variables L\_v1 and L\_v2 and returns the maximum value.

%........................................................
\NewOperator{L\_min(L\_v1, L\_v2)} \newop20

Compares two 32-bit variables L\_v1 and L\_v2 and returns the minimum value.

%........................................................
\NewOperator{norm\_l(L\_v1)}

Produces the number of left shifts needed to normalise the 32-bit variable {\tt L\_v1} for positive values on the interval with
minimum of {\tt 1073741824} and maximum {\tt 2147483647}, and for negative values on the interval with minimum of {\tt -2147483648} and maximum of {\tt -1073741824};
in order to normalise the result, the following operation must be done:

\rulex{2mm}{\tt L\_norm\_v1 = L\_shl(L\_v1, norm\_l(L\_v1))}

%------------------------------------------------------------------
\subsubsection{Multiplication operators}

%........................................................
\NewOperator{i\_mult(v1, v2)}

Multiply two 16-bit words {\tt v1} and {\tt v2} returning a 16-bit word with overflow control.

%........................................................
\NewOperator{L\_mult(v1, v2)}

Operator {\tt L\_mult} implements the 32-bit result of the multiplication of {\tt v1} times {\tt v2} with one shift left, i.e.

\rulex{2mm}{\tt L\_mult(v1, v2) = L\_shl((v1 $\times$ v2), 1)}

Note that {\tt L\_mult(-32768,-32768) = 2147483647}.

%........................................................
\NewOperator{L\_mult0(v1, v2)}

Operator {\tt L\_mult0} implements the 32-bit result of the multiplication of {\tt v1} times {\tt v2} {\em without} left shift, i.e.

\rulex{2mm}{\tt L\_mult0(v1, v2) = (v1 $\times$ v2)}

%........................................................
\NewOperator{mult(v1, v2)}

Performs the multiplication of {\tt v1} by {\tt v2} and gives a 16-bit result which is scaled, i.e.

\rulex{2mm}{\tt mult(v1, v2) =  extract\_l(L\_shr((v1 times v2),15))}

Note that {\tt mult(-32768,-32768) = 32767}.

%........................................................
\NewOperator{mult\_r(v1, v2)}

Same as {\tt mult()} but with rounding, i.e.

\rulex{2mm}{\tt mult\_r(v1, v2)
= extract\_l(L\_shr(((v1 $\times$ v2)+16384), 15))}

and {\tt mult\_r(-32768, -32768) = 32767}.

%........................................................
\NewOperator{L\_mac(L\_v3, v1, v2)}

Multiply {\tt v1} by {\tt v2} and shift the result left by 1.
Add the 32-bit result to {\tt L\_v3} with saturation, return a 32-bit result:

\rulex{2mm}{\tt L\_mac(L\_v3, v1, v2) = L\_add(L\_v3, L\_mult(v1, v2))}

%........................................................
\NewOperator{L\_mac0(L\_v3, v1, v2)}

Multiply {\tt v1} by {\tt v2} {\em without} left shift.
Add the 32-bit result to {\tt L\_v3} with saturation, returning a 32-bit result:

\rulex{2mm}{\tt L\_mac0(L\_v3, v1, v2) = L\_add(L\_v3, L\_mult0(v1, v2))}

%........................................................
\NewOperator{L\_macNs(L\_v3, v1, v2)}

Multiply {\tt v1} by {\tt v2} and shift the result left by 1.
Add the 32-bit result to {\tt L\_v3} without saturation, return a 32-bit result.
Generates carry and overflow values:

\rulex{2mm}{\tt L\_macNs(L\_v3, v1, v2) = L\_add\_c(L\_v3, L\_mult(v1, v2))}

%........................................................
\NewOperator{mac\_r(L\_v3, v1, v2)}

Multiply {\tt v1} by {\tt v2} and shift the result left by 1.
Add the 32-bit result to {\tt L\_v3} with saturation.
Round the 16 least significant bits of the result into the 16 most significant bits with saturation and shift the result right by 16.
Returns a 16-bit result.

\rulex{2mm}{\tt mac\_r(L\_v3, v1, v2) = \\
\rulex{5mm} round\_fx(L\_mac(L\_v3, v1, v2))=\\
\rulex{5mm} extract\_h(L\_add(L\_add(L\_v3, L\_mult(v1, v2)), 32768))}

%........................................................
\NewOperator{L\_msu(L\_v3, v1, v2)}

Multiply {\tt v1} by {\tt v2} and shift the result left by 1.
Subtract the 32-bit result from {\tt L\_v3} with saturation, return a 32-bit result:

\rulex{2mm}{\tt L\_msu(L\_v3, v1, v2) = L\_sub(L\_v3, L\_mult(v1, v2))}.

%........................................................
\NewOperator{L\_msu0(L\_v3, v1, v2)}

Multiply {\tt v1} by {\tt v2} {\em without} left shift.
Subtract the 32-bit result from {\tt L\_v3} with saturation, returning a 32-bit result:

\rulex{2mm}{\tt L\_msu0(L\_v3, v1, v2) = L\_sub(L\_v3, L\_mult0(v1, v2))}.

%........................................................
\NewOperator{L\_msuNs(L\_v3, v1, v2)}

\textcolor{blue}{
%
Caution: The sub-routine {\tt L\_sub\_c} evoked from this function is reported to have a carry problem.
Use of this operator in current and past release of STL is NOT recommended.
%
}

Multiply {\tt v1} by {\tt v2} and shift the result left by 1.
Subtract the 32-bit result from {\tt L\_v3} without saturation, return a 32-bit result.
Generates carry and overflow values:


\rulex{2mm}{\tt L\_msuNs(L\_v3, v1, v2) = L\_sub\_c(L\_v3, L\_mult(v1, v2))}

%........................................................
\NewOperator{L\_mls(L\_v1, v2)}

Performs a multiplication of a 32-bit variable {\tt L\_v1} by a 16-bit variable {\tt v2}, returning a 32-bit value.

%........................................................
\NewOperator{msu\_r(L\_v3, v1, v2)}

Multiply {\tt v1} by {\tt v2} and shift the result left by 1.
Subtract the 32-bit result from {\tt L\_v3} with saturation.
Round the 16 least significant bits of the result into the 16 bits with saturation and shift the result right by 16.
Returns a 16-bit result.

\ \\
\rulex{2mm}{\tt msu\_r(L\_v3, v1, v2) = \\
\rulex{5mm} round\_fx(L\_msu(L\_v3, v1, v2))= \\
\rulex{5mm} extract\_h(L\_add(L\_sub(L\_v3, L\_mult(v1, v2)), 32768))}

\subsubsection{Logical operators}

%........................................................
\NewOperator{s\_and(v1, v2)} \newop20

Performs a bit wise AND between the two 16-bit variables v1 and v2.

%........................................................
\NewOperator{s\_or(v1, v2)} \newop20

Performs a bit wise OR between the two 16-bit variables v1 and v2.

%........................................................
\NewOperator{s\_xor(v1, v2)} \newop20

Performs a bit wise XOR between the two 16-bit variables v1 and v2.

%........................................................
\NewOperator{lshl(v1, v2)} \newop20

Logically shifts left the 16-bit variable v1 by v2 positions:

\rulex{10mm} -- \pbox{150mm}{if v2 is negative, v1 is shifted to the least significant bits by (-v2) positions with insertion of 0 at the most significant bit.}

\rulex{10mm} -- \pbox{150mm}{if v2 is positive, v1 is shifted to the most significant bits by (v2) positions without saturation control.}

%........................................................
\NewOperator{lshr(v1, v2)} \newop20

Logically shifts right the 16-bit variable v1 by v2 positions:

\rulex{10mm} -- \pbox{150mm}{if v2 is positive, v1 is shifted to the least significant bits by (v2) positions with insertion of 0 at the most significant bit.}

\rulex{10mm} -- \pbox{150mm}{if v2 is negative, v1 is shifted to the most significant bits by (-v2) positions without saturation control.}


%........................................................
\NewOperator{L\_and(L\_v1, L\_v2)} \newop20

Performs a bit wise AND between the two 32-bit variables {\tt L\_v1} and {\tt L\_v2}.


%........................................................
\NewOperator{L\_or(L\_v1, L\_v2)} \newop20

Performs a bit wise OR between the two 32-bit variables {\tt L\_v1} and {\tt L\_v2}.


%........................................................
\NewOperator{L\_xor(L\_v1, L\_v2)} \newop20

Performs a bit wise XOR between the two 32-bit variables {\tt L\_v1} and {\tt L\_v2}.


%........................................................
\NewOperator{L\_lshl(L\_v1, v2)} \newop20

Logically shifts left the 32-bit variable {\tt L\_v1} by v2 positions:

\rulex{10mm} -- \pbox{150mm}{if v2 is negative, {\tt L\_v1} is shifted to the least significant bits by (-v2) positions with insertion of 0 at the most significant bit.}

\rulex{10mm} -- \pbox{150mm}{if v2 is positive, {\tt L\_v1} is shifted to the most significant bits by (v2) positions without saturation control.}


%........................................................
\NewOperator{L\_lshr(L\_v1, v2)} \newop20

Logically shifts right the 32-bit variable {\tt L\_v1} by v2 positions:

\rulex{10mm} -- \pbox{150mm}{if v2 is positive, {\tt L\_v1} is shifted to the least significant bits by (v2) positions with insertion of 0 at the most significant bit.}

\rulex{10mm} -- \pbox{150mm}{if v2 is negative, {\tt L\_v1} is shifted to the most significant bits by (-v2) positions without saturation control.}


\subsubsection{Data type conversion operators}

%........................................................
\NewOperator{extract\_h(L\_v1)}

Return the 16 MSB of {\tt L\_v1}.

%........................................................
\NewOperator{extract\_l(L\_v1)}

Return the 16 LSB of {\tt L\_v1}.

%........................................................
\NewOperator{round\_fx(L\_v1)}

Round the lower 16 bits of the 32-bit input number into the most significant 16 bits with saturation.
Shift the resulting bits right by 16 and return the 16-bit number:

\rulex{2mm}{\tt round\_fx(L\_v1) = extract\_h(L\_add(L\_v1, 32768))}

Initially, this operator was named ``{\tt round()}'', however to avoid the conflict with C standard libraries, this operator was renamed from version 2.3. There are no functionality changes.

%........................................................
\NewOperator{L\_deposit\_h(v1)}

Deposit the 16-bit {\tt v1} into the 16 most significant bits of the 32-bit output.
The 16 least significant bits of the output are zeroed.

%........................................................
\NewOperator{L\_deposit\_l(v1)}

Deposit the 16-bit {\tt v1} into the 16 least significant bits of the 32-bit output.
The 16 most significant bits of the output are sign-extended.


%........................................................
\NewOperator{L\_sat(L\_v1)}

The 32-bit variable L\_v1 is set to {\tt 2147483647} if an overflow occurred, or {\tt -2147483648} if an underflow occurred, on the most recent {\tt L\_add\_c()}, {\tt L\_sub\_c()}, {\tt L\_macNs()} or {\tt L\_msuNs()} operations.
The carry and overflow values are binary variables which can be tested and assigned values.


\subsection{Operators with complexity weight of 2}

%........................................................
\NewOperator{L\_add\_c(L\_v1, L\_v2)}

Performs the 32-bit addition with carry.
No saturation.
Generates carry and overflow values.
The carry and overflow values are binary variables which can be tested and assigned values.

%........................................................
\ \\
\NewOperator{L\_sub\_c(L\_v1, L\_v2)}

\textcolor{blue}{
%
  Caution: This {\tt L\_sub\_c} operator is reported to have a carry problem.
  This problem has not been mended and volunteers are seeked to correct it.
  Use of this operator in current and past release of STL is NOT recommended.
%
}

Performs the 32-bit subtraction with carry (borrow).
Generates carry (borrow) and overflow values.
No saturation.
The carry and overflow values are binary variables which can be tested and assigned values.

%........................................................
\NewOperator{shr\_r(v1, v2)}

Same as {\tt shr()} but with rounding.
Saturate the result in case of underflows or overflows.

{\tt
\rulex{2mm} if (v2$>$0) then\\
\rulex{4mm} if (sub(shl(shr(v1,v2),1), shr(v1,sub(v2,1)))==0) \\
\rulex{4mm} then shr\_r(v1, v2) = shr(v1, v2)\\
\rulex{4mm} else shr\_r(v1, v2) = add(shr(v1, v2), 1)

\rulex{2mm} else if (v2 $\leq$ 0) \\
\rulex{4mm} then shr\_r(v1, v2) = shr(v1, v2)}

%........................................................
\NewOperator{L\_shr\_r(L\_v1, v2)}

Same as {\tt L\_shr(v1,v2)} but with rounding.
Saturate the result in case of underflows or overflows:

{\tt
\rulex{2mm} if (v2 $>$ 0) then\\
\rulex{4mm} if (L\_sub(L\_shl(L\_shr(L\_v1,v2),1), L\_shr(L\_v1, sub(v2,1)))) == 0 \\
\rulex{4mm} then L\_shr\_r(L\_v1, v2) = L\_shr(L\_v1, v2)\\
\rulex{4mm} else L\_shr\_r(L\_v1, v2) = L\_add(L\_shr(L\_v1, v2), 1)

\rulex{2mm} if (v2 $\leq$ 0) \\
\rulex{4mm} then L\_shr\_r(L\_v1, v2) = L\_shr(L\_v1, v2)}

%........................................................
\NewOperator{shl\_r(v1, v2)}

Same as {\tt shl()} but with rounding.
Saturate the result in case of underflows or overflows:

\rulex{2mm}{\tt shl\_r(v1, v2) = shr\_r(v1, -v2)}

\textbf{Note:} \hfill \pbox{145mm}{In v1.x this operator was called \textbf{shift\_r(v1, v2)}; in the STL2005, both names can be used.}

%........................................................
\NewOperator{L\_shl\_r(L\_v1, v2)}

Same as {\tt L\_shl(L\_v1,v2)} but with rounding.
Saturate the result in case of underflows or overflows.

\rulex{2mm}{\tt L\_shl\_r(L\_v1, v2) = L\_shr\_r(L\_v1, -v2)}

In v1.x, this operator is called \textbf{L\_shift\_r(L\_v1, v2}) ; both names can be used.


%________________________________________________________
\subsection{Operators with complexity weight of 3}

%________________________________________________________
\subsubsection{Logical Operators}

%........................................................
\NewOperator{rotl(v1, v2, * v3)} \newop20

Rotates the 16-bit variable v1 by 1 bit to the most significant bits.
Bit 0 of v2 is copied to the least significant bit of the result before it is returned.
The most significant bit of v1 is copied to the bit 0 of v3 variable.

%........................................................
\NewOperator{rotr(v1, v2, * v3)} \newop20

Rotates the 16-bit variable v1 by 1 bit to the least significant bits.
Bit 0 of v2 is copied to the most significant bit of the result before it is returned.
The least significant bit of v1 is copied to the bit 0 of v3 variable.

%........................................................
\NewOperator{L\_rotl(L\_v1, v2, * v3)} \newop20

Rotates the 32-bit variable L\_v1 by 1 bit to the most significant bits.
Bit 0 of v2 is copied to the least significant bit of the result before it is returned.
The most significant bit of L\_v1 is copied to the bit 0 of v3 variable.

%........................................................
\NewOperator{L\_rotr(L\_v1, v2, * v3)} \newop20

Rotates the 32-bit variable L\_v1 by 1 bit to the least significant bits.
Bit 0 of v2 is copied to the most significant bit of the result before it is returned.
The least significant bit of L\_v1 is copied to the bit 0 of v3 variable.

%-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.
\subsection{Operators with complexity weight of 18}

%........................................................
\NewOperator{div\_s(v1, v2)}

Produces a result which is the fractional integer division of {\tt v1} by {\tt v2}.
Values in {\tt v1} and {\tt v2} must be positive and {\tt v2} must be greater than or equal to {\tt v1}.
The result is positive (leading bit equal to 0) and truncated to 16 bits.
If {\tt v1}={\tt v2}, then {\tt div(v1, v2) = 32767}.

\subsection{Operators with complexity weight of 32}

%........................................................
\NewOperator{div\_l(L\_v1, v2)} %\rulex{1mm}

Produces a result which is the fractional integer division of a positive 32-bit value {\tt L\_v1} by a positive 16-bit value {\tt v2}.
The result is positive (leading bit equal to 0) and truncated to 16 bits.

%--------------------------------------------------
\subsection{Basic operator usage across standards}
%--------------------------------------------------

Table \ref{tbl:basop-in-recs} contains a survey of the 16-bit and 32-bit basic operators which are used in various standards.
Follows some notes associated to \ref{tbl:basop-in-recs}:

\begin{enumerate}
    \item abs\_s(v1) is referred to as abs(v1) in GSM 06.10 (GSM full-rate).
    \item shl(v1,v2) is written as v1$<<$v2 in GSM 06.10.
    \item shr(v1,v2) is written as v1$>>$v2 in GSM 06.10.
    \item v2=extract\_h(L\_v1) is written as v2 = L\_v1 in GSM 06.10.
    \item negate(v1) is written as --v1 in GSM 06.10.
    \item L\_negate(L\_v1) is written as --L\_v1 in GSM 06.10.
    \item L\_shl(L\_v1,v2) is written as L\_v1$<<$v2 in GSM 06.10.
    \item L\_shr(L\_v1,v2) is written as L\_v1$>>$v2 in GSM 06.10.
    \item L\_v2=deposit\_l(v1) is written as L\_v2=v1 in GSM 06.10.
    \item div\_s(v1,v2) is written as div(v1,v2) in GSM 06.10.
    \item norm\_l(L\_v1) is written as norm(L\_v1) in GSM 06.10.
    \item GSM 06.20 uses shift\_r(v1,v2), which can be implemented
    as shr\_r(v1,--v2).
    \item GSM 06.20 uses L\_shift\_r(L\_v1,v2), which can be
    implemented as L\_shr\_r(L\_v1,--v2).
    \item div\_s(v1,v2) is written as divide\_s(v1,v2) in GSM 06.20.
    \item Operator is not part of the original ETSI library.
    \item Operator is not part of the original ETSI library but was
    accepted in the TETRA standard.
\end{enumerate}


%-----------------------------------------------------------------
% Table with Basic operators in ITU Recs
%-----------------------------------------------------------------
\begin{table}[th]
    \Caption{14cm}{\SF Use of 32-bit basic operators in G.723.1, G.729
    and ETSI GSM speech coding recommendations.
    \label{tbl:basop-in-recs}}
    \begin{center}
        \footnotesize
        \begin{tabular}{|l|c|c|c|c|c|c|c|c|}
            \hline
            Operation &Weight &FR GSM &HR GSM &EFR GSM &AMR GSM &G.729 &G.723.1 &TETRA\\
            \hline \hline
            {\tt add()}     &1 &X &X &X &X &X &X &X\\
            {\tt sub()}     &1 &X &X &X &X &X &X &X\\
            {\tt abs\_s()}  &1 &X (1) &X &X &X &X &X &X\\
            {\tt shl()}     &1 &X (2) &X &X &X &X &X &X\\
            {\tt shr()}     &1 &X (3) &X &X &X &X &X &X\\
            {\tt extract\_h()}      &1 & &X &X &X &X &X &X\\
            {\tt extract\_l()}      &1 &X (4) &X &X &X &X &X &X\\
            {\tt mult()}    &1 &X &X &X &X &X &X &X\\
            {\tt L\_mult()} &1 &X &X &X &X &X &X &X\\
            {\tt negate()}  &1 &X (5) &X &X &X &X &X & \\
            {\tt round\_fx()}   &1 & &X &X &X &X &X &X\\
            {\tt L\_mac()}  &1 & &X &X &X &X &X &X\\
            {\tt L\_msu()}  &1 & &X &X &X &X &X &X\\
            {\tt L\_macNs()}        &1 & & &X & &X &X & \\
            {\tt L\_msuNs()}        &1 & & & & &X &X & \\
            {\tt L\_add()}  &1 &X &X &X &X &X &X &X\\
            {\tt L\_sub()}  &1 &X &X &X &X &X &X &X\\
            {\tt L\_negate()}       &1 &X (6) &X &X &X &X &X &X\\
            {\tt L\_shl()}  &1 &X (7) &X &X &X &X &X &X\\
            {\tt L\_shr()}  &1 &X (8) &X &X &X &X &X &X\\
            {\tt mult\_r()} &1 &X &X &X &X &X &X &X\\
            {\tt mac\_r()}  &1 & &X & & & &X & \\
            {\tt msu\_r()}  &1 & &X & & & &X & \\
            {\tt L\_deposit\_h()}   &1 & &X &X &X &X &X &X\\
            {\tt L\_deposit\_l()}   &1 &X (9) &X &X &X &X &X &X\\
            {\tt L\_abs()}  &1 & &X &X &X &X &X &X\\
            {\tt norm\_s()}         &1 & &X &X &X &X &X & \\
            {\tt norm\_l()} &1 &X (11) &X &X &X &X &X &X\\
            {\tt L\_add\_c()}       &2 & & & & & &X & \\
            {\tt L\_sub\_c()}       &2 & & & & & &X & \\
            {\tt shr\_r()}  &3 & &X (12) &X &X &X &X & \\
            {\tt L\_shr\_r()}       &3 & &X (13) &X &X &X &X &X\\
            {\tt L\_sat()}  &4 & & & & &X &X &\\
            {\tt div\_s()}  &18 &X (10) &X (14) &X &X &X &X &X\\
            \hline
            {\tt i\_mult()} &3 & & & & & &X (15) & \\
            {\tt L\_mls()}  &5 & & & & & &X (15) & \\
            {\tt div\_l()}  &32 & & & & & &X (15) & \\
            \hline
            {\tt L\_mult0()} &1 & & & & & & &X (16)\\
            {\tt L\_mac0()}  &1 & & & & & & &X (16)\\
            {\tt L\_msu0()}  &1 & & & & & & &X (16)\\
            \hline
        \end{tabular}
    \end{center}
\end{table}

%-----------------------------------------------------------------
\flushfloats

%----------------------------------------------------------------------
\section{Description of the basic operators for unsigned data types}
%----------------------------------------------------------------------

This section describes the different basic operators for unsigned data types available in the STL, organized by complexity (”weights”).

\subsection{Variable definitions}

The variables used in the operators are signed integers in 2's complements representation, defined by:

{\tt U\_var1}, {\tt U\_varout\_l}: 16-bit unsigned variables\\
{\tt UL\_var1}, {\tt UL\_var2}, {\tt var1}, {\tt UL\_varout\_h}, {\tt UL\_varout\_l}: 32-bit unsigned variables


%-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.
\subsection{Operators with complexity weight of 1}

%........................................................
\NewOperator{UL\_addNs(UL\_var1, UL\_var2, *var1)}

Adds the two unsigned 32-bit variables UL\_var1 and UL\_var2 with overflow control, but without saturation.
Returns 32-bit unsigned result.
var1 is set to 1 if wrap around occurred, otherwise 0.

%........................................................
\NewOperator{UL\_subNs(UL\_var1, UL\_var2, *var1)}

Subtracts the 32-bit usigned variable UL\_var2 from the 32-bit unsigned variable UL\_var1 with overflow control, but without saturation.
Returns 32-bit unsigned result.
var1 is set to 1 if wrap around (to "negative") occurred, otherwise 0.

%........................................................
\NewOperator{norm\_ul (UL\_var1)}

Produces the number of left shifts needed to normalize the 32-bit unsigned variable UL\_var1 for positive values on the interval with minimum of 0 and maximum of 0xffffffff.
If UL\_var1 contains 0, return 0.

%........................................................
\NewOperator{UL\_deposit\_l(U\_var1)}

Deposit the 16-bit U\_var1 into the 16 LS bits of the 32-bit output. The 16 MS bits of the output are not sign extended.

%........................................................
\NewOperator{UL\_Mpy\_32\_32(UL\_var1, UL\_var2)}

Multiplies the two unsigned values UL\_var1 and UL\_var2 and returns the lower 32 bits, without saturation control.
UL\_var1 and UL\_var2 are supposed to be in Q32 format.
The result is produced in Q64 format, the 32 LS bits.
Operates like a regular 32x32-bit unsigned int multiplication in ANSI-C.

\subsection{Operators with complexity weight of 2}

%........................................................
\NewOperator{Mpy\_32\_32\_uu(UL\_var1, UL\_var2, *UL\_varout\_h, *UL\_varout\_l)}

Multiplies the two unsigned 32-bit variables UL\_var1 and UL\_var2.
The operation is performed in fractional mode.
UL\_var1 and UL\_var2 are supposed to be in Q32 format.
The result is produced in Q64 format: UL\_varout\_h points to the 32 MS bits while UL\_varout\_l points to the 32 LS bits.

%........................................................
\NewOperator{Mpy\_32\_16\_uu(UL\_var1, U\_var1, *UL\_varout\_h, *U\_varout\_l)}

Multiplies the unsigned 32-bit variable UL\_var1 with the unsigned 16-bit variable U\_var1.
The operation is performed in fractional mode :
UL\_var1 is supposed to be in Q32 format.
U\_var1 is supposed to be in Q16 format.
The result is produced in Q48 format: UL\_varout\_h points to the 32 MS bits while U\_varout\_l points to the 16 LS bits.


%----------------------------------------------------------------------
\section{Description of the 40-bit basic operators and associated weights}
%----------------------------------------------------------------------

This section describes the different 40-bit basic operators available in the STL, and are organized by complexity ("weights").
The complexity values to be considered (since the publication of the STL2005) are the ones related to the version 2.0 and subsequent versions of the library.
These basic operators did not exist in the previous version of the library (version 1.x).

A set of coding guidelines must be followed in order to avoid algorithm complexity miss-evaluation.
This section describes also these guidelines.

\subsection{Variable definitions}

The variables used in the operators are signed integers in 2's complements representation, defined by:

{\tt v1}, {\tt v2}: 16-bit variables\\
{\tt L\_v1}, {\tt L\_v2}, {\tt L\_v3}: 32-bit variables\\
{\tt L40\_v1}, {\tt L40\_v2}, {\tt L40\_v3}: 40-bit variables\\

%-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.
\subsection{Operators with complexity weight of 1}
\subsubsection{Arithmetic operators (multiplication excluded)}

\NewOperator{L40\_set(L40\_v1)}

Assigns a 40-bit constant to the returned 40-bit variable.

%........................................................
\NewOperator{L40\_add(L40\_v1, L40\_v2)}

Adds the two 40-bit variables L40\_v1 and L40\_v2 \textbf{without} 40-bit saturation control.
It will exit execution if it detects a 40-bit overflow.


%........................................................
\NewOperator{L40\_sub(L40\_v1, L40\_v2)}

Subtracts the two 40-bit variables L40\_v2 from L40\_v1 \textbf{without} 40-bit saturation control.
It will exit execution if it detects a 40-bit overflow.

%........................................................
\NewOperator{L40\_abs(L40\_v1)}

Returns the absolute value of the 40-bit variable L40\_v1 without 40-bit saturation control.
It will exit execution if it detects a 40-bit overflow.

%........................................................
\NewOperator{L40\_shl(L40\_v1, v2)}

Arithmetically shifts left the 40-bit variable L40\_v1 by v2 positions:

\rulex{10mm} -- \pbox{150mm}{if v2 is negative, L40\_v1 is shifted to the least significant bits by (-v2) positions with extension of the sign bit.}

\rulex{10mm} -- \pbox{150mm}{
if v2 is positive, L40\_v1 is shifted to the most significant bits by (v2) positions \textbf{without} 40-bit saturation control.
It will exit execution if it detects a 40-bit overflow.
}

%........................................................
\NewOperator{L40\_shr(L40\_v1, v2)}

Arithmetically shifts right the 40-bit variable L40\_v1 by v2 positions:

\rulex{10mm} -- \pbox{150mm}{if v2 is positive, L40\_v1 is shifted to the least significant bits by (v2) positions with extension of the sign bit.}

\rulex{10mm} -- \pbox{150mm}{
if v2 is negative, L40\_v1 is shifted to the most significant bits by (-v2) positions \textbf{without} 40-bit saturation control.
It will exit execution if it detects a 40-bit overflow.
}

%........................................................
\NewOperator{L40\_negate(L40\_v1)}

Negates the 40-bit variable L40\_v1 \textbf{without} 40-bit saturation control.
It will exit execution if it detects a 40-bit overflow.

%........................................................
\NewOperator{L40\_max(L40\_v1, L40\_v2)}

Compares two 40-bit variables L40\_v1 and L40\_v2 and returns the maximum value.

%........................................................
\NewOperator{L40\_min(L40\_v1, L40\_v2)}

Compares two 40-bit variables L40\_v1 and L40\_v2 and returns the minimum value.

%........................................................
\NewOperator{norm\_L40(L40\_v1)}

Produces the number of left shifts needed to normalize the 40-bit variable L40\_v1 for positive values on the interval with minimum
of 1073741824 and maximum 2147483647, and for negative values on the interval with minimum of -2147483648 and maximum of -1073741824;
in order to normalize the result, the following operation must be done:

\rulex{5mm}
{\tt L40\_norm\_v1 = L40\_shl( L40\_v1, norm\_L40( L40\_v1))}

\subsubsection{Multiplication operators}

%........................................................
\NewOperator{L40\_mult(v1, v2)}

Multiplies the 2 signed 16-bit variables v1 and v2 \textbf{without} 40-bit saturation control.
It will exit execution if it detects a 40-bit overflow.
The operation is performed \textbf{in fractional mode}:

\rulex{10mm} -- \pbox{150mm}{v1 and v2 are supposed to be in 1Q15 format.}

\rulex{10mm} -- \pbox{150mm}{The result is produced in 9Q31 format.}

%........................................................
\NewOperator{L40\_mac(L40\_v3, v1, v2)}

Equivalent to: {\tt L40\_add( L40\_v1, L40\_mult( v2, v3)) }

%........................................................
\NewOperator{L40\_msu(L40\_v3, v1, v2)}

Equivalent to: {\tt L40\_sub( L40\_v1, L40\_mult( v2, v3)) }

\subsubsection{Logical operators}

%........................................................
\NewOperator{L40\_lshl(L40\_v1, v2)}

Logically shifts left the 40-bit variable L40\_v1 by v2 positions:

\rulex{10mm} -- \pbox{150mm}{if v2 is negative, L40\_v1 is shifted to the least significant bits by (-v2) positions with insertion of 0 at
the most significant bit.}

\rulex{10mm} -- \pbox{150mm}{if v2 is positive, L40\_v1 is shifted to the most significant bits by (v2) positions without saturation control.}

%........................................................
\NewOperator{L40\_lshr(L40\_v1, v2)}

Logically shifts right the 40-bit variable L40\_v1 by v2 positions:

\rulex{10mm} -- \pbox{150mm}{if v2 is positive, L40\_v1 is shifted to the least significant bits by (v2) positions with insertion of 0 at the most significant bit.}

\rulex{10mm} -- \pbox{150mm}{if v2 is negative, L40\_v1 is shifted to the most significant bits by (-v2) positions without saturation control.}

\subsubsection{Data type conversion operators}

%........................................................
\NewOperator{Extract40\_H(L40\_v1)}

Returns the bits [31..16] of L40\_v1.

%........................................................
\NewOperator{Extract40\_L(L40\_v1)}

Returns the bits [15..00] of L40\_v1.

%........................................................
\NewOperator{round40(L40\_v1)}

Equivalent to:\\
{\tt extract\_h( L\_saturate40( L40\_round( L40\_v1))) }

%........................................................
\NewOperator{L\_Extract40(L40\_v1)}

Returns the bits [31..00] of L40\_v1.

%........................................................
\NewOperator{L\_saturate40(L40\_v1)}

If L40\_v1 is greater than 2147483647, the operator returns 2147483647. \\
If L40\_v1 is lower than -2147483648, the operator returns -2147483648. \\
Otherwise, it is equivalent to {\tt L\_Extract40(L40\_v1)}.


%........................................................
\NewOperator{L40\_deposit\_h(v1)}

Deposits the 16-bit variable v1 in the bits [31..16] of the return value: the return value bits [15..0] are set to 0 and the bits [39..32] sign extend v1 sign bit.

%........................................................
\ \\
\NewOperator{L40\_deposit\_l(v1)}

Deposits the 16-bit variable v1 in the bits [15..0] of the return value: the return value bits [39..16] sign extend v1 sign bit.

%........................................................
\NewOperator{L40\_deposit32(L\_v1)}

Deposits the 32-bit variable L\_v1 in the bits [31..0] of the return value: the return value bits [39..32] sign extend L\_v1 sign bit.

%........................................................
\NewOperator{L40\_round(L40\_v1)}

Performs a rounding to the infinite on the 40-bit variable L40\_v1.
32768 is added to L40\_v1 \textbf{without} 40-bit saturation control.
It will exit execution if it detects a 40-bit overflow.
The end-result 16 LSBits are cleared to 0.


\subsection{Operators with complexity weight of 2}

%........................................................
\NewOperator{mac\_r40(L40\_v1, v2, v3)}

Equivalent to: \\
{\tt round40( L40\_mac( L40\_v1, v2, v3)) }

%........................................................
\NewOperator{msu\_r40(L40\_v1, v2, v3) }

Equivalent to: \\
{\tt round40( L40\_msu( L40\_v1, v2, v3)) }

%........................................................
\NewOperator{L40\_shr\_r(L40\_v1, v2)}

Arithmetically shifts the 40-bit variable L40\_v1 by v2 positions to the least significant bits and rounds the result.
It is equivalent to {\tt L40\_shr( L40\_v1, v2)} except that if v2 is positive and the last shifted out bit is 1, then the shifted result is increment by 1\textbf{without} 40-bit saturation control.
It will exit execution if it detects a 40-bit overflow.

%........................................................
\NewOperator{L40\_shl\_r(L40\_v1, v2)}

Arithmetically shifts the 40-bit variable L40\_v1 by v2 positions to the most significant bits and rounds the result.
It is equivalent to {\tt L40\_shl( L40\_var1, v2)} except if v2 is negative.
In this case, it does the same as {\tt L40\_shr\_r( L40\_v1, (-v2))}.

%........................................................
\NewOperator{Mpy\_32\_16\_ss(L\_v1, v2, *L\_v3\_h, *v3\_l)}

\textbf{Multiplies the 2 signed values} L\_v1 (32-bit) and v2 (16-bit) with saturation control on 48-bit.
The operation is performed in \textbf{fractional mode}: \\
When L\_v1 is in 1Q31 format, and v2 is in 1Q15 format, the result is produced in 1Q47 format: L\_v3\_h bears the 32 most significant bits while v3\_l bears the 16 least significant bits.

%........................................................
\NewOperator{Mpy\_32\_32\_ss(L\_v1, L\_v2, *L\_v3\_h, *L\_v3\_l)}

Multiplies the two signed 32-bit values L\_v1 and L\_v2 with saturation control on 64-bit.
The operation is performed in \textbf{fractional mode}: when L\_v1 and L\_v2 are in 1Q31 format, the result is produced in 1Q63 format; L\_v3\_h bears the 32 most significant bits while L\_v3\_l bears the 32 least significant bits.

%........................................................
\subsection{Coding Guidelines}

The following recommendations must be followed in the usage of the
40-bit operators:
\begin{enumerate}
    \item Only 40-bit variables local to functions can be declared.
    Declaration of arrays and structures containing 40-bit elements
    must not be done.
    \item 40-bit basic operators and 16/32-bit basic
    operators must not be mixed within the same loop initialized with
    a FOR(), DO or WHILE() control basic operator.

    When nested loop software structure is implemented, this
    recommendation applies to the most inner loops. This enables to
    have, for instance, an outer loop containing 2 inner loops, with
    the 1st inner loop using 40-bit basic operators and the 2nd inner
    loop using 16/32-bit basic operators. However, whenever possible,
    even such 2 level loop structure configuration should only use
    either 40-bit basic operators or 16/32-bit basic operators.

    Current version (2.0) of the operator implementation does not
    evaluate the complexity associated to the mixing of 40-bit and
    16/32-bit operators. Subsequent versions may do so.
\end{enumerate}

%########################################################################
\section{Description of the basic operators which use complex data types }

This section describes the complex basic operators available in the STL, organized by complexity ("weights").

\subsection{Variable definitions}

The variables used in the operators are signed integer in 2's complements representation, defined by:

{\tt var1}, {\tt var2}, {\tt var3}, {\tt re}, {\tt im}: 16-bit variables\\
{\tt C\_var}, {\tt C\_var1}, {\tt C\_var2}, {\tt C\_coeff}: 16-bit complex variables\\
{\tt L\_var2}, {\tt L\_var3}, {\tt L\_re}, {\tt L\_im}: 32-bit variables\\
{\tt CL\_var}, {\tt CL\_var1}, {\tt CL\_var2}: 32-bit complex variables

\subsection{Operators with complexity weight of 1}

%........................................................
\NewOperator{CL\_shr(CL\_var1, var2)}

Arithmetically shifts right the real and imaginary parts of the 32-bit complex number CL\_var1 by var2 positions.\\
If var2 is negative, real and imaginary parts of CL\_var1 are shifted to the most significant bits by (-var2) positions with 32-bit saturation control.\\
If var2 is positive, real and imaginary parts of CL\_var1 are shifted to the least significant bits by (var2) positions with sign extension.\\
The following code snippet describes the operations performed on real \& imaginary part of a complex number:

{\tt \rulex{5mm}CL\_result.re = L\_shr(CL\_var1.re, L\_shift\_val);\\
\rulex{5mm}CL\_result.im = L\_shr(CL\_var1.im, L\_shift\_val);\\
}

%........................................................
\NewOperator{CL\_shl(CL\_var1, var2)}

Arithmetically shifts left the real and imaginary parts of the 32-bit complex number CL\_var1 by L\_shift\_val positions.\\
If var2 is negative, real and imaginary parts of CL\_var1 are shifted to the least significant bits by ( -var2 ) positions with sign extension.\\
If var2 is positive, real and imaginary parts of CL\_var1 are shifted to the most significant bits by (var2) positions with 32-bit saturation control.\\
The following code snippet describes the operations performed on real \& imaginary part of a complex number:

{\tt \rulex{5mm} CL\_result.re = L\_shl(CL\_var1.re, L\_shift\_val);\\
\rulex{5mm} CL\_result.im = L\_shl(CL\_var1.im, L\_shift\_val);
}

%........................................................
\NewOperator{CL\_add(CL\_var1, CL\_var2)}

Adds the two 32-bit complex numbers CL\_var1 and CL\_var2 with 32-bit saturation control.\\
Real part of the 32-bit complex number CL\_var1 is added to Real part of the 32-bit complex number CL\_var2 with 32-bit saturation control.
The result forms the real part of the result variable.\\
Imaginary part of the 32-bit complex number CL\_var1 is added to Imaginary part of the 32-bit complex number CL\_var2 with 32-bit saturation control.
The result forms the imaginary part of the result variable.\\
Following code snippet describe the operations performed on real \& imaginary part of a complex number:

{\tt \rulex{5mm} CL\_result.re = L\_add(CL\_var1.re, CL\_var2.re);\\
\rulex{5mm} CL\_result.im = L\_add(CL\_var1.im, CL\_var2.im);
}

%........................................................
\NewOperator{CL\_sub(CL\_var1, CL\_var2)}

Subtracts the two 32-bit complex numbers CL\_var1 and CL\_var2 with 32-bit saturation control.\\
Real part of the 32-bit complex number CL\_var2 is subtracted from Real part of the 32-bit complex number CL\_var1 with 32-bit saturation control.
The result forms the real part of the result variable.\\
Imaginary part of the 32-bit complex number CL\_var2 is subtracted from Imaginary part of the 32-bit complex number CL\_var1 with 32-bit saturation control.
The result forms the imaginary part of the result variable.\\
The following code snippet describes the operations performed on real \& imaginary part of a complex number:

{\tt \rulex{5mm} CL\_result.re = L\_sub(CL\_var1.re, CL\_var2.re);\\
\rulex{5mm} CL\_result.im = L\_sub(CL\_var1.im, CL\_var2.im);
}

%........................................................
\NewOperator{CL\_scale(CL\_var, var1)}

Multiplies the real and imaginary parts of a 32-bit complex number CL\_var by a 16-bit var1.
The resulting 48-bit product for each part is rounded, saturated and 32-bit MSB of 48-bit result are returned.\\
The following code snippet describes the operations performed on real \& imaginary part of a complex number:

{\tt \rulex{5mm} CL\_result.re = Mpy\_32\_16\_r(CL\_var.re, var1);\\
\rulex{5mm} CL\_result.im = Mpy\_32\_16\_r(CL\_var.im, var1);
}

%........................................................
\NewOperator{CL\_dscale(CL\_var3, var1, var2)}

Multiplies the real parts of a 32-bit complex number CL\_var3 by a 16-bit var1 and imaginary parts of a 32-bit complex number CL\_var3 by a 16-bit var2.
The resulting 48-bit product for each part is rounded, saturated and 32-bit MSB of 48-bit result are returned.\\
The following code snippet describes the operations performed on real \& imaginary part of a complex number:

{\tt \rulex{5mm} CL\_result.re = Mpy\_32\_16\_r(CL\_var.re, var1);\\
\rulex{5mm} CL\_result.im = Mpy\_32\_16\_r(CL\_var.im, var2);
}

%........................................................
\NewOperator{CL\_msu\_j(CL\_var1, CL\_var2)}

Multiplies the 32-bit complex number CL\_var2 with j and subtracts the result from the 32-bit complex number CL\_var1 with saturation control.\\
The following code snippet describes the operations performed on real \& imaginary part of a complex number:

{\tt \rulex{5mm} CL\_result.re = L\_add( CL\_var1.re, CL\_var2.im );\\
\rulex{5mm} CL\_result.im = L\_sub( CL\_var1.im, CL\_var2.re );
}

%........................................................
\NewOperator{CL\_mac\_j(CL\_var1, CL\_var2)}

Multiplies the 32-bit complex number CL\_var2 with j and adds the result to the 32-bit complex number CL\_var1 with saturation control.\\
The following code snippet describes the operations performed on real \& imaginary part of a complex number:

{\tt \rulex{5mm} CL\_result.re = L\_sub( CL\_var1.re, CL\_var2.im );\\
\rulex{5mm} CL\_result.im = L\_add( CL\_var1.im, CL\_var2.re );
}

%........................................................
\NewOperator{CL\_move(CL\_var1)}

Copies the 32-bit complex number CL\_var1 to destination 32-bit complex number.

%........................................................
\NewOperator{CL\_Extract\_real(CL\_var1)}

Returns the real part of a 32-bit complex number CL\_var1.

%........................................................
\NewOperator{CL\_scale (CL\_var, var1)}

Multiplies the real and imaginary parts of a 32-bit complex number CL\_var by a 16-bit var1.
The resulting 48-bit product for each part is rounded, saturated and 32-bit MSB of 48-bit result are returned.\\
The following code snippet describes the operations performed on real \& imaginary part of a complex number:

{\tt \rulex{5mm} CL\_result.re = Mpy\_32\_16\_r(CL\_var.re, var1);\\
\rulex{5mm} CL\_result.im = Mpy\_32\_16\_r(CL\_var.im, var1);
}

%........................................................
\NewOperator{CL\_dscale(CL\_var, var1, var2)}

Multiplies the real parts of a 32-bit complex number CL\_var by a 16-bit var1 and imaginary parts of a 32-bit complex number CL\_var by a 16-bit var2.
The resulting 48-bit product for each part is rounded, saturated and 32-bit MSB of 48-bit result are returned.\\
The following code snippet describes the operations performed on real \& imaginary part of a complex number:

{\tt \rulex{5mm} CL\_result.re = Mpy\_32\_16\_r(CL\_var.re, var1);\\
\rulex{5mm} CL\_result.im = Mpy\_32\_16\_r(CL\_var.im, var2);
}

%........................................................
\NewOperator{CL\_msu\_j(CL\_var1, CL\_var2)}

Multiplies the 32-bit complex number CL\_var2 with j and subtracts the result from the 32-bit complex number CL\_var1 with saturation control.\\
The following code snippet describes the operations performed on real \& imaginary part of a complex number:

{\tt \rulex{5mm} CL\_result.re = L\_add( CL\_var1.re, CL\_var2.im );\\
\rulex{5mm} CL\_result.im = L\_sub( CL\_var1.im, CL\_var2.re );
}

%........................................................
\NewOperator{CL\_mac\_j(CL\_var1, CL\_var2)}

Multiplies the 32-bit complex number CL\_var2 with j and adds the result to the 32-bit complex number CL\_var1 with saturation control.\\
The following code snippet describes the operations performed on real \& imaginary part of a complex number:

{\tt \rulex{5mm} CL\_result.re = L\_sub( CL\_var1.re, CL\_var2.im );\\
\rulex{5mm} CL\_result.im = L\_add( CL\_var1.im, CL\_var2.re );
}

%........................................................
\NewOperator{CL\_move(CL\_var)}

Copies the 32-bit complex number CL\_var to destination 32-bit complex number.

%........................................................
\NewOperator{CL\_Extract\_real(CL\_var)}

Returns the real part of a 32-bit complex number CL\_var.

%........................................................
\NewOperator{CL\_Extract\_imag(CL\_var)}

Returns the imaginary part of a 32-bit complex number CL\_var.

%........................................................
\NewOperator{CL\_form(L\_re, L\_im)}

Combines the two 32-bit variables L\_re and L\_im and returns a 32-bit complex number.\\
The following code snippet describes the operations performed on real \& imaginary part of a complex number:

{\tt \rulex{5mm} CL\_result.re = L\_re;\\
\rulex{5mm} CL\_result.im = L\_im;
}

%........................................................
\NewOperator{CL\_negate(CL\_var)}

Negates the 32-bit complex number, saturates and returns.\\
The following code snippet describes the operations performed on real \& imaginary part of a complex number:

{\tt \rulex{5mm} CL\_result.re = L\_negate(CL\_var.re);\\
\rulex{5mm} CL\_result.im = L\_negate(CL\_var.im);
}

%........................................................
\NewOperator{CL\_conjugate(CL\_var)}

Negates only the imaginary part of complex number CL\_var with saturation.
No change in the real part.\\
The following code snippet describes the operations:

{\tt \rulex{5mm} CL\_result.re = CL\_var.re;\\
\rulex{5mm} CL\_result.im = L\_negate(CL\_var.im);
}

%........................................................
\NewOperator{CL\_mul\_j(CL\_var)}

Multiplication of a 32-bit complex number CL\_var with j and return a 32-bit complex number.

%........................................................
\NewOperator{CL\_swap\_real\_imag(CL\_var)}

Swaps real and imaginary parts of a 32-bit complex number CL\_var and returns a 32-bit complex number.

%........................................................
\NewOperator{C\_add(C\_var1, C\_var2)}

Adds the two 16-bit complex numbers C\_var1 and C\_var2 with 16-bit saturation control.\\
The following code snippet describe the operations performed on real \& imaginary part of a complex number:

{\tt \rulex{5mm} C\_result.re = add(C\_var1.re, C\_var2.re);\\
\rulex{5mm} C\_result.im = add(C\_var1.im, C\_var2.im);
}

%........................................................
\NewOperator{C\_sub(C\_var1, C\_var2)}

Subtracts the two 16-bit complex numbers C\_var1 and C\_var2 with 16-bit saturation control.\\
The following code snippet describes the operations performed on real \& imaginary part of a complex number:

{\tt \rulex{5mm} C\_result.re = sub(C\_var1.re, C\_var2.re);\\
\rulex{5mm} C\_result.im = sub(C\_var1.im, C\_var2.im);
}

%........................................................
\NewOperator{C\_mul\_j(C\_var)}

Multiplies a 16-bit complex number with j and returns a 16-bit complex number.

%........................................................
\NewOperator{C\_form(re, im)}

Combines the two 16-bit variable re and im and returns a 16-bit complex number.

%........................................................
\NewOperator{CL\_scale\_32(CL\_var1, L\_var2)}

Multiplies the real and imaginary parts of a 32-bit complex number CL\_var1 by a 32-bit L\_var2.\\
The resulting 64-bit product for each part is rounded, saturated and 32-bit MSB of 64-bit result are returned.\\
The following code snippet describes the operations performed on real \& imaginary part of a complex number:

{\tt \rulex{5mm} CL\_result.re = Mpy\_32\_32\_r(CL\_var1.re, L\_var2);\\
\rulex{5mm} CL\_result.im = Mpy\_32\_32\_r(CL\_var1.im, L\_var2);
}

%........................................................
\NewOperator{CL\_dscale\_32(CL\_var1, L\_var2, L\_var3)}

Multiplies the real parts of a 32-bit complex number CL\_var1 by a 32-bit L\_var2 and imaginary parts of a 32-bit complex number CL\_var1 by a 32-bit L\_var3.
The resulting 64-bit product for each part is rounded, saturated and 32-bit MSB of 64-bit result are returned.\\
The following code snippet describes the operations performed on real \& imaginary part of a complex number:

{\tt \rulex{5mm} CL\_result.re = Mpy\_32\_32\_r(CL\_var1.re, L\_var2);\\
\rulex{5mm} CL\_result.im = Mpy\_32\_32\_r(CL\_var1.im, L\_var3);
}

%........................................................
\NewOperator{CL\_round32\_16( CL\_var1)}

Rounds the lower 16 bits of the 32-bit complex number CL\_var1 into the most significant 16 bits with saturation.
Shifts the resulting bits right by 16 and returns the 16-bit complex number.\\
If real and imaginary of CL\_var1 is in 1Q31 format, then the result returned will be rounded and saturated to 1Q15 format.

%........................................................
\NewOperator{C\_Extract\_real(C\_var1)}

Returns the real part of a 16-bit complex number C\_var1.

%........................................................
\NewOperator{C\_Extract\_imag(C\_var1)}

Returns the imaginary part of a 16-bit complex number C\_var1.

%........................................................
\NewOperator{C\_scale(C\_var1,var2)}

Multiplies the real and imaginary parts of a 16-bit complex number C\_var1 by a 16-bit var2.
Returns 32-bit complex number.

%........................................................
\NewOperator{C\_negate(C\_var1)}

Negates the 16-bit complex number, saturates and returns a 16-bit complex number.

%........................................................
\NewOperator{C\_conjugate(C\_var1)}

Negates only the imaginary part of a 16-bit complex number C\_var1 with saturation.
No change in the real part.

%........................................................
\NewOperator{C\_shr(C\_var1, var2)}

Arithmetically shifts right the real and imaginary parts of the 16-bit complex number C\_var1 by var2 positions.\\
If var2 is negative, real and imaginary parts of C\_var1 are shifted to the most significant bits by (-var2) positions with 16-bit saturation control.\\
If var2 is positive, real and imaginary parts of C\_var1 are shifted to the least significant bits by (var2) positions with sign extension.

%........................................................
\NewOperator{C\_shl(C\_var1,var2)}

Arithmetically shifts left the real and imaginary parts of the 16-bit complex number C\_var1 by var2 positions.\\
If var2 is negative, real and imaginary parts of C\_var1 are shifted to the least significant bits by (-var2) positions with sign extension.\\
If var2 is positive, real and imaginary parts of C\_var1 are shifted to the most significant bits by (var2) positions with 16-bit saturation control.

%______________________________________________________
\subsection{Operators with complexity weight of 2}

%........................................................
\NewOperator{CL\_multr\_32x16(CL\_var, C\_coeff)}

Multiplication of 32-bit complex number CL\_var with a 16-bit complex number C\_coeff.\\
The formula for multiplying two complex numbers, {\tt (x+iy)} and {\tt (u+iv)} is:

{\tt \rulex{5mm} (x+iy)*(u+iv) = (xu – yv) + i(xv + yu);}

The following code snippet describes the operations performed on real \& imaginary part of a complex number:

{\tt \rulex{5mm} W\_tmp1 = W\_mult\_32\_16(CL\_var.re, C\_coeff.re);\\
\rulex{5mm} W\_tmp2 = W\_mult\_32\_16(CL\_var.im, C\_coeff.im);\\
\rulex{5mm} W\_tmp3 = W\_mult\_32\_16(CL\_var.re, C\_coeff.im);\\
\rulex{5mm} W\_tmp4 = W\_mult\_32\_16(CL\_var.im, C\_coeff.re);\\

\rulex{5mm} CL\_res.re = W\_round48\_L( W\_sub\_nosat (W\_tmp1, W\_tmp2));\\
\rulex{5mm} CL\_res.im = W\_round48\_L( W\_add\_nosat (W\_tmp3, W\_tmp4));
}

For example, if the real and imaginary part of complex variable CL\_var are in 1Q31 format, and C\_coeff in 1Q15 format, then the intermediate products would be in 17Q47 format.
The round operation will convert the result of addition/subtraction from 17Q47 format to 1Q31 format.

%........................................................
\NewOperator{C\_multr(C\_var1, C\_var2)}

Multiplies the 16-bit complex number C\_var1 with the 16-bit complex number C\_var2 which results in a 16-bit complex number.\\
The formula for multiplying two complex numbers, {\tt (x+iy)} and {\tt (u+iv)} is:

{\tt \rulex{5mm} (x+iy)*(u+iv) = (xu – yv) + i(xv + yu);}

The following code snippet describes the operations performed on real \& imaginary part of a complex number:

{\tt \rulex{5mm} W\_tmp1 = W\_mult\_16\_16(C\_var1.re, C\_var2.re);\\
\rulex{5mm} W\_tmp2 = W\_mult\_16\_16(C\_var1.im, C\_var2.im);\\
\rulex{5mm} W\_tmp3 = W\_mult\_16\_16(C\_var1.re, C\_var2.im);\\
\rulex{5mm} W\_tmp4 = W\_mult\_16\_16(C\_var1.im, C\_var2.re);\\

\rulex{5mm} C\_result.re = round\_fx(W\_sat\_l (W\_sub\_nosat (W\_tmp1, W\_tmp2)));\\
\rulex{5mm} C\_result.im = round\_fx(W\_sat\_l (W\_add\_nosat (W\_tmp3, W\_tmp4)));
}

%........................................................
\NewOperator{CL\_multr\_32x32(CL\_var1, CL\_var2)}

Complex multiplication of CL\_var1 and CL\_var2.
Multiplication is in fractional mode. Both input and outputs are in 1Q31 format.\\
The following code snippet describes the performed operations:

{\tt \rulex{5mm} W\_tmp1 = W\_mult\_32\_32(CL\_var1.re, CL\_var2.re);\\
\rulex{5mm} W\_tmp2 = W\_mult\_32\_32(CL\_var1.im, CL\_var2.im);\\
\rulex{5mm} W\_tmp3 = W\_mult\_32\_32(CL\_var1.re, CL\_var2.im);\\
\rulex{5mm} W\_tmp4 = W\_mult\_32\_32(CL\_var1.im, CL\_var2.re);

\rulex{5mm} CL\_res.re = W\_round64\_L( W\_sub (W\_tmp1, W\_tmp2));\\
\rulex{5mm} CL\_res.im = W\_round64\_L( W\_add (W\_tmp3, W\_tmp4));
}

%........................................................
\NewOperator{C\_mac\_r(CL\_var1, C\_var2, var3)}

Multiplies real and imaginary part of C\_var2 by var3 and shifts the result left by 1.
Adds the 32-bit result to CL\_var1 with saturation.
Rounds the 16 least significant bits of the result into the 16 most significant bits with saturation and shifts the result right by 16.
Returns a 16-bit complex result.

{\tt \rulex{5mm} C\_result = CL\_round32\_16( CL\_add( Cl\_var1, C\_scale(C\_var2, var3) ) ); }

%........................................................
\NewOperator{C\_msu\_r(CL\_var1, C\_var2, var3)}

Multiplies real and imaginary part of C\_var2 by var3 and shifts the result left by 1.
Subtracts the 32-bit result from CL\_var1 with saturation. Rounds the 16 least significant bits of the result into the 16 most significant bits with saturation and shifts the result right by 16.
Returns a 16-bit complex result.

{\tt \rulex{5mm} C\_result = CL\_round32\_16( CL\_sub( Cl\_var1, C\_scale(C\_var2, var3) ) ); }


%########################################################################
\section{Description of the basic operators which use 64-bit registers/accumulators} \label{basop64bitoperators}

This section describes the 64-bit basic operators available in the STL, organized by complexity ("weights").

\subsection{Variable definitions}

The variables used in the operators are signed integer in 2's complements representation, defined by:

{\tt var1}, {\tt var2}: 16-bit variables\\
{\tt L\_var1}, {\tt L\_var2}: 32-bit variables\\
{\tt W\_var}, {\tt W\_var1}, {\tt W\_var2}, {\tt W\_acc}: 64-bit variables


\subsection{Operators with complexity weight of 1}

%........................................................
\NewOperator{W\_add\_nosat(W\_var1, W\_var2)}

Adds the two 64-bit variables W\_var1 and W\_var2 without saturation control on 64 bits.

%........................................................
\NewOperator{W\_sub\_nosat(W\_var1, W\_var2)}

Subtracts the two 64-bit variables W\_var1 and W\_var2 without saturation control on 64 bits.


%........................................................
\NewOperator{W\_shl(W\_var1, var2)}

Arithmetically shifts left the 64-bit variable W\_var1 by var2 positions:\\
if var2 is negative, W\_var1 is shifted to the least significant bits by (–var2) positions with extension of the sign bit.\\
if var2 is positive, W\_var1 is shifted to the most significant bits by (var2) positions with saturation control on 64 bits.


%........................................................
\NewOperator{W\_shl\_nosat(W\_var1, var2)}

Arithmetically shifts left the 64-bit variable W\_var1 by var2 positions:\\
if var2 is negative, W\_var1 is shifted to the least significant bits by (–var2) positions with extension of the sign bit.\\
if var2 is positive, W\_var1 is shifted to the most significant bits by (var2) positions without saturation control on 64 bits.


%........................................................
\NewOperator{W\_shr(W\_var1, var2)}

Arithmetically shifts right the 64-bit variable W\_var1 by var2 positions:\\
if var2 is negative, W\_var1 is shifted to the most significant bits by (–var2) positions with saturation control on 64 bits .\\
if var2 is positive, W\_var1 is shifted to the least significant bits by (var2) positions with extension of the sign bit.


%........................................................
\NewOperator{W\_shr\_nosat(W\_var1, var2)}

Arithmetically shifts right the 64-bit variable W\_var1 by var2 positions:\\
if var2 is negative, W\_var1 is shifted to the most significant bits by (–var2) positions without saturation control on 64 bits.\\
if var2 is positive, W\_var1 is shifted to the least significant bits by (var2) positions with extension of the sign bit.


%........................................................
\NewOperator{W\_mult\_32\_16(L\_var1, var2)}

\textbf{ This operator is SIMD and VLIW friendly}

Multiplies the signed 32-bit variable L\_var1 with signed 16-bit variable var2.
Shifts the product left by 1 and sign extends to 64-bits without saturation control. \\
The operation is performed in fractional mode.\\
For example, if L\_var1 is in 1Q31 format and var2 is in 1Q15 format, then the result is produced in 17Q47 format.

%........................................................
\NewOperator{W\_mac\_32\_16(W\_acc, L\_var1, var2)}

\textbf{ This operator is SIMD and VLIW friendly}

Multiplies the signed 32-bit variable L\_var1 with signed 16-bit variable var2.
Shifts the product left by 1 and sign extends to 64-bits without saturation control;\\
adds this 64 bit value to the 64 bit W\_acc without saturation control, and returns a 64 bit result.\\
The operation is performed in fractional mode.\\
For example, if L\_var1 is in 1Q31 format and var2 is in 1Q15 format, then the product is produced in 17Q47 format which is then added to W\_acc (in 17Q47) format.
The final result is in 17Q47 format.

%........................................................
\NewOperator{W\_msu\_32\_16(W\_acc, L\_var1, var2)}

\textbf{ This operator is SIMD and VLIW friendly}

Multiplies the signed 32-bit variable L\_var1 with signed 16-bit variable var2.
Left-shift the product by 1 and sign extends to 64-bit without saturation control; subtracts this 64 bit value from the 64 bit W\_acc without saturation control, and returns a 64 bit result.\\
The operation is performed in fractional mode.\\
For example, if L\_var1 is in 1Q31 format and var2 is in 1Q15 format, then the product is produced in 17Q47 format which is then subtracted from W\_acc (in 17Q47) format.
The final result is in 17Q47 format.

%........................................................
\NewOperator{W\_mult0\_16\_16(var1, var2)}

\textbf{ This operator is SIMD and VLIW friendly}

Multiplies 16-bit var1 by 16-bit var2, sign extends to 64 bits and returns the 64 bit result.

%........................................................
\NewOperator{W\_mac0\_16\_16(W\_acc, var1, var2)}

\textbf{ This operator is SIMD and VLIW friendly}

Multiplies 16-bit var1 by 16-bit var2, sign extends to 64 bits; adds this 64 bit value to the 64 bit W\_acc without saturation control, and returns a 64 bit result.

%........................................................
\NewOperator{W\_msu0\_16\_16(W\_acc, var1, var2)}

\textbf{ This operator is SIMD and VLIW friendly}

Multiplies 16-bit var1 by 16-bit var2, sign extends to 64 bits; subtracts this 64 bit value from the 64 bit W\_acc without saturation control, and returns a 64 bit result.

%........................................................
\NewOperator{W\_mult\_16\_16(W\_acc, var1, var2)}

\textbf{ This operator is SIMD and VLIW friendly}

Multiplies a signed 16-bit var1 by signed 16-bit var2, shifts the product left by 1 and sign extends to 64-bits without saturation control and returns a 64 bit result.\\
The operation is performed in fractional mode.\\
For example, if var1 is in 1Q15 format and var2 is in 1Q15 format, then the result is produced in 33Q31 format.

%........................................................
\NewOperator{W\_mac\_16\_16(W\_acc, var1, var2)}

\textbf{ This operator is SIMD and VLIW friendly}

Multiplies a signed 16-bit var1 by signed 16-bit var2, shifts the result left by 1 and sign extends to 64-bits;\\
add this 64 bit value to the 64 bit W\_acc without saturation control, and returns a 64 bit result.\\
The operation is performed in fractional mode.\\
For example, if var1 is in 1Q15 format and var2 is in 1Q15 format, then the product is in 33Q31 format which is then added to W\_acc (in 33Q31 format) to provide a final result in 33Q31 format.

%........................................................
\NewOperator{W\_msu\_16\_16(W\_acc, var1, var2)}

\textbf{ This operator is SIMD and VLIW friendly}

Multiplies a signed 16-bit var1 by signed 16-bit var2, shifts the result left by 1 and sign extends to 64-bit;\\
subtracts this 64 bit value from the 64 bit W\_acc without saturation control, and returns a 64 bit result.\\
The operation is performed in fractional mode.\\
For example, if var1 is in 1Q15 format and var2 is in 1Q15 format, then the product is in 33Q31 format which is then subtracted from W\_acc (in 33Q31 format) to provide a final result in 33Q31 format.

%........................................................
\NewOperator{W\_deposit32\_l(L\_var1)}

Deposits the 32 bit L\_var1 into the 32 LS bits of the 64-bit output. The 32 MS bits of the output are sign extended.

%........................................................
\NewOperator{W\_deposit32\_h(L\_var1)}

Deposits the 32-bit L\_var1 into the 32 MS bits of the 64-bit output. The 32 LS bits of the output are zeroed.

%........................................................
\NewOperator{W\_sat\_l(W\_v1)}

Saturates the 64-bit variable W\_v1 to 32-bit value and returns the lower 32 bits.\\
For example, a 64-bit wide accumulator is helpful in accumulating 16*16 multiplies without checking for saturation.
However, at the end of the multiply-and-accumulate loop, we need to return only the 32-bit value after checking for saturation.\\
If W\_v1 is in 33Q31 format, then the result returned will be saturated to 1Q31 format.

%........................................................
\NewOperator{W\_sat\_m(W\_v1)}

Arithmetically shifts right the 64-bit variable W\_v1 by 16 bits; saturates the 64-bit value to 32-bit value and returns the lower 32 bits.\\
For example, a 64-bit wide accumulator is helpful in accumulating 32\*16 multiplies without checking for saturation.
A 32\*16 multiply gives a 48-bit product; at the end of the multiply-and-accumulate loop, the result is in the lower 48 bits of the 64-bit accumulator.
Now an arithmetic right shift by 16 bits will drop the LSB 16 bits.
Now we should check for saturation and return the lower 32 bits.\\
If W\_var is in 17Q47 format, then the result returned will be saturated to 1Q31 format.

%........................................................
\NewOperator{W\_shl\_sat\_l(W\_1, var1)}

Arithmetically shifts left the 64-bit W\_v1 by v1 positions with lower 32-bit saturation and returns the 32 LSB of 64-bit result.\\
If v1 is negative, the result is shifted to right by (-var1) positions and sign extended.
After shift operation, returns the 32 MSB of 64-bit result.

%........................................................
\NewOperator{W\_extract\_l(W\_var1)}

Returns the 32 LSB of a 64-bit variable W\_var1.

%........................................................
\NewOperator{W\_extract\_h(W\_var1)}

Returns the 32 MSB of a 64-bit variable W\_var1.

%........................................................
\NewOperator{W\_round48\_L(W\_var1)}

Rounds the lower 16 bits of the 64-bit input number W\_var1 into the most significant 32 bits with saturation.
Shifts the resulting bits right by 16 and returns the 32-bit number:\\
If W\_var1 is in 17Q47 format, then the result returned will be rounded and saturated to 1Q31 format.

%........................................................
\NewOperator{W\_round32\_s(W\_var1)}

Rounds the lower 32 bits of the 64-bit input number W\_var1 into the most significant 16 bits with saturation.
Shifts the resulting bits right by 32 and returns the 16-bit number:\\
If W\_var1 is in 17Q47 format, then the result returned will be rounded and saturated to 1Q15 format.

%........................................................
\NewOperator{W\_norm(W\_var1)}

Produces the number of left shifts needed to normalize the 64-bit variable W\_var1.
If W\_var1 contains 0, return 0.

%........................................................
\NewOperator{W\_add(W\_var1, W\_var2)}

Adds the two 64-bit variables W\_var1 and W\_var2 with 64-bit saturation control.
Sets overflow flag. Returns 64-bit result.

%........................................................
\NewOperator{W\_sub(W\_var1, W\_var2)}

Subtracts 64-bit variable W\_var2 from W\_var1 with 64-bit saturation control.
Sets overflow flag. Returns 64-bit result.

%........................................................
\NewOperator{W\_neg(W\_var1)}

Negates a 64-bit variables W\_var1 with 64-bit saturation control.
Set overflow flag. Returns 64-bit result.

%........................................................
\NewOperator{W\_abs(W\_var1)}

Returns a 64-bit absolute value of a 64-bit variable W\_var1 with saturation control.

%........................................................
\NewOperator{W\_mult\_32\_32(L\_var1, L\_var2)}

Multiplies the signed 32-bit variable L\_var1 with signed 32-bit variable L\_var2.
Shift the product left by 1 with saturation control.
Returns the 64-bit result.\\
The operation is performed in fractional mode.\\
For example, if L\_var1 \& L\_var2 are in 1Q31 format then the result is produced in 1Q63 format.\\
Note that {\tt W\_mult\_32\_32(-2147483648, -2147483648) = 9223372036854775807}.

%........................................................
\NewOperator{W\_mult0\_32\_32(L\_var1, L\_var2)}

Multiplies the signed 32-bit variable L\_var1 with signed 32-bit variable L\_var2.
Returns the 64-bit result.\\
For example, if L\_var1 \& L\_var2 are in 1Q31 format then the result is produced in 2Q62 format.

%........................................................
\NewOperator{W\_lshl(W\_var1, var2)}

Logically shift the 64-bit input W\_var1 left by var2 positions.
If var2 is negative, logically shift right W\_var1 by (-var2).

%........................................................
\NewOperator{W\_lshr(W\_var1, var2)}

Logically shift the 64-bit input W\_var1 right by var2 positions.
If var2 is negative, logically shift left W\_var1 by (-var2).

%........................................................
\NewOperator{W\_round64\_L(W\_var1)}

Rounds the lower 32 bits of the 64-bit input number W\_var1 into the most significant 32 bits with saturation.
Shifts the resulting bits right by 32 and returns the 32-bit number.\\
If W\_var1 is in 1Q63 format, then the result returned will be rounded and saturated to 1Q31 format.



%----------------------------------------------------------------------
\section{Basic operators which use 32-bit precision multiply}

Basic operators in this section are useful for FFT and scaling functions where the result of a 32\*16 or 32\*32 arithmetic operation is rounded, and saturated to 32-bit value.
There is no accumulation of products in these functions.
In functions that accumulate products, you should use base operators in Section \ref{basop64bitoperators}.

All basic operators in this section have a complexity weight of 1.

%........................................................
\subsection{Variable definitions}

The variables used in the operators are signed integers in 2's complements representation, defined by:

{\tt var2}: 16-bit variables\\
{\tt L\_var1}, {\tt L\_var2}, {\tt L\_var3}: 32-bit variables


\subsection{Operators}

%........................................................
\NewOperator{Mpy\_32\_16\_1(L\_var1, var2)}

Multiplies the signed 32-bit variable L\_var1 with signed 16-bit variable var2.
Shifts the product left by 1 with 48-bit saturation control;
Returns the 32 MSB of the 48-bit result after truncation of lower 16 bits.
The operation is performed in fractional mode.

For example, if L\_var1 is in 1Q31 format and var2 is in 1Q15 format, then the product is produced in 17Q47 format which is then saturated, truncated and returned in 1Q31 format.

The following code snippet describes the operations performed:

\rulex{2mm}{\tt W\_var1 = W\_mult\_32\_16 ( L\_var1, var2 );}\\
\rulex{2mm}{\tt L\_var\_out = W\_sat\_m( W\_var1 );}


%........................................................
\NewOperator{Mpy\_32\_16\_r(L\_var1, var2)}

Multiplies the signed 32-bit variable L\_var1 with signed 16-bit variable var2. Shifts the product left by 1 with 48-bit saturation control; Returns the 32 MSB of the 48-bit result after rounding of the lower 16 bits.
The operation is performed in fractional mode.
For example, if L\_var1 is in 1Q31 format and var2 is in 1Q15 format, then the product is produced in 17Q47 format which is then rounded, saturated, and returned in 1Q31 format.

The following code snippet describes the operations performed:

\rulex{2mm}{\tt W\_var1 = W\_mult\_32\_16( L\_var1, var2 );}\\
\rulex{2mm}{\tt L\_var\_out = W\_round48\_L (W\_var1);}

%........................................................
\NewOperator{Mpy\_32\_32(L\_var1, L\_var2)}

Multiplies the signed 32-bit variable L\_var1 with signed 32-bit variable L\_var2.
Shifts the product left by 1 with 64-bit saturation control;
Returns the 32 MSB of the 64-bit result after truncating of the lower 32 bits.
The operation is performed in fractional mode.

For example, if L\_var1 is in 1Q31 format and var2 is in 1Q31 format, then the product is produced in 1Q63 format which is then truncated, saturated, and returned in 1Q31 format.

The following code snippet describes the operations performed:

\rulex{2mm}{\tt W\_var1 = (( Word64)L\_var1 * L\_var2);}\\
\rulex{2mm}{\tt L\_var\_out = W\_extract\_h(W\_shl(W\_var1, 1) );}

%........................................................
\NewOperator{Mpy\_32\_32\_r(L\_var1, L\_var2)}

Multiplies the signed 32-bit variable L\_var1 with signed 32-bit variable L\_var2.
Adds rounding offset to lower 31 bits of the product.
Shifts the result left by 1 with 64-bit saturation control; returns the 32 MSB of the 64-bit result with saturation control.

The operation is performed in fractional mode.
For example, if L\_var1 is in 1Q31 format and L\_var2 is in 1Q31 format, then the result is produced in 1Q63 format which is then rounded, saturated, and returned in 1Q31 format.

The following code snippet describes the operations performed:

\rulex{2mm}{\tt W\_var1 = (( Word64)L\_var1 * L\_var2);}\\
\rulex{2mm}{\tt W\_var1 = W\_var1 + 0x40000000LL;}\\
\rulex{2mm}{\tt W\_var1 = W\_shl ( W\_var1, 1 );}\\
\rulex{2mm}{\tt L\_var\_out = W\_extract\_h( W\_var1 );}

%........................................................
\NewOperator{Madd\_32\_16(L\_var3, L\_var1, var2)}

Multiplies the signed 32-bit variable L\_var1 with signed 16-bit variable var2.
Shift the product left by 1 with 48-bit saturation control; Add the 32-bit MSB of the 48-bit result with 32-bit L\_var3 with 32-bit saturation control.
The operation is performed in fractional mode.

For example, if L\_var1 is in 1Q31 format and var2 is in 1Q15 format, then the product is produced in 17Q47 format which is then saturated, truncated to 1Q31 format and added to L\_var3 in 1Q31 format.

The following code snippet describes the operations performed:

\rulex{2mm}{\tt L\_var\_out = Mpy\_32\_16\_1(L\_var1, var2);}\\
\rulex{2mm}{\tt L\_var\_out = L\_add(L\_var3, L\_var\_out);}

%........................................................
\NewOperator{Madd\_32\_16\_r(L\_var3, L\_var1, var2)}

Multiplies the signed 32-bit variable L\_var1 with signed 16-bit variable var2.
Shifts the product left by 1 with 48-bit saturation control;
Gets the 32-bit MSB from 48-bit result after rounding of the lower 16 bits and adds this with 32-bit L\_var3 with 32-bit saturation control.

The operation is performed in fractional mode.

For example, if L\_var1 is in 1Q31 format and var2 is in 1Q15 format, then the product is produced in 17Q47 format which is then saturated, rounded to 1Q31 format and added to L\_var3 in 1Q31 format.

The following code snippet describes the operations performed:

\rulex{2mm}{\tt L\_var\_out = Mpy\_32\_16\_r(L\_var1, var2);}\\
\rulex{2mm}{\tt L\_var\_out = L\_add(L\_var3, L\_var\_out);}

%........................................................
\NewOperator{Msub\_32\_16(L\_var3, L\_var1, var2)}

Multiplies the signed 32-bit variable L\_var1 with signed 16-bit variable var2.
Shifts the product left by 1 with 48-bit saturation control; Subtracts the 32-bit MSB of the 48-bit result from 32-bit L\_var3 with 32-bit saturation control.

The operation is performed in fractional mode.

For example, if L\_var1 is in 1Q31 format and var2 is in 1Q15 format, then the product is produced in 17Q47 format which is then saturated, truncated to 1Q31 format and subtracted from L\_var3 in 1Q31 format.

The following code snippet describes the operations performed:

\rulex{2mm}{\tt L\_var\_out = Mpy\_32\_16\_1(L\_var1, var2);}\\
\rulex{2mm}{\tt L\_var\_out = L\_sub(L\_var3, L\_var\_out);}

%........................................................
\NewOperator{Msub\_32\_16\_r(L\_var3, L\_var1, var2)}

Multiplies the signed 32-bit variable L\_var1 with signed 16-bit variable var2.
Shifts the product left by 1 with 48-bit saturation control; Gets the 32-bit MSB from 48-bit result after rounding of the lower 16 bits and subtracts this from 32-bit L\_var3 with 32-bit saturation control.

The operation is performed in fractional mode.

For example, if L\_var1 is in 1Q31 format and var2 is in 1Q15 format, then the product is produced in 17Q47 format which is then saturated, rounded to 1Q31 format and subtracted from L\_var3 in 1Q31 format.

The following code snippet describes the operations performed:

\rulex{2mm}{\tt L\_var\_out = Mpy\_32\_16\_r(L\_var1, var2);}\\
\rulex{2mm}{\tt L\_var\_out = L\_sub(L\_var3, L\_var\_out);}

%........................................................
\NewOperator{Madd\_32\_32(L\_var3, L\_var1, L\_var2)}

Multiplies the signed 32-bit variable L\_var1 with signed 32-bit variable L\_var2.
Shifts the product left by 1 with 64-bit saturation control; Adds the 32 MSB of the 64-bit result to 32-bit signed variable L\_var3 with 32-bit saturation control.

The operation is performed in fractional mode.
For example, if L\_var1 is in 1Q31 format and L\_var2 is in 1Q31 format, then the product is saturated and truncated in 1Q31 format which is then added to L\_var3 (in 1Q31 format), to provide result in 1Q31 format.

The following code snippet describes the operations performed:

\rulex{2mm}{\tt L\_var\_out = Mpy\_32\_32(L\_var1, L\_var2);}\\
\rulex{2mm}{\tt L\_var\_out = L\_add(L\_var3, L\_var\_out);}

%........................................................
\NewOperator{Madd\_32\_32\_r(L\_var3, L\_var1, L\_var2)}

Multiplies the signed 32-bit variable L\_var1 with signed 32-bit variable L\_var2.
Adds rounding offset to lower 31 bits of the product.
Shifts the result left by 1 with 64-bit saturation control;
gets the 32 MSB of the 64-bit result with saturation and adds this with 32-bit signed variable L\_var3 with 32-bit saturation control.

The operation is performed in fractional mode.

For example, if L\_var1 is in 1Q31 format and L\_var2 is in 1Q31 format, then the product is saturated and rounded in 1Q31 format which is then added to L\_var3 (in 1Q31 format), to provide result in 1Q31 format.

The following code snippet describes the operations performed:

\rulex{2mm}{\tt L\_var\_out = Mpy\_32\_32\_r(L\_var1, L\_var2);}\\
\rulex{2mm}{\tt L\_var\_out = L\_add(L\_var3, L\_var\_out);}

%........................................................
\NewOperator{Msub\_32\_32(L\_var3, L\_var1, L\_var2)}

Multiplies the signed 32-bit variable L\_var1 with signed 32-bit variable L\_var2.
Shifts the product left by 1 with 64-bit saturation control;
Subtracts the 32 MSB of the 64-bit result from 32-bit signed variable L\_var3 with 32-bit saturation control.

The operation is performed in fractional mode.

For example, if L\_var1 is in 1Q31 format and L\_var2 is in 1Q31 format, then the product is saturated and truncated in 1Q31 format which is then subtracted from L\_var3 (in 1Q31 format), to provide result in 1Q31 format.

The following code snippet describes the operations performed:

\rulex{2mm}{\tt L\_var\_out = Mpy\_32\_32(L\_var1, L\_var2);}\\
\rulex{2mm}{\tt L\_var\_out = L\_sub(L\_var3, L\_var\_out);}

%........................................................
\NewOperator{Msub\_32\_32\_r(L\_var3, L\_var1, L\_var2)}

Multiplies the signed 32-bit variable L\_var1 with signed 32-bit variable L\_var2.
Adds rounding offset to lower 31 bits of the product. Shifts the result left by 1 with 64-bit saturation control;
gets the 32 MSB of the 64-bit result with saturation and subtracts this from 32-bit signed variable L\_var3 with 32-bit saturation control.

The operation is performed in fractional mode.

For example, if L\_var1 is in 1Q31 format and L\_var2 is in 1Q31 format, then the product is saturated and rounded in 1Q31 format which is then subtracted from L\_var3 (in 1Q31 format), to provide result in 1Q31 format.

The following code snippet describes the operations performed:

\rulex{2mm}{\tt L\_var\_out = Mpy\_32\_32\_r(L\_var1, L\_var2);}\\
\rulex{2mm}{\tt L\_var\_out = L\_sub(L\_var3, L\_var\_out);}



%----------------------------------------------------------------------
\section{Description of the basic operators for control operations}
%----------------------------------------------------------------------

The following basic operators should be used in the control processing part of the reference code.
They are expected to help compilers generate more efficient code for control sections of the reference C code.
In addition, they also help in computing a more accurate representation of control code operations in the total WMOPs (weighted millions of operations) of the reference code.

All operators in this section have a complexity weight of 1.

\subsection{Variable definitions}

The variables used in the operators are signed integers in 2's complements representation, defined by:

{\tt var1}, {\tt var2}: 16-bit variables\\
{\tt L\_var1}, {\tt L\_var2}: 32-bit variables\\
{\tt W\_var1}, {\tt W\_var2}: 64-bit variables

%........................................................
\NewOperator{LT\_16(var1, var2)}

Returns 1 if 16-bit variable var1 is less than 16-bit variable var2, else returns 0.

%........................................................
\NewOperator{GT\_16(var1, var2)}

Returns 1 if 16-bit variable var1 is greater than 16-bit variable var2, else returns 0.

%........................................................
\NewOperator{LE\_16(var1, var2)}

Returns 1 if 16-bit variable var1 is less than or equal to 16-bit variable var2, else return 0.

%........................................................
\NewOperator{GE\_16(var1, var2)}

Returns 1 if 16-bit variable var1 is greater than or equal to 16-bit variable var2, else returns 0.

%........................................................
\NewOperator{EQ\_16(var1, var2)}

Returns 1 if 16-bit variable var1 is equal to 16-bit variable var2, else returns 0.

%........................................................
\NewOperator{NE\_16(var1, var2)}

Returns 1 if 16-bit variable var1 is not equal to 16-bit variable var2, else returns 0.

%........................................................
\NewOperator{LT\_32(L\_var1, L\_var2)}

Returns 1 if 32-bit variable L\_var1 is less than 32-bit variable L\_var2, else returns 0.

%........................................................
\NewOperator{GT\_32(L\_var1, L\_var2)}

Returns 1 if 32-bit variable L\_var1 is greater than 32-bit variable L\_var2, else returns 0.

%........................................................
\NewOperator{LE\_32(L\_var1, L\_var2)}

Returns 1 if 32-bit variable L\_var1 is less than or equal to 32-bit variable L\_var2, else returns 0.

%........................................................
\NewOperator{GE\_32(L\_var1, L\_var2)}

Returns 1 if 32-bit variable L\_var1 is greater than or equal to 32-bit variable L\_var2, else returns 0.

%........................................................
\NewOperator{EQ\_32(L\_var1, L\_var2)}

Returns 1 if 32-bit variable L\_var1 is equal to 32-bit variable L\_var2, else returns 0.

%........................................................
\NewOperator{NE\_32(L\_var1, L\_var2)}

Returns 1 if 32-bit variable L\_var1 is not equal to 32-bit variable L\_var2, else returns 0.

%........................................................
\NewOperator{LT\_64(W\_var1, W\_var2)}

Returns 1 if 64-bit variable W\_var1 is less than 64-bit variable W\_var2, else returns 0.

%........................................................
\NewOperator{GT\_64(W\_var1, W\_var2)}

Returns 1 if 64-bit variable W\_var1 is greater than 64-bit variable W\_var2, else returns 0.

%........................................................
\NewOperator{LE\_64(W\_var1, W\_var2)}

Returns 1 if 64-bit variable W\_var1 is less than or equal to 64-bit variable W\_var2, else returns 0.

%........................................................
\NewOperator{GE\_64(W\_var1, W\_var2)}

Returns 1 if 64-bit variable W\_var1 is greater than or equal to 64-bit variable W\_var2, else returns 0.

%........................................................
\NewOperator{NE\_64(W\_var1, W\_var2)}

Returns 1 if 64-bit variable W\_var1 is not equal to 64-bit variable W\_var2, else returns 0.

%........................................................
\NewOperator{EQ\_64(W\_var1, W\_var2)}

Returns 1 if 64-bit variable W\_var1 is equal to 64-bit variable W\_var2, else returns 0.

%-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.
\section{Description of the control basic operators and associated weights}

This section describes the different control basic operators available in the STL and their associated complexity weights.
The complexity values to be considered (since the publication of the STL2005) are the ones related to 2.0 and subsequent versions of the library.

\textbf{A set of coding guidelines must be followed} in order to avoid algorithm complexity miss-evaluation.
This section describes also these guidelines.

\subsection{Operators and complexity weights}
Nine macros are defined to enable the evaluation of the complexity
associated to control instructions that are frequently used in C.

\begin{list}{o}{}
    \item The \textbf{IF(expression)} and \textbf{ELSE} macros
    evaluate the cost of the C statement:
    {\small
    \begin{verbatim}
        if (expression) {...}[[else if(expression2) {...}] else {...}]
    \end{verbatim}}
    \item The \textbf{SWITCH(expression)} macro evaluates the cost of the C
    statement:
    {\small
    \begin{verbatim}
        switch (expression) {...}
    \end{verbatim}}
    \item The \textbf{WHILE (expression)} macro evaluates the cost of the C
    statement:
    {\small
    \begin{verbatim}
        while (expression) {...}
    \end{verbatim}}
    \item The \textbf{FOR (expr1;expr2; expr3)} macro evaluates the cost
    of the C statement:
    {\small
    \begin{verbatim}
        for (expr1; expr2; expr3) {...}
    \end{verbatim}}
    \item The \textbf{DO} and \textbf{WHILE(expression)} macros evaluates
    the cost of the C statement:
    {\small
    \begin{verbatim}
        do {...} while (expression)
    \end{verbatim}}
    \item The \textbf{CONTINUE} macro evaluates the cost of the C statement:\\
    {\small
    \begin{verbatim}
        while (expression) {
        ...
        continue;
        ...
        }
    \end{verbatim}}
    or
    {\small
    \begin{verbatim}
        for (expr1; expr2; expr3) {
        ...
        continue;
        ...
        }
    \end{verbatim}}
    \item The \textbf{BREAK} macro evaluates the cost of the C statement:
    {\small
    \begin{verbatim}
        while(expression)
        {
        ...
        break;
        ...
        }
    \end{verbatim}}
    or
    {\small
    \begin{verbatim}
        for (expr1; expr2; expr3) {
        ...
        break;
        ...
        }
    \end{verbatim}}
    or
    {\small
    \begin{verbatim}
        switch(...) {
        ...
        break;
        ...
        }
    \end{verbatim}}
    \item The \textbf{GOTO} macro evaluates the cost of the C statement:
    {\small
    \begin{verbatim}
        goto label;
    \end{verbatim}}
\end{list}

Table \ref{tbl:control-basicop} summarizes the control basic operators and their associated complexity.

%-------------------------------------------------------------------------
% Table with the control basic operators and their associated complexity.
%-------------------------------------------------------------------------
\begin{table}[th]
    \Caption{14cm}{\SF Control basic operators and associated complexity. \label{tbl:control-basicop}}
    \begin{center}
        \footnotesize
        \begin{tabularx}{\textwidth}{|c|X|X|}
            \hline Complexity Weight  & Basic Operator  & Description\\
            \hline \hline {0}    &
            \textbf{DO}\{...\} while(expression) &
            \SF The macro DO must be used instead of the 'do' C statement.\\
            \hline {3} &
            \textbf{FOR}(expr1; expr2; expr3) \{...\} &
            \SF The macro FOR must be used instead of the 'for' C statement.
            The complexity is \textbf{independent} of the number of loop iterations that are performed. \\
            \hline {0} &
            \parbox[t]{60mm}{\SF \textbf{if}(expression)
            \textbf{one\_and\_only\_one\_basic\_operator (control operators excluded)}} &
            \SF \textbf{The macro IF must not be used} when the 'if' structure does not have any 'else if' nor 'else' statement and it conditions only one basic operator (control operators excluded). \\
            \hline {3} &
            \parbox[t]{60mm}{\SF \textbf{IF}(expression) \{...\}} &
            \SF The macro IF must be used instead of the 'if' C statement \textbf{in every other case}: when there is an 'else' or 'else if' statement, or when the 'if' conditions several basic operators, or when the 'if' conditions a function call or when the 'if' conditions a control operator.\\
            \hline {4} &
            \parbox[t]{60mm}{\SF if(expression) \{...\} [[\\
            \textbf{ELSE} if(expression2)\{...\}]\\
            \textbf{ELSE} \{...\}]} &
            \SF The macro ELSE must be used instead of the 'else' C statement.\\
            \hline {6} &
            \textbf{SWITCH}(expression) \{...\} &
            \SF The macro SWITCH must be used instead of the 'switch' C statement.\\
            \hline {3} &
            \textbf{WHILE}(expression) \{...\} &
            \SF The macro WHILE must be used instead of the 'while' C statement.
            The complexity is \textbf{proportional} to the number of loop iterations that are performed.\\
            \hline {2} &
            \parbox[t]{60mm}{\SF while(expression) \{ \\
            ... \textbf{CONTINUE}; ...\\ \}\\
            or\\
            for(expr1; expr2; expr3) \{ \\
            ...\\
            \textbf{CONTINUE}; \\
            ...\\
            \}} &
            \SF The macro CONTINUE must be used instead of the 'continue' C statement.\\
            \hline {2} &
            \parbox[t]{60mm}{\SF while(expression) \{ \\
            ...\textbf{BREAK}; ...\\
            \}\\
            or\\
            for(expr1; expr2; expr3) \{\\
            ...\\
            \textbf{BREAK}; \\...\\
            \}\\
            or\\
            switch(var) \{ \\
            ...\\
            \textbf{BREAK};\\
            ...
            \\
            \}} &
            \SF The macro BREAK must be used instead of the 'break' C statement.\\
            \hline {2} &
            \textbf{GOTO}  &
            \SF The macro GOTO must be used instead of the 'goto' C statement.\\
            \hline
        \end{tabularx}
    \end{center}
\end{table}

%\flushfloats

\subsection{Coding guidelines}
\subsubsection{When to use IF() instead of if()?}

The \textbf{IF}() macro must be used instead of the classical C
statement \textbf{if}(), wherever:
\begin{list}{}
    \item o There is an else or else if statement, \item o There is
    \textbf{strictly more than one basic operators} to condition, \item
    o There is at least a function call to condition. \item o There is
    a control basic operator to condition.
\end{list}
An example code:
{\small
\begin{verbatim}
    if (x == 0)
    z = add(z, sub(y, x)); /* more than one basic ops */
    if (z == 0)
    Decode(); /* function call */
    something();
\end{verbatim}}
must be written as:
{\small
\begin{verbatim}
    IF (x == 0)
    z = add(z, sub(y, x));
    IF (z == 0)
    Decode();
    something();
\end{verbatim}}

While below code must stay untouched since \textbf{only one} basic
operator
is conditioned.
{\small
\begin{verbatim}
    if (x == 0)
    z = add(z, x); /* one basic op */
    something();
\end{verbatim}}

\subsubsection{When to use FOR() and WHILE() macros?}

The {\tt FOR()} and {\tt WHILE()} macros must be used to differentiate
loops which can be handled by a h/w loop controller from complex loops
which need to be controlled by additional control software.

\flushfloats

\begin{list}{o}
    \item Follows an example of a \textbf{simple h/w loop} that must
    be designed with the \textbf{FOR()} macro. It will iterate
    C-statement E0 to E20 a number of times \textbf{known at loop
    entry} (and at least once). Therefore, for such loops, there is no
    complexity associated to the computation of the decision to loop
    back or not:
    {\small
    \begin{verbatim}
        /* var1 > 0 is ensured  */
        FOR (n = 0; n < var1; n++) {
        E0;
        /* never do anything that impacts "var1" nor "n" value */
        E20;
        }
    \end{verbatim}}

    \item Follows an example of a \textbf{complex s/w loop} that must be
    designed with the \textbf{WHILE()}. It will iterate C-statement E0 to
    E20 a number of times \textbf{undefined} at loop entry (eventually 0
    times). Indeed, at the end of one loop iteration, the decision to loop
    back depends on the processing done within the elapsed iteration.
    {\small
    \begin{verbatim}
        /* do not need to ensure n < var1 at loop entry */
        WHILE (n < var1) {
        E0;
        /* can do anything that impacts "var1" or "n" value */
        E20;
        }
    \end{verbatim}}
\end{list}

ANSI-C defines \textbf{for}() structures with \textbf{while}()
structures, but by differencing the \textbf{FOR}() and
\textbf{WHILE}() macro usage, a better complexity evaluation of
the loop controlling is made.

\begin{list}{}
    \item o A loop defined with FOR() macro:
    \begin{list}{}
        \item - \textbf{Only counts the initial set-up} of the h/w loop controller with a complexity weight of 3.
        \item - \textbf{Must iterate at least once}.
        \item - Has a complexity \textbf{independent} of the number of iterations that are performed.
    \end{list}
    \item o A Loop defined with WHILE() macro:
    \begin{list}{}
        \item - Counts, at \textbf{every single iteration} which is executed,
        \textbf{the complexity associated to the computation of the
        decision to loop back or not}.
        \item - \textbf{Can be executed 0 times.}
        \item - Has a complexity \textbf{proportional} (by a factor
        of  4) to the number of iterations that are performed.
    \end{list}
\end{list}

\subsubsection{When to use DO and WHILE() macros?}
It is important to \textbf{modify} below C code:
{\small
\begin{verbatim}
    do {
    x = sub(x, y)
    } while (x < 0);
\end{verbatim}}
into following one: \\
{\small
\begin{verbatim}
    DO {
    x = sub(x, y)
    } WHILE (x < 0);
\end{verbatim}}

The following code is also possible but, although the associated
complexity computation will be identical, it can generate parsing
errors by some source code editors which perform on-the-fly syntax
checking.
{\small
\begin{verbatim}
    do {
    x = sub(x, y)
    } WHILE (x < 0);
\end{verbatim}}

\subsubsection {Testing an expression equality}

\textbf{\emph{if(expression) \{...\} and while(expression) \{...\}
C statements.}}

All arithmetic tests on data must be presented as a comparison to
zero. To perform comparison between two variables (or a variable
and a non-zero constant), a subtraction (\textbf{sub} or
\textbf{L\_sub} or \textbf{L40\_sub}) must be performed first.

For example, below examples leads to an under evaluation of the
complexity:
{\small
\begin{verbatim}
    if (a > 3) { }
    while (a != 5) { } ...
\end{verbatim}}

While, below examples leads to a correct evaluation of the
complexity:
{\small
\begin{verbatim}
    if (sub(a,3) > 0) { }
    while (sub(a, 5) != 0) { } ...
\end{verbatim}}

If multiple condition need to be evaluated and merged, one
\textbf{test}() operator must be used for each additional test to be
done.

Example 1:

The following code ...

\rulex{10mm}if ( (a $>$ b) \&\& (c $>$ d)) \{\}

... must be modified to:

\rulex{10mm}\textbf{test}(); \\
\rulex{10mm}if ( (sub( a, b) $>$ 0) \&\& (sub( c, d) $>$ 0)) \{\}

Example 2:

The following code ...\\
\rulex{10mm}if ( (a $>$ b) \\
\rulex{10mm}\&\& (c $>$ d) \\
\rulex{10mm}$||$(e $>$ f)) \{\}

... must be modified to:\\
\rulex{10mm}\textbf{test}(); \\
\rulex{10mm}\textbf{test}(); \\
\rulex{10mm}if (  (sub( a, b) $>$ 0)\\
\rulex{10mm}\&\& ( sub( c, d) $>$ 0)\\
\rulex{10mm}$||$ (sub( e, f) $>$ 0)) \{\}\\

\ \\
\textbf{\emph{(condition) ? (statement1) : (statement2)}}

The ternary operator ``\textbf{? \ :}'' must not be used since it does
not enable the evaluation of the associated complexity.

Therefore, instead of writing: \\
\rulex{10mm}(condition) ? (statement1) : (statement2)

One must write: \\
\rulex{10mm}IF(condition)\\
\rulex{15mm}{statement1};\\
\rulex{10mm}ELSE\\
\rulex{15mm}{statement2};

Whenever it is possible to avoid the \textbf{else} clause, one should write:\\
\rulex{10mm}{statement2};\\
\rulex{10mm}IF(condition)\\
\rulex{15mm}{statement1};

And whenever \textbf{statement1} is \textbf{one and only one basic
operator} (control operator excluded), one can write:\\
\rulex{10mm}{statement2};\\
\rulex{10mm}if(condition)\\
\rulex{15mm}{one\_and\_only\_one\_basic\_operator};\\

\textbf{\emph{for(expresion1; expression2; expression3)}}

A ``\textbf{for}'' C statement must be limited to initializing,
testing and incrementing the loop counter. The following C code
statement is an example of incorrect usage:

\rulex{10mm}for(i=0, j=0; i$<$N \& w$>$0 ; i++, j+=3)

It must be replaced by: \\
\rulex{10mm}j=0;\\
\rulex{10mm}for(i=0; i$<$N ; i++) \{\\
\rulex{15mm}j = add(j,3);\\
\rulex{15mm}if(w $>$ 0)\\
\rulex{18mm}break; \\
\rulex{10mm}\}

Actually, in order to respect the other recommendations, it must
be replaced by: \\
\rulex{10mm}j=0;\\
\rulex{10mm}FOR(i=0; i$<$N ; i++) \{\\
\rulex{15mm}j = add(j,3);\\
\rulex{15mm}if(w $>$ 0)\{\\
\rulex{18mm}BREAK; \\
\rulex{15mm}\}\\
\rulex{10mm}\}

%\subsubsection{}

\section{Complexity associated with data moves and other operations}

\subsection{Data moves}

Each data move between two 16-bit or two 32-bit variables, \textbf{move16}() and \textbf{move32}() operators respectively, has a complexity weight of 1.

\begin{enumerate}{}{}
    \item A 16-bit variable cannot be directly moved to a 32-bit or 40-bit variable.
    \item A 32-bit variable cannot be directly moved to a 16-bit or 40-bit variable.
    \item A 40-bit variable cannot be directly moved to a 16-bit or 32-bit variable.
\end{enumerate}

For above 3 types of moves, functions such as the following ones
must be used:
\begin{center}
    \begin{tabular}{|c|c|c|}
        \hline
        \hline round\_fx() & round40()   & L\_saturate40()\\
        \hline extract\_h() & Extract40\_H()   & L\_Extract40()\\
        \hline extract\_l() & Extract40\_L()   & L40\_deposit32()\\
        \hline L\_deposit\_h()   & L40\_deposit\_h() & \\
        \hline L\_deposit\_l()   & L40\_deposit\_l() & \\
        \hline
    \end{tabular}
\end{center}

There will be no extra weighting for data move when using above
functions: the weighting of the data move is already included in
the weighting of these functions.

Data moves are only counted in
the following cases:
\begin{enumerate}
    \item A data move from a constant to a variable;
    \item A data move from a variable to a variable;
    \item A data move of the result of a basic operation to an array;
    \item A typecast from a Word8 to a Word16 variable;
    \item A typecast from a Word8 to a Word32 variable.
\end{enumerate}

\subsubsection{Is it necessary to count the complexity of typecast
from Word8 to Word16 or Word32?}
Following example shows necessity:
{\tt\small
\begin{verbatim}
    const Word8 tbl[2] = {0x1, 0x2};

    Word16 tmp;
    tmp = add((Word16 )tbl[0], (Word16 )tbl[1]); move16(); move16();
    a = my\_function((Word16 )tbl[0], (Word16 )tbl[1]); move16(); move16();
    /* assuming my\_function requires 2 Word16 parameters. */
\end{verbatim}
}

\subsubsection{Is it necessary to count an address calculation when initializing a pointer?}
For a case when initializing a pointer with an address, extra weight
count, e.g. move16(), is not necessary because address computation is
not counted as a part of the complexity. For example:
{\tt\small
\begin{verbatim}
    Word16 *p;
    p = \&(array[1]); /* move16() not necessary */
\end{verbatim}
}% \textcolor{green}{[EDNOTE: \#02]}

\subsubsection{Does return value assignment need to be counted?}
When a return value of a function is assigned, it does not require
move16() count. For example:
{\tt\small
\begin{verbatim}
    Word16 a = function(b); /* move16() not necessary */
\end{verbatim}
}% \textcolor{green}{[EDNOTE: \#04]}
Here is another example that does not require copy count:
{\tt\small
\begin{verbatim}
    Word16 function(Word16 b) {
    return (add(b, 1)); /* move16() not necessary */.
    }
\end{verbatim}
}% \textcolor{green}{[EDNOTE: \#05 and \#07]}

Introducing dummy functions to avoid extra basop
counts must be avoided. % \textcolor{green}{[EDNOTE: \#08]}
% \textcolor{green}{[EDNOTE: \#05 and \#07]}
% \textcolor{green}{%
%
% However, the following is an example that takes advantage of no
% penalty counts for the return value assignment, and this \textbf{must be
% avoided}:
% }
% {\tt\small
% \begin{verbatim}
%   /* following dummy function to save move16() must avoided */
%   Word16 function(Word16 b) {
%      if(b>0) {b=1;move16();}
%      return b;
%   }
% \end{verbatim}
% } \Textcolor{green}{[EDNOTE: \#08]}

\subsubsection{What to do with return value of a macro?}
When copying return value of a complex macro to a variable, it does
not require extra weight count as in a return value of a function:
{\tt\small
\begin{verbatim}
    Word32 w = Mpy\_32(); /* move32() not required */
\end{verbatim}
} % \textcolor{green}{[EDNOTE: \#12]}

\subsection{Other operations}

Address computation must be excluded from the complexity
evaluation. However, when extremely complex address computations
are done, these address computations should be resolved using the
basic operations, in order to account for the associated
complexity.

For example, incrementation of an address by one does not require an
extra count, but followings would be considered complex:
{\tt\small
\begin{verbatim}
    j=0; move16();
    FOR( i=0; i<5; i++) {
    sum = add(sum, array[j]);
    j = add(j,i);
    }"
\end{verbatim}
} % \textcolor{green}{[EDNOTE: \#09]}

%----------------------------------------------------------------------
\section{Program ROM estimation tool for fixed-point C Code}
%----------------------------------------------------------------------

\subsection{Tool Description }
This tool is developed to help the estimation of program ROM of
applications written using ITU-T Basic Operator libraries. This tool
counts the number of calls to basic operators in a C source file, and
also the number of calls to user defined functions. The sum of these
two numbers gives an estimation of the required PROM for this C source
file. Note that RAM and data ROM have to be estimated by other means.

The tool is meant to provide a consistent, platform independent method
of obtaining and reporting program ROM estimates.

This tool works as follows:
\begin{list}{-}
    \item In a first step, a pre-processing removes C and C++ style
    comments to avoid counting functions that are commented out. The
    result is written in the file with extension {\tt .c\_pre}.\\
    Note that the pre-processor directives are not taken into account,
    so functions of the source code deactivated by a pre-processor
    directive are counted by the tool.
    \item In a second step, the pre-processed file is analysed and the
    number of basic operators (first group) and all other functions
    (second group) are counted. This second group of other functions is
    divided into two sub-groups as it is possible to define a so called
    "blocklist" that contains functions that should not be counted in
    the program ROM. Typically these functions are memory allocation
    functions (malloc, free,\dots), file manipulation functions (fopen,
    fclose, fwrite, printf,\dots) or even functions related to complexity
    counting (setCounter, WMOPS\_output, fwc,\dots). This list is
    already initialized and can be further edited and completed if
    needed. The other subgroup is called user defined functions as it
    consists of all functions which are neither basic operators nor
    blocklist functions.
\end{list}

At the end of the execution, the results are printed out on the
standard output indicating the names of the C file and of the
pre-processed file, the number of calls to basic operators, the number
of calls to user defined functions, and the number of calls to
blocklist functions.

When a result file name is also given as second optional argument of
the command line, a summary of the results is written in this result
file in append mode. Thus, to estimate the program ROM of a given
application, the tool has to be run for all C files of the application
using the same result file. Each call adds a new line in for the input
C file. Though the format of the result file is a text file with tab
separators, it is advised to name it with .xls extension and open it
with Microsoft Excel.

The Excel file has as many rows as the number of C files. For each
row, there are four columns: the first column contains the ANSI C
input file name, the second the number of calls to basic operators,
the third the number of calls to user defined functions and the fourth
the number of calls to blocklist functions. In this way the program
ROM of an application containing several C source files can be easily
estimated as the sum of the numbers in the second and third columns.

By defining the pre-pocessor directives {\tt VERBOSE\_BASOP}, {\tt
VERBOSE\_FUNC} or\\ {\tt VERBOSE\_BLOCKLIST\_FUNC} the detailed list
of called function for basic operator functions, user defined
functions and blocklist functions respectively, is also printed
out. This allows an easy cross-check of the results.

This tool is optimized for the basic operators of STL2005 or later. In
case of estimating the program ROM of an application written using
earlier STL basic operators, it is advised to define the pre-processor
directive {\tt OLD\_STL}. In this case some C operators like if, do
are not counted directly as they should be accompanied by the basic
operator {\tt test()}, and this later is counted by the tool.

\subsection{Tool implementation}
The tool consists of one ANSI C file {\tt basop\_cnt.c}.

To use this tool the C source file {\tt basop\_cnt.c} has to be
compiled and linked. The resulted executable file has to be called for
each C source file of the examined application, with the following
syntax:
\begin{verbatim}
basop\_cnt input.c [result\_file\_name.txt]}
\end{verbatim}
where $input.c$ is an ANSI C file and $result\_file\_name.txt$ the
ouput result file.

If needed to further edit the list of functions that should not
be counted in the program ROM, modify {\tt const char blocklist[][20]
= \{{\dots}\}} in basop\_cnt.c before compilation.


\subsection{Example}
This tool was first used to estimate the program ROM of the G.722 PLC
candidate algorithms.  The example below gives the execution of this
tool with part of G.722 appendix IV\footnote{this example does not
give the total complexity of G.722 appendix IV}.\\
- without a result file:  {\tt basop\_cnt g722.c} \\
the output is : \\
\texttt{
\begin{tabbing}
Output pre-processed file:..\=\kill
Input file:   \>g722.c\\
Output pre-processed file:\>g722.c\_pre\\
~~87 ~calls to STL basicops\\
~~28 ~calls to user-defined functions\\
~~~8 ~calls to blocklist tokens\\
\end{tabbing}
}
If the pre-processor directive {\tt VERBOSE\_BLOCKLIST\_FUNC} is
defined, the list of the 8 blocklist functions found is also given:
\\ \texttt{
\begin{tabbing}
line..XXX:.\=blocklist X...\=x:\kill
line  ~86:\>blocklist \#  \>1:                          \`          return \\
line  160:\>blocklist \#  \>2:                          \`          calloc \\
line  160:\>blocklist \#  \>3:                          \`          sizeof \\
line  230:\>blocklist \#  \>4:                          \`            free \\
line  271:\>blocklist \#  \>5:                          \`          return \\
line  303:\>blocklist \#  \>6:                          \`          calloc \\
line  303:\>blocklist \#  \>7:                          \`          sizeof \\
line  318:\>blocklist \#  \>8:                          \`            free \\
\end{tabbing}
}
Note that the line numbers correspond to the comment free pre-processed file.

- with a result file g722appIV\_summary.xls:\\
\texttt{
\begin{itemize}
\item basop\_cnt g722.c g722appIV\_summary.xls
\item basop\_cnt funcg722.c	g722appIV\_summary.xls
\end{itemize}
}
After the first call, the result file contains:\\
\begin{tabbing}
\begin{tabular}{|p{3cm}|r|r|r|}
\hline
g722.c & \hspace{6mm}87 & \hspace{6mm}28 & \hspace{7mm}8 \\
\hline
\end{tabular}\\
\end{tabbing}

After the second call, the result file contains:\\
\begin{tabbing}
\begin{tabular}{|p{3cm}|r|r|r|}
\hline
g722.c & \hspace{6mm}87 & \hspace{6mm}28 & \hspace{7mm}8 \\
\hline
funcg722.c & 389 & 41 & 19 \\
\hline
\end{tabular}\\
\end{tabbing}


%----------------------------------------------------------------------
\section{Complexity evaluation tool for floating-point C Code}
\label{ch:cmplx_eval_tool}
%----------------------------------------------------------------------

\subsection{Introduction}
The Complexity evaluation tool for floating-point C Code enables to
estimate the number of WMOPS (Weighted Million Operations per Second)
and Program ROM of a floating-point implementation of speech and audio
codecs. An estimation of the complexity that would be obtained
after conversion of a floating-point source code into the corresponding
fixed-point implementation is also computed.

\subsection{Tool Description }
This tool consists of complexity counters (macros) collected in an ANSI
C library. The library is intended to be included in a codec algorithm,
each line of which is instrumented with the complexity counters. The
tool measures the computational complexity and program ROM based on a
floating-point C source code instrumented with the counters. Note that
RAM and table ROM have to be estimated by other means.

The tool is meant to provide a consistent, platform independent method
of obtaining and reporting complexity estimates. The weights assigned
with arithmetic operations reflect as much as possible those of the
ITU-T Fixed-point Basic Operators. It should be noted, however, that the methodology
cannot give an exact correspondence with the complexity of the fixed-point implementation and only estimation is given. Among several other
reasons, this is because the scaling related operations (including
saturation and overflow control) used in the fixed-point implementation
have no correspondence in the floating-point implementation.

The essential feature of the tool is that the instructions need to be
executed to be counted. Therefore the codec should be executed in
conditions that give the broadest possible coverage of the source code
(i.e. usually at the highest bitrate in frame-error conditions).

\subsection{Complexity Verification Method}
The computational complexity associated with a given speech and audio
codec can be specified in terms of the number of instructions required
per frame. The type and number of operations returned by the algorithm
on a per-frame basis are specified for both the encoder and the
decoder. Algorithms are broken down into sub-processing elements, each
having a detailed breakdown of the types of operations and the number
of operations required to complete the sub-processing element. Certain
operations require several instructions in order to be computed. Thus
all operations have associated with them a weight, indicative of this
expansion, and given in Table \ref{tbl:flp-counters} (column
Complexity Weights).

The total number of instructions required per frame is then given by
summing the total number of weighted operations. This number represents
the basic computational complexity of the codec in instructions per
frame. The complexity in WMOPS is then obtained by dividing the number
of operations per frame by the length of the frame in seconds. The
complexity estimates are computed assuming average and worst case
number of operations both per frame and per second. The complexity
is computed separately for the encoder and the decoder.

The operation count performed for the complexity measurement is re-used
to get an estimate of the program memory. This operation count specifies
operations in loops, loop counters, operations in subroutines, and
subroutine counters. Each operation is weighted using the memory weights
from the Table \ref{tbl:flp-counters} (column Memory Weights) to produce
a memory usage in words. Operations inside loops are counted only once.
Similarly operations inside subroutines are counted only once.

\subsection{Tool implementation}
The tool consists of one header file \textit{flc.h} and one ANSI C library
file \textit{flc.c}. Both files must be included into the project to use
this tool. Further, the code must be instrumented using counters defined
in the Table \ref{tbl:flp-counters} (column Counter). Finally the following
functions are needed:
\begin{itemize}
\item To initialize internal data structures, the function
{\tt FLC\_init()} must be called before any counters are defined,
usually at the beginning of the codec algorithm.
\item The function {\tt FLC\_frame\_update()} must be called at the
end of the frame loop in order the FLC tool can keep track of the
per-frame maxima to evaluate the worst-case conditions.
\item The function {\tt FLC\_end()} computes and prints the complexity
of the program and is called usually at the end of the codec algorithm.
\item The separate complexity of subroutine/subsection is estimated by
calling the function {\tt FLC\_sub\_start(name\_of\_subroutine)} that
must be matched with calling the function {\tt FLC\_sub\_end()} at
the end of the subsection/subroutine.
\end{itemize}

Note that once the code is instrumented using the complexity counters
and functions, the compilation switch {\tt DONT\_COUNT} can be
activated to suppress the functionality of the tool with no need of
removing the complexity counters and functions from the code.

\subsection{Scaling factor}
A scaling factor is used to estimate and print the complexity that
would be obtained after conversion of a floating-point source code
into the corresponding fixed-point implementation. The scaling factor
({\tt FLC\_SCALEFAC}) is defined in file \textit{flc.h} and its value
is set to 1.1.

\subsection{List of complexity measurement counters}

\begin{center}
\begin{longtable}{|m{3.5cm}|m{2.2cm}|m{3.5cm}|m{2.8cm}|m{1.5cm}|}
\caption{\SF Floating-point Complexity Measurement Counters}
\label{tbl:flp-counters}
\\
\hline
Operation&Counter&Example&Complexity Weights (Cycles)&Memory Weights (words)
\endfirsthead
\multicolumn{5}{l}{\small\sl (Table~\ref{tbl:flp-counters} continued from previous page)}\\
\hline
Operation&Counter&Example&Complexity Weights (Cycles)&Memory Weights (words)\\
\hline
\endhead
\hline
\multicolumn{5}{r}{\small\sl (continued on to next page)}\\
\endfoot
\hline
\endlastfoot
\hline
Addition	& ADD()	& a=b+c	& 1	& 1\\
\hline
Multiplication	& MULT()	& a=b*c &	1	& 1 \\
\hline
Multiplication-Addition	& MAC() &	a+=b*c	& 1 &	1 \\
\hline
Move	& MOVE()	& a=b, a[i]=b[i] ONLY assignment or copy	& 1 &	1 \\
\hline
Storing Arithmetic Result in Array	& STORE()	& a[i]=b[i]+c[i]	& 1 (for move only)	& 0\\
\hline
\pagebreak
Logical	& LOGIC()	 & AND, OR, etc.	& 1 &	1 \\
\hline
Shift	& SHIFT()	& a=b$>>$c	& 1 &	1 \\
\hline
Branch (tested with zero)	& BRANCH()	& if, if...then...else...Count 1
BRANCH for each "if" possibility	& 4 &	2 \\
\hline
Division & DIV() &	a=b/c, a=b\%c & 18	& 2 \\
\hline
Square-root	& SQRT()	&a=sqrt(b), a=isqrt(b), a=1/sqrt(b)	& 10	& 2\\
\hline
Transcendental	& TRANS()	& sine, log, arctan	& 25 & 2\\
\hline
Function call	& FUNC()	& a=func(b, c, d) &	2+i, where i=number of arguments passed \& returned	& 2\\
\hline
Loop initialization	&LOOP()	&for (i=0; i$<$n; i++)&	3	&1\\
\hline
\multirow{3}{*}{Indirect addressing}& \multirow{3}{*}{INDIRECT()}	& a=b.c, a=b[c], a=b[c][d],
a=*b, a=*(b+c) & \multirow{3}{*}{2}	&\multirow{3}{*}{2}\\
& & st$->$array & 	& \\
& & st$->$value	&	&\\
\hline
Pointer initialization &	PTR\_INIT()	&a[i]	&1 (charged outside the loop)	&1\\
\hline
Double Precision Addition	&DADD()	&a=b+c	&2&	1\\
\hline
Double Precision Multiplication	&DMULT()	&a=b*c	& 2&	1\\
\hline
Double Precision Move	&DMOVE()	&a=b&	2	&1\\
\hline
Double Precision Division	&DDIV()&	a=b/c	&36&	2\\
\hline
Exponential	& POWER()	& pow, 1.0/x, exp(n)	&25	&2 \\
\hline
Logarithm	&LOG()&	log2, log10, Ln	&25	&2\\
\hline
Extra conditional test& 	TEST()&	used in conjunction with BRANCH &	2	&1\\
\hline
All other operations&	MISC()&	e.g. ABS&	1	&1\\
\hline
\end{longtable}
\end{center}

%% \begin{center}
%%   \tablefirsthead{
%%     \hline
%%     Operation&Counter&Example&Complexity Weights (Cycles)&Memory Weights (words)\\
%%     \hline}
%%   \tablehead{
%%     \hline
%%     \multicolumn{5}{|l|}{\small\sl continued from previous page}\\
%%     \hline
%%     Operation&Counter&Example&Complexity Weights (Cycles)&Memory Weights (words)\\
%%     \hline}
%%   \tabletail{
%%     \hline
%%     \multicolumn{5}{|r|}{\small\sl continued on next page}\\
%%     \hline}
%%   \tablelasttail{\hline}
%%   % \bottomcaption{\SF Floating-point Complexity Measurement Counters
%%   % 		\label{tbl:flp-counters}}
%%   \topcaption{\SF Floating-point Complexity Measurement Counters
%%     \label{tbl:flp-counters}}
%%   \begin{supertabular}{|m{4cm}|m{2.2cm}|m{3.6cm}|m{3.6cm}|m{2cm}|}
%%     \hline
%%     Addition	& ADD()	& a=b+c	& 1	& 1\\
%%     \hline
%%     Multiplication	& MULT()	& a=b*c &	1	& 1 \\
%%     \hline
%%     Multiplication-Addition	& MAC() &	a+=b*c	& 1 &	1 \\
%%     \hline
%%     Move	& MOVE()	& a=b, a[i]=b[i] ONLY assignment or copy	& 1 &	1 \\
%%     \hline
%%     Storing Arithmetic Result in Array	& STORE()	& a[i]=b[i]+c[i]	& 1 (for move only)	& 0\\
%%     \hline
%%     Logical	& LOGIC()	 & AND, OR, etc.	& 1 &	1 \\
%%     \hline
%%     Shift	& SHIFT()	& a=b$>>$c	& 1 &	1 \\
%%     \hline
%%     Branch (tested with zero)	& BRANCH()	& if, if...then...else...Count 1
%%     BRANCH for each "if" possibility	& 4 &	2 \\
%%     \hline
%%     Division & DIV() &	a=b/c, a=b\%c & 18	& 2 \\
%%     \hline
%%     Square-root	& SQRT()	&a=sqrt(b), a=isqrt(b), a=1/sqrt(b)	& 10	& 2\\
%%     \hline
%%     Transcendental	& TRANS()	& sine, log, arctan	& 25 & 2\\
%%     \hline
%%     Function call	& FUNC()	& a=func(b, c, d) &	2+i, where i=number of arguments passed \& returned	& 2\\
%%     \hline
%%     Loop initialization	&LOOP()	&for (i=0; i$<$n; i++)&	3	&1\\
%%     \hline
%%     \multirow{3}{*}{Indirect addressing}& \multirow{3}{*}{INDIRECT()}	& a=b.c, a=b[c], a=b[c][d],
%%     a=*b, a=*(b+c) & \multirow{3}{*}{2}	&\multirow{3}{*}{2}\\
%%     & & st$->$array & 	& \\
%%     & & st$->$value	&	&\\
%%     \hline
%%     Pointer initialization &	PTR\_INIT()	&a[i]	&1 (charged outside the loop)	&1\\
%%     \hline
%%     Double Precision Addition	&DADD()	&a=b+c	&2&	1\\
%%     \hline
%%     Double Precision Multiplication	&DMULT()	&a=b*c	& 2&	1\\
%%     \hline
%%     Double Precision Move	&DMOVE()	&a=b&	2	&1\\
%%     \hline
%%     Double Precision Division	&DDIV()&	a=b/c	&36&	2\\
%%     \hline
%%     Exponential	& POWER()	& pow, 1.0/x, exp(n)	&25	&2 \\
%%     \hline
%%     Logarithm	&LOG()&	log2, log10, Ln	&25	&2\\
%%     \hline
%%     Extra conditional test& 	TEST()&	used in conjunction with BRANCH &	2	&1\\
%%     \hline
%%     All other operations&	MISC()&	e.g. ABS&	1	&1\\
%%     \hline
%%   \end{supertabular}
%% \end{center}

\subsection{Examples of instrumentation of the code}
The rules to compute the complexity are general and when they are
implemented, some choices must be done. Table \ref{tbl:flp-usage}
contains some examples to show where the counters should be placed.

\begin{center}
\begin{longtable}{|m{4.5cm}|m{4.5cm}|m{4cm}|m{2.0cm}|}
\caption{\SF Usage of floating-point complexity measurement counters
\label{tbl:flp-usage}}
\\
\hline
Operation	& Counter used &	Explanation	& Reference\\
\hline
\endfirsthead
\multicolumn{4}{l}{\small\sl (Table~\ref{tbl:flp-usage} continued from previous page)}\\
\hline
Operation	& Counter used &	Explanation	& Reference\\
\hline
\endhead
\hline
\multicolumn{4}{r}{\small\sl (continued on to next page)}\\
\endfoot
\hline
\endlastfoot
if (a!=b $||$ c==d)\{...\}	& ADD(2); BRANCH(1); TEST(1);	&
BRANCH for if, TEST for additional condition, ADD for
two tests against non-zero value	&\\
\hline
if (a!=b \&\& c==d)\{\} else if( a==c )\{\} & ADD(3);
BRANCH(2);TEST(1); & & \\
\hline
b = a / L	& MULT(1); &	When L is constant; (1/L) is a constant too,
So b = a * (1/L)	& \\
\hline
*a = *b	& MOVE(1);	& Copy 	& Table \ref{tbl:flp-counters}, Move\\
\hline
for(i=0;i$<$L;i++) \{x[i]=a[i]+b[i];\}	& LOOP(1);(before)
ADD(1); STORE(1);(inside)	& When a loop begins with an offset,
initialization of pointer is counted	 & \\
for(i=c;i$<$L;i++) \{x[i]=a[i]+b[i];\}	& PTR\_INIT(3), LOOP(1); (before)
ADD(1); STORE(1); (inside)	& 	& \\
\hline
\&pt = \&(a+L)	& PTR\_INIT(1);	& if L is constant and b is variable,
ADD is counted		& \\
\&pt = \&(a+b)	&ADD(1); PTR\_INIT(1);	& & \\
\hline
a=func(b) or a[i]=func(b)	& FUNC(2);	&The value returned by function is counted in FUNC().
MOVE or STORE are not counted in that case	&\\
\hline
a = *b	& INDIRECT(1);	& &	Table \ref{tbl:flp-counters}, Pointer Initialization \\
for(i=0;i$<$L;i++) \{a=*b++;\} a=*b;	& MOVE(1) in the loop MOVE(1) outside the loop
& Use of MOVE outside the loop because the pointer is already initialized
&	Table \ref{tbl:flp-counters}, Move \\
\hline
pt\_a += M	& PTR\_INIT(1);	& M is constant, so this is equivalent to pt\_a=\&pt\_a+M	&\\
\hline
pt\_a += m	& ADD(1); PTR\_INIT(1);	& m is variable, so this is equivalent to  pt\_a=\&pt\_a+m	& \\
\hline
*a=0.99*b	& MULT(1); STORE(1); &	A mathematical result is stored with a pointer & \\
for(i=0;i$<$L;i++) \{a=*b+a;\} & PTR\_INIT(1); (before loop) ADD(1); (inside)
& If a pointer is initialized before the loop, no need to count INDIRECT(1) inside
& \\
\hline
a[b][c]=x[y][z]	& MOVE(1);	& &	Table \ref{tbl:flp-counters}, Move \\
\hline
switch(a)\{ & & Can be replaced by: &\\
case b:break; & \multirow{2}{4.5cm}{ADD(2); BRANCH(2) before switch} &
if (a==b) \{...\} &\\
case c: break; & & else if (a==c) \{...\} &\\
default:break; & & else\{...\} &\\
\} & & & \\
\hline
& & \multirow{4}{4cm}{Use INDIRECT(2) to remove
double indirection and call MOVE(2) to copy data}	& \\
st$->$a[0]=t[2]; & INDIRECT(2); & \\
st$->$a[1]=t[3];	& MOVE(2) & & \\
& & &\\
& & &\\
%& & &\\
\hline
(*rnd\_T0)++	& ADD(1); STORE(1);	&it can be replaced by
*rnd\_T0=*rnd\_T0+1;	& \\
\hline
pit\_shrp( code,  &	FUNC(4);&	  \multirow{2}{4cm}{*round\_T0 is passed by indirection}	&\\
PIT\_SHARP, *round\_T0, L\_SUBFR); &	INDIRECT(1);& 	&\\
\hline
indice[0] = & \multirow{2}{*}{INDIRECT(2);}	& \multirow{2}{*}{Double indirection} &\\
indirect\_dico1[indice[0]];	& & &\\
\hline
sqr = indice[0] +indice[1] +indice[2] +indice[3] +indice[4];&	PTR\_INIT(1);
ADD(4);	&Can be done in a loop	&\\
\hline
\end{longtable}
\end{center}

%% \begin{center}
%% \tablefirsthead{
%% \hline
%% Operation	& Counter used &	Explanation	& Reference \\
%% \hline}
%% \tablehead{
%% \hline
%% \multicolumn{4}{|l|}{\small\sl continued from previous page}\\
%% \hline
%% Operation	& Counter used &	Explanation	& Reference \\
%% \hline}
%% \tabletail{
%% \hline
%% \multicolumn{4}{|r|}{\small\sl continued on next page}\\
%% \hline}
%% \tablelasttail{\hline}
%% \bottomcaption{\SF Usage of floating-point complexity measurement counters
%%          \label{tbl:flp-usage}}
%% \renewcommand{\arraystretch}{1.5}
%% \begin{supertabular}{|m{4.5cm}|m{4.5cm}|m{4cm}|m{2.5cm}|}
%% \hline
%% if (a!=b $||$ c==d)\{...\}	& ADD(2); BRANCH(1); TEST(1);	&
%% BRANCH for if, TEST for additional condition, ADD for
%% two tests against non-zero value	&\\
%% \hline
%% if (a!=b \&\& c==d)\{\} else if( a==c )\{\} & ADD(3);
%% BRANCH(2);TEST(1); & & \\
%% \hline
%% b = a / L	& MULT(1); &	When L is constant; (1/L) is a constant too,
%% So b = a * (1/L)	& \\
%% \hline
%% *a = *b	& MOVE(1);	& Copy 	& Table \ref{tbl:flp-counters}, Move\\
%% \hline
%% for(i=0;i$<$L;i++) \{x[i]=a[i]+b[i];\}	& LOOP(1);(before)
%% ADD(1); STORE(1);(inside)	& When a loop begins with an offset,
%% initialization of pointer is counted	 & \\
%% for(i=c;i$<$L;i++) \{x[i]=a[i]+b[i];\}	& PTR\_INIT(3), LOOP(1); (before)
%%  ADD(1); STORE(1); (inside)	& 	& \\
%% \hline
%% \&pt = \&(a+L)	& PTR\_INIT(1);	& if L is constant and b is variable,
%% ADD is counted		& \\
%% \&pt = \&(a+b)	&ADD(1); PTR\_INIT(1);	& & \\
%% \hline
%% a=func(b) or a[i]=func(b)	& FUNC(2);	&The value returned by function is counted in FUNC().
%% MOVE or STORE are not counted in that case	&\\
%% \hline
%% a = *b	& INDIRECT(1);	& &	Table \ref{tbl:flp-counters}, Pointer Initialization \\
%% for(i=0;i$<$L;i++) \{a=*b++;\} a=*b;	& MOVE(1) in the loop MOVE(1) outside the loop
%% & Use of MOVE outside the loop because the pointer is already initialized
%% &	Table \ref{tbl:flp-counters}, Move \\
%% \hline
%% pt\_a += M	& PTR\_INIT(1);	& M is constant, so this is equivalent to pt\_a=\&pt\_a+M	&\\
%% \hline
%% pt\_a += m	& ADD(1); PTR\_INIT(1);	& m is variable, so this is equivalent to  pt\_a=\&pt\_a+m	& \\
%% \hline
%% *a=0.99*b	& MULT(1); STORE(1); &	A mathematical result is stored with a pointer & \\
%% for(i=0;i$<$L;i++) \{a=*b+a;\} & PTR\_INIT(1); (before loop) ADD(1); (inside)
%% & If a pointer is initialized before the loop, no need to count INDIRECT(1) inside
%% & \\
%% \hline
%% a[b][c]=x[y][z]	& MOVE(1);	& &	Table \ref{tbl:flp-counters}, Move \\
%% \hline
%% switch(a)\{
%% case b:break;
%% case c: break;
%% default:break;
%% \} & ADD(2); BRANCH(2) before switch	& Can be replaced by
%% if (a==b) \{...\} else if(a==c) \{...\} else \{...\} & \\
%% \hline
%% & & &\\
%% st$->$a[0]=t[2]; & INDIRECT(2); 	& \multirow{3}{4cm}{Use INDIRECT(2) to remove
%% double indirection and call MOVE(2) to copy data}	& \\
%% st$->$a[1]=t[3];	& MOVE(2) & & \\
%% & & &\\
%% %& & &\\
%% %& & &\\
%% \hline
%% (*rnd\_T0)++	& ADD(1); STORE(1);	&it can be replaced by
%% *rnd\_T0=*rnd\_T0+1;	& \\
%% \hline
%% pit\_shrp( code,  &	FUNC(4);&	  \multirow{2}{4cm}{*round\_T0 is passed by indirection}	&\\
%% PIT\_SHARP, *round\_T0, L\_SUBFR); &	INDIRECT(1);& 	&\\
%% \hline
%% indice[0] = & \multirow{2}{*}{INDIRECT(2);}	& \multirow{2}{*}{Double indirection} &\\
%% indirect\_dico1[indice[0]];	& & &\\
%% \hline
%% sqr = indice[0] +indice[1] +indice[2] +indice[3] +indice[4];&	PTR\_INIT(1);
%% ADD(4);	&Can be done in a loop	&\\
%% \hline
%% \end{supertabular}
%% \end{center}

\subsection{Tests and Portability}
Compiled and tested on a PC (Windows XP) platform with MS Visual C++ 2005 and
in Cygwin with gcc (version 3.4.4).

\subsection{Example code}
A demonstration program, \textit{flc\_example.c}, serves as an example
and guideline for the illustration of the tool usage. To compile a
demonstration program, Windows MSVC and Cygwin gcc makefiles are
enclosed as \textit{makefile.cl} and \textit{makefile.unx},
respectively.

Below you can find the output screen when executing the demonstration program.
\begin{verbatim}
===== Call Graph and total ops per function =====
Function                     Calls              Ops         Ops/Call
-----------
ROOT                             1                0                0
-Autocorr                      100           975900             9759
--Set_Zero                     200             4100             20.5
-Lev_dur                       100            99600              996

===== Program Memory Usage by Function =====

Function            ADD  MULT   MAC  MOVE STORE LOGIC SHIFT BRNCH   DIV
-----------
Set_Zero              0     0     0     1     0     0     0     0     0
Autocorr              1     4    17     0    21     0     0     2     0
Lev_dur               0     2     5     5     3     0     1     1     2
ROOT                  0     0     0     0     0     0     0     0     0
-----------
totals                1     6    22     6    24     0     1     3     2

--------------------------------


Function           SQRT TRANC  FUNC  LOOP   IND   PTR  MISC
-----------
Set_Zero              0     0     0     1     0     1     0
Autocorr              0     0     2     2     1     6     0
Lev_dur               0     0     0     3     4     5     0
ROOT                  0     0     2     0     0     0     0
-----------
totals                0     0     4     6     5    12     0


===== SUMMARY =====
Total Ops: 1.0796e+06
Total Program ROM usage: 83  (word)


===== Per Frame Summary =====
Number of Frames: 100
Average Ops/frame: 10796.00   Max Ops/frame: 10796

===== ESTIMATED COMPLEXITY (Frame length is 20.00 ms) =====
Maximum complexity: 0.539800 WMOPS
Average complexity: 0.539800 WMOPS

Estimated fixed point complexity with 1.1 scaling factor:
Maximum complexity: 0.593780 WMOPS
Average complexity: 0.593780 WMOPS

\end{verbatim}

%-------------------------------------------------------------------------
% Table providing the change of complexity weight for individual operators between STL versions
%-------------------------------------------------------------------------
\begin{longtable}{|c|c|c|c|c|}
\caption{Complexity weight history for each basic operator.} \label{tbl:operators-weight} \\

\hline
    \multicolumn{1}{|c|}{\textbf{Operator}} &
    \multicolumn{1}{c|} {\textbf{STL2000}} &
    \multicolumn{1}{c|}{\textbf{STL2005}} &
    \multicolumn{1}{c|}{\textbf{STL2009}} &
    \multicolumn{1}{c|}{\textbf{STL2019}}\\ \hline
\endfirsthead

\multicolumn{5}{c}%
{{\small\sl (\tablename\ \thetable{} -- continued from previous page)}} \\
\hline
\multicolumn{1}{|c|}{\textbf{Operator}} &
\multicolumn{1}{c|} {\textbf{STL2000}} &
\multicolumn{1}{c|}{\textbf{STL2005}} &
\multicolumn{1}{c|}{\textbf{STL2009}} &
\multicolumn{1}{c|}{\textbf{STL2019}}\\ \hline
\endhead
\hline
\multicolumn{5}{r}{{\small\sl (Continued on next page)}} \\
\endfoot

\hline
\endlastfoot

add                     & 1       & 1       & 1       & 1        \\
sub                     & 1       & 1       & 1       & 1        \\
abs\_s                  & 1       & 1       & 1       & 1        \\
shl                     & 1       & 1       & 1       & 1        \\
shr                     & 1       & 1       & 1       & 1        \\
extract\_h              & 1       & 1       & 1       & 1        \\
extract\_l              & 1       & 1       & 1       & 1        \\
mult                    & 1       & 1       & 1       & 1        \\
L\_mult                 & 1       & 1       & 1       & 1        \\
negate                  & 1       & 1       & 1       & 1        \\
round / round\_fx       & 1       & 1       & 1       & 1        \\
L\_mac                  & 1       & 1       & 1       & 1        \\
L\_msu                  & 1       & 1       & 1       & 1        \\
L\_macNs                & 1       & 1       & 1       & 1        \\
L\_msuNs                & 1       & 1       & 1       & 1        \\
L\_add                  & 2       & 1       & 1       & 1        \\
L\_sub                  & 2       & 1       & 1       & 1        \\
L\_add\_c               & 2       & 2       & 2       & 2        \\
L\_sub\_c               & 2       & 2       & 2       & 2        \\
L\_negate               & 2       & 1       & 1       & 1        \\
L\_shl                  & 2       & 1       & 1       & 1        \\
L\_shr                  & 2       & 1       & 1       & 1        \\
mult\_r                 & 2       & 1       & 1       & 1        \\
shr\_r                  & 3       & 3       & 3       & 2        \\
mac\_r                  & 2       & 1       & 1       & 1        \\
msu\_r                  & 2       & 1       & 1       & 1        \\
L\_deposit\_h           & 2       & 1       & 1       & 1        \\
L\_deposit\_l           & 2       & 1       & 1       & 1        \\
L\_shr\_r               & 3       & 3       & 3       & 2        \\
L\_abs                  & 2       & 1       & 1       & 1        \\
L\_sat                  & 4       & 4       & 4       & 1        \\
norm\_s                 & 15      & 1       & 1       & 1        \\
div\_s                  & 18      & 18      & 18      & 18       \\
norm\_l                 & 30      & 1       & 1       & 1        \\
move16                  & 1       & 1       & 1       & 1        \\
move32                  & 2       & 2       & 2       & 1        \\
Logic16                 & 1       & 1       & 1       & 1        \\
Logic32                 & 2       & 2       & 2       & 1        \\
Test                    & 2       & 2       & 2       & 1        \\
s\_max                  & -       & 1       & 1       & 1        \\
s\_min                  & -       & 1       & 1       & 1        \\
L\_max                  & -       & 1       & 1       & 1        \\
L\_min                  & -       & 1       & 1       & 1        \\
L40\_max                & -       & 1       & 1       & 1        \\
L40\_min                & -       & 1       & 1       & 1        \\
shl\_r / shift\_r       & 2       & 3       & 3       & 2        \\
L\_shl\_r / L\_shift\_r & 3       & 3       & 3       & 2        \\
L40\_shr\_r             & -       & 3       & 3       & 2        \\
L40\_shl\_r             & -       & 3       & 3       & 2        \\
norm\_L40               & -       & 1       & 1       & 1        \\
L40\_shl                & -       & 1       & 1       & 1        \\
L40\_shr                & -       & 1       & 1       & 1        \\
L40\_negate             & -       & 1       & 1       & 1        \\
L40\_add                & -       & 1       & 1       & 1        \\
L40\_sub                & -       & 1       & 1       & 1        \\
L40\_abs                & -       & 1       & 1       & 1        \\
L40\_mult               & -       & 1       & 1       & 1        \\
L40\_mac                & -       & 1       & 1       & 1        \\
mac\_r40                & -       & 2       & 2       & 2        \\
L40\_msu                & -       & 1       & 1       & 1        \\
msu\_r40                & -       & 2       & 2       & 2        \\
Mpy\_32\_16\_ss         & -       & 2       & 2       & 2        \\
Mpy\_32\_32\_ss         & -       & 4       & 4       & 2        \\
L\_mult0                & 1       & 1       & 1       & 1        \\
L\_mac0                 & 1       & 1       & 1       & 1        \\
L\_msu0                 & 1       & 1       & 1       & 1        \\
lshl                    & -       & 1       & 1       & 1        \\
lshr                    & -       & 1       & 1       & 1        \\
L\_lshl                 & -       & 1       & 1       & 1        \\
L\_lshr                 & -       & 1       & 1       & 1        \\
L40\_lshl               & -       & 1       & 1       & 1        \\
L40\_lshr               & -       & 1       & 1       & 1        \\
s\_and                  & -       & 1       & 1       & 1        \\
s\_or                   & -       & 1       & 1       & 1        \\
s\_xor                  & -       & 1       & 1       & 1        \\
L\_and                  & -       & 1       & 1       & 1        \\
L\_or                   & -       & 1       & 1       & 1        \\
L\_xor                  & -       & 1       & 1       & 1        \\
rotl                    & -       & 3       & 3       & 3        \\
rotr                    & -       & 3       & 3       & 3        \\
L\_rotl                 & -       & 3       & 3       & 3        \\
L\_rotr                 & -       & 3       & 3       & 3        \\
L40\_set                & -       & 3       & 3       & 1        \\
L40\_deposit\_h         & -       & 1       & 1       & 1        \\
L40\_deposit\_l         & -       & 1       & 1       & 1        \\
L40\_deposit32          & -       & 1       & 1       & 1        \\
Extract40\_H            & -       & 1       & 1       & 1        \\
Extract40\_L            & -       & 1       & 1       & 1        \\
L\_Extract40            & -       & 1       & 1       & 1        \\
L40\_round              & -       & 1       & 1       & 1        \\
L\_saturate40           & -       & 1       & 1       & 1        \\
round40                 & -       & 1       & 1       & 1        \\
IF                      & -       & 4       & 4       & 3        \\
GOTO                    & -       & 4       & 4       & 2        \\
BREAK                   & -       & 4       & 4       & 2        \\
SWITCH                  & -       & 8       & 8       & 6        \\
FOR                     & -       & 3       & 3       & 3        \\
WHILE                   & -       & 4       & 4       & 3        \\
CONTINUE                & -       & 4       & 4       & 2        \\
L\_mls                  & 6       & 5       & 5       & 1        \\
div\_l                  & 32      & 32      & 32      & 32       \\
i\_mult                 & 1       & 3       & 3       & 1        \\
CL\_shr                 & -       & -       & -       & 1        \\
CL\_shl                 & -       & -       & -       & 1        \\
CL\_add                 & -       & -       & -       & 1        \\
CL\_sub                 & -       & -       & -       & 1        \\
CL\_scale               & -       & -       & -       & 1        \\
CL\_dscale              & -       & -       & -       & 1        \\
CL\_msu\_j              & -       & -       & -       & 1        \\
CL\_mac\_j              & -       & -       & -       & 1        \\
CL\_move                & -       & -       & -       & 1        \\
CL\_Extract\_real       & -       & -       & -       & 1        \\
CL\_Extract\_imag       & -       & -       & -       & 1        \\
CL\_form                & -       & -       & -       & 1        \\
CL\_multr\_32x16        & -       & -       & -       & 2        \\
CL\_negate              & -       & -       & -       & 1        \\
CL\_conjugate           & -       & -       & -       & 1        \\
CL\_mul\_j              & -       & -       & -       & 1        \\
CL\_swap\_real\_imag    & -       & -       & -       & 1        \\
C\_add                  & -       & -       & -       & 1        \\
C\_sub                  & -       & -       & -       & 1        \\
C\_mul\_j               & -       & -       & -       & 1        \\
C\_multr                & -       & -       & -       & 2        \\
C\_form                 & -       & -       & -       & 1        \\
CL\_scale\_32           & -       & -       & -       & 1        \\
CL\_dscale\_32          & -       & -       & -       & 1        \\
CL\_multr\_32x32        & -       & -       & -       & 2        \\
C\_mac\_r               & -       & -       & -       & 2        \\
C\_msu\_r               & -       & -       & -       & 2        \\
CL\_round32\_16         & -       & -       & -       & 1        \\
C\_Extract\_real        & -       & -       & -       & 1        \\
C\_Extract\_imag        & -       & -       & -       & 1        \\
C\_scale                & -       & -       & -       & 1        \\
C\_negate               & -       & -       & -       & 1        \\
C\_conjugate            & -       & -       & -       & 1        \\
C\_shr                  & -       & -       & -       & 1        \\
C\_shl                  & -       & -       & -       & 1        \\
move64                  & -       & -       & -       & 1        \\
W\_add\_nosat           & -       & -       & -       & 1        \\
W\_sub\_nosat           & -       & -       & -       & 1        \\
W\_shl                  & -       & -       & -       & 1        \\
W\_shr                  & -       & -       & -       & 1        \\
W\_shl\_nosat           & -       & -       & -       & 1        \\
W\_shr\_nosat           & -       & -       & -       & 1        \\
W\_mac\_32\_16          & -       & -       & -       & 1        \\
W\_msu\_32\_16          & -       & -       & -       & 1        \\
W\_mult\_32\_16         & -       & -       & -       & 1        \\
W\_mult0\_16\_16        & -       & -       & -       & 1        \\
W\_mac0\_16\_16         & -       & -       & -       & 1        \\
W\_msu0\_16\_16         & -       & -       & -       & 1        \\
W\_mult\_16\_16         & -       & -       & -       & 1        \\
W\_mac\_16\_16          & -       & -       & -       & 1        \\
W\_msu\_16\_16          & -       & -       & -       & 1        \\
W\_shl\_sat\_l          & -       & -       & -       & 1        \\
W\_sat\_l               & -       & -       & -       & 1        \\
W\_sat\_m               & -       & -       & -       & 1        \\
W\_deposit32\_l         & -       & -       & -       & 1        \\
W\_deposit32\_h         & -       & -       & -       & 1        \\
W\_extract\_l           & -       & -       & -       & 1        \\
W\_extract\_h           & -       & -       & -       & 1        \\
W\_round48\_L           & -       & -       & -       & 1        \\
W\_round32\_s           & -       & -       & -       & 1        \\
W\_norm                 & -       & -       & -       & 1        \\
W\_add                  & -       & -       & -       & 1        \\
W\_sub                  & -       & -       & -       & 1        \\
W\_neg                  & -       & -       & -       & 1        \\
W\_abs                  & -       & -       & -       & 1        \\
W\_mult\_32\_32         & -       & -       & -       & 1        \\
W\_mult0\_32\_32        & -       & -       & -       & 1        \\
W\_lshl                 & -       & -       & -       & 1        \\
W\_lshr                 & -       & -       & -       & 1        \\
W\_round64\_L           & -       & -       & -       & 1        \\
Mpy\_32\_16\_1          & -       & -       & -       & 1        \\
Mpy\_32\_16\_r          & -       & -       & -       & 1        \\
Mpy\_32\_32             & -       & -       & -       & 1        \\
Mpy\_32\_32\_r          & -       & -       & -       & 1        \\
Madd\_32\_16            & -       & -       & -       & 1        \\
Madd\_32\_16\_r         & -       & -       & -       & 1        \\
Msub\_32\_16            & -       & -       & -       & 1        \\
Msub\_32\_16\_r         & -       & -       & -       & 1        \\
Madd\_32\_32            & -       & -       & -       & 1        \\
Madd\_32\_32\_r         & -       & -       & -       & 1        \\
Msub\_32\_32            & -       & -       & -       & 1        \\
Msub\_32\_32\_r         & -       & -       & -       & 1        \\
UL\_addNs               & -       & -       & -       & 1        \\
UL\_subNs               & -       & -       & -       & 1        \\
UL\_Mpy\_32\_32         & -       & -       & -       & 1        \\
Mpy\_32\_32\_uu         & -       & -       & -       & 2        \\
Mpy\_32\_16\_uu         & -       & -       & -       & 2        \\
norm\_ul                & -       & -       & -       & 1        \\
UL\_deposit\_l          & -       & -       & -       & 1        \\
LT\_16                  & -       & -       & -       & 1        \\
GT\_16                  & -       & -       & -       & 1        \\
LE\_16                  & -       & -       & -       & 1        \\
GE\_16                  & -       & -       & -       & 1        \\
EQ\_16                  & -       & -       & -       & 1        \\
NE\_16                  & -       & -       & -       & 1        \\
LT\_32                  & -       & -       & -       & 1        \\
GT\_32                  & -       & -       & -       & 1        \\
LE\_32                  & -       & -       & -       & 1        \\
GE\_32                  & -       & -       & -       & 1        \\
EQ\_32                  & -       & -       & -       & 1        \\
NE\_32                  & -       & -       & -       & 1        \\
LT\_64                  & -       & -       & -       & 1        \\
GT\_64                  & -       & -       & -       & 1        \\
LE\_64                  & -       & -       & -       & 1        \\
GE\_64                  & -       & -       & -       & 1        \\
EQ\_64                  & -       & -       & -       & 1        \\
NE\_64                  & -       & -       & -       & 1        \\
\end{longtable}


